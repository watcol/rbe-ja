# 明示的アノテーション

ボローチェッカーは参照がどれだけの間有効か示すのに、ライフタイムの明示的
アノテーションを使用します。ライフタイムが省略[^1]されない場合、Rustでは
参照のライフタイムがどのようなものかを明示的に示すことが必要です。明示的
アノテーションは、以下のようにアポストロフィの後に文字を置くことで表せます。

```rust,ignore
foo<'a>
// `foo`はライフタイムパラメータ`'a`を持っています。
```

[closures][anonymity]のように、ライフタイムを使うにはジェネリクスが必要です。
更に、`foo`のライフタイムは`'a`を超えることはないということを表しています。
型を明示した場合は`'a`は`&'a T`となります。

複数のライフタイムを持つ時、構文は以下のようになります。

```rust,ignore
foo<'a, 'b>
// `foo`はライフタイムパラメータ`'a`と`'b`を持っています。
```

この時、`foo`のライフタイムは`'a`も`'b`も超えることはないということを表しています。

以下の例で明示的アノテーションの使い方を見てください。

```rust,editable,ignore,mdbook-runnable
// `print_refs`は少なくとも`print_refs`のライフタイムより長い2つ
// の異なったライフタイムを持つ2つの`i32`の参照をとります。
fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("x is {} and y is {}", x, y);
}

// 引数は取らないが、ライフタイムパラメータ`'a`を持つ関数。
fn failed_borrow<'a>() {
    let _x = 12;

    // エラー: `_x`のライフタイムが短いです。
    //let y: &'a i32 = &_x;
    // `'a`を関数内で明示的アノテーションとして使うことを試みましたが、`&_x`の
    // ライフタイムは`y`より短くいため、できません。短いライフタイムを長い
    // ライフタイムを持つものに強制させることはできない。
}

fn main() {
    // 下で使う変数を作る。
    let (four, nine) = (4, 9);
    
    // 両方の変数の借用(`&`)が関数に渡される。
    print_refs(&four, &nine);
    // 借用された入力は借用したものより長生きしなくてはならない。
    // 言い換えれば、`four`と`nine`は`print_refs`より長いライフタイムを
    // 持つ必要がある。
    
    failed_borrow();
    // `failed_borrow`関数のライフタイムよりも長くなるような`'a`の参照は
    // 存在しませんが、このような場合、`'a`は`'static`になるため、長いです。
}
```

[^1]: [省略][elision] ライフタイムが暗示的に注釈されることを意味します。

### こちらも参照:

- [ジェネリック][generics]
- [クロージャ][closures]

[anonymity]: ../../fn/closures/anonymity.md
[closures]: ../../fn/closures.md
[elision]: elision.md
[generics]: ../../generics.md
