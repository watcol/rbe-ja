<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Example</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">イントロダクション</a></li><li class="chapter-item "><a href="hello.html"><strong aria-hidden="true">1.</strong> Hello World</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello/comment.html"><strong aria-hidden="true">1.1.</strong> コメント</a></li><li class="chapter-item "><a href="hello/print.html"><strong aria-hidden="true">1.2.</strong> フォーマットしてプリント</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello/print/print_debug.html"><strong aria-hidden="true">1.2.1.</strong> デバッグ</a></li><li class="chapter-item "><a href="hello/print/print_display.html"><strong aria-hidden="true">1.2.2.</strong> ディスプレイ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello/print/print_display/testcase_list.html"><strong aria-hidden="true">1.2.2.1.</strong> テストケース: リスト</a></li></ol></li><li class="chapter-item "><a href="hello/print/fmt.html"><strong aria-hidden="true">1.2.3.</strong> フォーマット</a></li></ol></li></ol></li><li class="chapter-item "><a href="primitives.html"><strong aria-hidden="true">2.</strong> プリミティブ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="primitives/literals.html"><strong aria-hidden="true">2.1.</strong> リテラルと演算子</a></li><li class="chapter-item "><a href="primitives/tuples.html"><strong aria-hidden="true">2.2.</strong> タプル</a></li><li class="chapter-item "><a href="primitives/array.html"><strong aria-hidden="true">2.3.</strong> 配列とスライス</a></li></ol></li><li class="chapter-item "><a href="custom_types.html"><strong aria-hidden="true">3.</strong> カスタム型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="custom_types/structs.html"><strong aria-hidden="true">3.1.</strong> 構造体</a></li><li class="chapter-item "><a href="custom_types/enum.html"><strong aria-hidden="true">3.2.</strong> Enum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="custom_types/enum/enum_use.html"><strong aria-hidden="true">3.2.1.</strong> use</a></li><li class="chapter-item "><a href="custom_types/enum/c_like.html"><strong aria-hidden="true">3.2.2.</strong> Cライクなenum</a></li><li class="chapter-item "><a href="custom_types/enum/testcase_linked_list.html"><strong aria-hidden="true">3.2.3.</strong> テストケース: 連結リスト</a></li></ol></li><li class="chapter-item "><a href="custom_types/constants.html"><strong aria-hidden="true">3.3.</strong> 定数</a></li></ol></li><li class="chapter-item "><a href="variable_bindings.html"><strong aria-hidden="true">4.</strong> 変数束縛</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="variable_bindings/mut.html"><strong aria-hidden="true">4.1.</strong> 可変性</a></li><li class="chapter-item "><a href="variable_bindings/scope.html"><strong aria-hidden="true">4.2.</strong> スコープとシャドーイング</a></li><li class="chapter-item "><a href="variable_bindings/declare.html"><strong aria-hidden="true">4.3.</strong> 宣言</a></li><li class="chapter-item "><a href="variable_bindings/freeze.html"><strong aria-hidden="true">4.4.</strong> フリーズ</a></li></ol></li><li class="chapter-item "><a href="types.html"><strong aria-hidden="true">5.</strong> 型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/cast.html"><strong aria-hidden="true">5.1.</strong> キャスト</a></li><li class="chapter-item "><a href="types/literals.html"><strong aria-hidden="true">5.2.</strong> リテラル</a></li><li class="chapter-item "><a href="types/inference.html"><strong aria-hidden="true">5.3.</strong> 推論</a></li><li class="chapter-item "><a href="types/alias.html"><strong aria-hidden="true">5.4.</strong> エイリアシング</a></li></ol></li><li class="chapter-item "><a href="conversion.html"><strong aria-hidden="true">6.</strong> 変換</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="conversion/from_into.html"><strong aria-hidden="true">6.1.</strong> FromとInto</a></li><li class="chapter-item "><a href="conversion/try_from_try_into.html"><strong aria-hidden="true">6.2.</strong> TryFromとTryInto</a></li><li class="chapter-item "><a href="conversion/string.html"><strong aria-hidden="true">6.3.</strong> Stringから変換、Stringに変換</a></li></ol></li><li class="chapter-item "><a href="expression.html"><strong aria-hidden="true">7.</strong> 式</a></li><li class="chapter-item "><a href="flow_control.html"><strong aria-hidden="true">8.</strong> フロー制御</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/if_else.html"><strong aria-hidden="true">8.1.</strong> if/else</a></li><li class="chapter-item "><a href="flow_control/loop.html"><strong aria-hidden="true">8.2.</strong> loop</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/loop/nested.html"><strong aria-hidden="true">8.2.1.</strong> ネストとラベル</a></li><li class="chapter-item "><a href="flow_control/loop/return.html"><strong aria-hidden="true">8.2.2.</strong> ループの返り値</a></li></ol></li><li class="chapter-item "><a href="flow_control/while.html"><strong aria-hidden="true">8.3.</strong> while</a></li><li class="chapter-item "><a href="flow_control/for.html"><strong aria-hidden="true">8.4.</strong> forとrange</a></li><li class="chapter-item "><a href="flow_control/match.html"><strong aria-hidden="true">8.5.</strong> match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/match/destructuring.html"><strong aria-hidden="true">8.5.1.</strong> 分割代入</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/match/destructuring/destructure_tuple.html"><strong aria-hidden="true">8.5.1.1.</strong> タプル</a></li><li class="chapter-item "><a href="flow_control/match/destructuring/destructure_enum.html"><strong aria-hidden="true">8.5.1.2.</strong> enum</a></li><li class="chapter-item "><a href="flow_control/match/destructuring/destructure_pointers.html"><strong aria-hidden="true">8.5.1.3.</strong> ポインタ/参照</a></li><li class="chapter-item "><a href="flow_control/match/destructuring/destructure_structures.html"><strong aria-hidden="true">8.5.1.4.</strong> 構造体</a></li></ol></li><li class="chapter-item "><a href="flow_control/match/guard.html"><strong aria-hidden="true">8.5.2.</strong> ガード</a></li><li class="chapter-item "><a href="flow_control/match/binding.html"><strong aria-hidden="true">8.5.3.</strong> バインディング</a></li></ol></li><li class="chapter-item "><a href="flow_control/if_let.html"><strong aria-hidden="true">8.6.</strong> if let</a></li><li class="chapter-item "><a href="flow_control/while_let.html"><strong aria-hidden="true">8.7.</strong> while let</a></li></ol></li><li class="chapter-item "><a href="fn.html"><strong aria-hidden="true">9.</strong> 関数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fn/methods.html"><strong aria-hidden="true">9.1.</strong> メソッド</a></li><li class="chapter-item "><a href="fn/closures.html"><strong aria-hidden="true">9.2.</strong> クロージャ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fn/closures/capture.html"><strong aria-hidden="true">9.2.1.</strong> キャプチャ</a></li><li class="chapter-item "><a href="fn/closures/input_parameters.html"><strong aria-hidden="true">9.2.2.</strong> 引数として</a></li><li class="chapter-item "><a href="fn/closures/anonymity.html"><strong aria-hidden="true">9.2.3.</strong> 型匿名性</a></li><li class="chapter-item "><a href="fn/closures/input_functions.html"><strong aria-hidden="true">9.2.4.</strong> 入力関数</a></li><li class="chapter-item "><a href="fn/closures/output_parameters.html"><strong aria-hidden="true">9.2.5.</strong> 返り値として</a></li><li class="chapter-item "><a href="fn/closures/closure_examples.html"><strong aria-hidden="true">9.2.6.</strong> stdでの例</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="fn/closures/closure_examples/iter_any.html"><strong aria-hidden="true">9.2.6.1.</strong> Iterator::any</a></li><li class="chapter-item "><a href="fn/closures/closure_examples/iter_find.html"><strong aria-hidden="true">9.2.6.2.</strong> イテレータを検索</a></li></ol></li></ol></li><li class="chapter-item "><a href="fn/hof.html"><strong aria-hidden="true">9.3.</strong> 高階関数</a></li><li class="chapter-item "><a href="fn/diverging.html"><strong aria-hidden="true">9.4.</strong> 発散関数</a></li></ol></li><li class="chapter-item "><a href="mod.html"><strong aria-hidden="true">10.</strong> モジュール</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mod/visibility.html"><strong aria-hidden="true">10.1.</strong> 可視性</a></li><li class="chapter-item "><a href="mod/struct_visibility.html"><strong aria-hidden="true">10.2.</strong> 構造体の可視性</a></li><li class="chapter-item "><a href="mod/use.html"><strong aria-hidden="true">10.3.</strong> use宣言</a></li><li class="chapter-item "><a href="mod/super.html"><strong aria-hidden="true">10.4.</strong> superとself</a></li><li class="chapter-item "><a href="mod/split.html"><strong aria-hidden="true">10.5.</strong> ファイル階層</a></li></ol></li><li class="chapter-item "><a href="crates.html"><strong aria-hidden="true">11.</strong> クレート</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crates/lib.html"><strong aria-hidden="true">11.1.</strong> ライブラリ</a></li><li class="chapter-item "><a href="crates/link.html"><strong aria-hidden="true">11.2.</strong> extern crate</a></li></ol></li><li class="chapter-item "><a href="cargo.html"><strong aria-hidden="true">12.</strong> Cargo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/deps.html"><strong aria-hidden="true">12.1.</strong> 依存</a></li><li class="chapter-item "><a href="cargo/conventions.html"><strong aria-hidden="true">12.2.</strong> 慣習</a></li><li class="chapter-item "><a href="cargo/test.html"><strong aria-hidden="true">12.3.</strong> テスト</a></li><li class="chapter-item "><a href="cargo/build_scripts.html"><strong aria-hidden="true">12.4.</strong> ビルドスクリプト</a></li></ol></li><li class="chapter-item "><a href="attribute.html"><strong aria-hidden="true">13.</strong> 属性</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="attribute/unused.html"><strong aria-hidden="true">13.1.</strong> dead_code</a></li><li class="chapter-item "><a href="attribute/crate.html"><strong aria-hidden="true">13.2.</strong> クレート</a></li><li class="chapter-item "><a href="attribute/cfg.html"><strong aria-hidden="true">13.3.</strong> cfg</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="attribute/cfg/custom.html"><strong aria-hidden="true">13.3.1.</strong> カスタマイズ</a></li></ol></li></ol></li><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">14.</strong> ジェネリック</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/gen_fn.html"><strong aria-hidden="true">14.1.</strong> 関数</a></li><li class="chapter-item "><a href="generics/impl.html"><strong aria-hidden="true">14.2.</strong> 実装</a></li><li class="chapter-item "><a href="generics/gen_trait.html"><strong aria-hidden="true">14.3.</strong> トレイト</a></li><li class="chapter-item "><a href="generics/bounds.html"><strong aria-hidden="true">14.4.</strong> 境界</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/bounds/testcase_empty.html"><strong aria-hidden="true">14.4.1.</strong> テストケース: 空の境界</a></li></ol></li><li class="chapter-item "><a href="generics/multi_bounds.html"><strong aria-hidden="true">14.5.</strong> 複数の境界</a></li><li class="chapter-item "><a href="generics/where.html"><strong aria-hidden="true">14.6.</strong> Where節</a></li><li class="chapter-item "><a href="generics/new_types.html"><strong aria-hidden="true">14.7.</strong> New Typeイディオム</a></li><li class="chapter-item "><a href="generics/assoc_items.html"><strong aria-hidden="true">14.8.</strong> 関連要素</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/assoc_items/the_problem.html"><strong aria-hidden="true">14.8.1.</strong> 問題</a></li><li class="chapter-item "><a href="generics/assoc_items/types.html"><strong aria-hidden="true">14.8.2.</strong> 関連型</a></li></ol></li><li class="chapter-item "><a href="generics/phantom.html"><strong aria-hidden="true">14.9.</strong> 幽霊型パラメータ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/phantom/testcase_units.html"><strong aria-hidden="true">14.9.1.</strong> テストケース: 単位の明確化</a></li></ol></li></ol></li><li class="chapter-item "><a href="scope.html"><strong aria-hidden="true">15.</strong> スコープのルール</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/raii.html"><strong aria-hidden="true">15.1.</strong> RAII</a></li><li class="chapter-item "><a href="scope/move.html"><strong aria-hidden="true">15.2.</strong> 所有権とムーブ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/move/mut.html"><strong aria-hidden="true">15.2.1.</strong> 可変性</a></li></ol></li><li class="chapter-item "><a href="scope/borrow.html"><strong aria-hidden="true">15.3.</strong> 借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/borrow/mut.html"><strong aria-hidden="true">15.3.1.</strong> 可変性</a></li><li class="chapter-item "><a href="scope/borrow/alias.html"><strong aria-hidden="true">15.3.2.</strong> エイリアシング</a></li><li class="chapter-item "><a href="scope/borrow/ref.html"><strong aria-hidden="true">15.3.3.</strong> refパターン</a></li></ol></li><li class="chapter-item "><a href="scope/lifetime.html"><strong aria-hidden="true">15.4.</strong> ライフタイム</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/lifetime/explicit.html"><strong aria-hidden="true">15.4.1.</strong> 明示的アノテーション</a></li><li class="chapter-item "><a href="scope/lifetime/fn.html"><strong aria-hidden="true">15.4.2.</strong> 関数</a></li><li class="chapter-item "><a href="scope/lifetime/methods.html"><strong aria-hidden="true">15.4.3.</strong> メソッド</a></li><li class="chapter-item "><a href="scope/lifetime/struct.html"><strong aria-hidden="true">15.4.4.</strong> 構造体</a></li><li class="chapter-item "><a href="scope/lifetime/trait.html"><strong aria-hidden="true">15.4.5.</strong> トレイト</a></li><li class="chapter-item "><a href="scope/lifetime/lifetime_bounds.html"><strong aria-hidden="true">15.4.6.</strong> ライフタイムの境界</a></li><li class="chapter-item "><a href="scope/lifetime/lifetime_coercion.html"><strong aria-hidden="true">15.4.7.</strong> ライフタイムの圧縮</a></li><li class="chapter-item "><a href="scope/lifetime/static_lifetime.html"><strong aria-hidden="true">15.4.8.</strong> 静的ライフタイム</a></li><li class="chapter-item "><a href="scope/lifetime/elision.html"><strong aria-hidden="true">15.4.9.</strong> 省略</a></li></ol></li></ol></li><li class="chapter-item "><a href="trait.html"><strong aria-hidden="true">16.</strong> トレイト</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="trait/derive.html"><strong aria-hidden="true">16.1.</strong> 継承</a></li><li class="chapter-item "><a href="trait/dyn.html"><strong aria-hidden="true">16.2.</strong> dynでトレイトを返す</a></li><li class="chapter-item "><a href="trait/ops.html"><strong aria-hidden="true">16.3.</strong> 演算子オーバーロード</a></li><li class="chapter-item "><a href="trait/drop.html"><strong aria-hidden="true">16.4.</strong> Drop</a></li><li class="chapter-item "><a href="trait/iter.html"><strong aria-hidden="true">16.5.</strong> イテレータ</a></li><li class="chapter-item "><a href="trait/impl_trait.html"><strong aria-hidden="true">16.6.</strong> impl Trait</a></li><li class="chapter-item "><a href="trait/clone.html"><strong aria-hidden="true">16.7.</strong> 複製</a></li><li class="chapter-item "><a href="trait/supertraits.html"><strong aria-hidden="true">16.8.</strong> 親トレイト</a></li><li class="chapter-item "><a href="trait/disambiguating.html"><strong aria-hidden="true">16.9.</strong> 重複するトレイトの明確化</a></li></ol></li><li class="chapter-item "><a href="macros.html"><strong aria-hidden="true">17.</strong> macro_rules!</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macros/syntax.html"><strong aria-hidden="true">17.1.</strong> 構文</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macros/designators.html"><strong aria-hidden="true">17.1.1.</strong> マクロ指定子</a></li><li class="chapter-item "><a href="macros/overload.html"><strong aria-hidden="true">17.1.2.</strong> オーバーロード</a></li><li class="chapter-item "><a href="macros/repeat.html"><strong aria-hidden="true">17.1.3.</strong> 繰り返し</a></li></ol></li><li class="chapter-item "><a href="macros/dry.html"><strong aria-hidden="true">17.2.</strong> 同じことを繰り返さない(DRY)</a></li><li class="chapter-item "><a href="macros/dsl.html"><strong aria-hidden="true">17.3.</strong> ドメイン固有言語(DSL)</a></li><li class="chapter-item "><a href="macros/variadics.html"><strong aria-hidden="true">17.4.</strong> 可変長引数</a></li></ol></li><li class="chapter-item "><a href="error.html"><strong aria-hidden="true">18.</strong> エラー処理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/panic.html"><strong aria-hidden="true">18.1.</strong> panic</a></li><li class="chapter-item "><a href="error/option_unwrap.html"><strong aria-hidden="true">18.2.</strong> Optionとunwrap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/option_unwrap/question_mark.html"><strong aria-hidden="true">18.2.1.</strong> ?でOptionを解析する</a></li><li class="chapter-item "><a href="error/option_unwrap/map.html"><strong aria-hidden="true">18.2.2.</strong> コンビネータ: map</a></li><li class="chapter-item "><a href="error/option_unwrap/and_then.html"><strong aria-hidden="true">18.2.3.</strong> コンビネータ: and_then</a></li></ol></li><li class="chapter-item "><a href="error/result.html"><strong aria-hidden="true">18.3.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/result/result_map.html"><strong aria-hidden="true">18.3.1.</strong> Resultのmap</a></li><li class="chapter-item "><a href="error/result/result_alias.html"><strong aria-hidden="true">18.3.2.</strong> Resultのエイリアス</a></li><li class="chapter-item "><a href="error/result/early_returns.html"><strong aria-hidden="true">18.3.3.</strong> 早期のリターン</a></li><li class="chapter-item "><a href="error/result/enter_question_mark.html"><strong aria-hidden="true">18.3.4.</strong> ?の導入</a></li></ol></li><li class="chapter-item "><a href="error/multiple_error_types.html"><strong aria-hidden="true">18.4.</strong> 複数のエラー型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/multiple_error_types/option_result.html"><strong aria-hidden="true">18.4.1.</strong> ResultをOptionから引き出す</a></li><li class="chapter-item "><a href="error/multiple_error_types/define_error_type.html"><strong aria-hidden="true">18.4.2.</strong> エラー型の定義</a></li><li class="chapter-item "><a href="error/multiple_error_types/boxing_errors.html"><strong aria-hidden="true">18.4.3.</strong> エラーをBoxに入れる</a></li><li class="chapter-item "><a href="error/multiple_error_types/reenter_question_mark.html"><strong aria-hidden="true">18.4.4.</strong> 他の?の使い方</a></li><li class="chapter-item "><a href="error/multiple_error_types/wrap_error.html"><strong aria-hidden="true">18.4.5.</strong> エラーをラップする</a></li></ol></li><li class="chapter-item "><a href="error/iter_result.html"><strong aria-hidden="true">18.5.</strong> Resultを繰り返す</a></li></ol></li><li class="chapter-item "><a href="std.html"><strong aria-hidden="true">19.</strong> Stdライブラリの型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/box.html"><strong aria-hidden="true">19.1.</strong> ボックス、スタック、ヒープ</a></li><li class="chapter-item "><a href="std/vec.html"><strong aria-hidden="true">19.2.</strong> ベクター</a></li><li class="chapter-item "><a href="std/str.html"><strong aria-hidden="true">19.3.</strong> 文字列</a></li><li class="chapter-item "><a href="std/option.html"><strong aria-hidden="true">19.4.</strong> Option</a></li><li class="chapter-item "><a href="std/result.html"><strong aria-hidden="true">19.5.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/result/question_mark.html"><strong aria-hidden="true">19.5.1.</strong> ?</a></li></ol></li><li class="chapter-item "><a href="std/panic.html"><strong aria-hidden="true">19.6.</strong> panic!</a></li><li class="chapter-item "><a href="std/hash.html"><strong aria-hidden="true">19.7.</strong> ハッシュマップ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/hash/alt_key_types.html"><strong aria-hidden="true">19.7.1.</strong> 独自のキーの型</a></li><li class="chapter-item "><a href="std/hash/hashset.html"><strong aria-hidden="true">19.7.2.</strong> ハッシュセット</a></li></ol></li><li class="chapter-item "><a href="std/rc.html"><strong aria-hidden="true">19.8.</strong> Rc</a></li></ol></li><li class="chapter-item "><a href="std_misc.html"><strong aria-hidden="true">20.</strong> その他のStd</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/threads.html"><strong aria-hidden="true">20.1.</strong> スレッド</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/threads/testcase_mapreduce.html"><strong aria-hidden="true">20.1.1.</strong> テストケース: map-reduce</a></li></ol></li><li class="chapter-item "><a href="std_misc/channels.html"><strong aria-hidden="true">20.2.</strong> チャンネル</a></li><li class="chapter-item "><a href="std_misc/path.html"><strong aria-hidden="true">20.3.</strong> パス</a></li><li class="chapter-item "><a href="std_misc/file.html"><strong aria-hidden="true">20.4.</strong> ファイルI/O</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/file/open.html"><strong aria-hidden="true">20.4.1.</strong> open</a></li><li class="chapter-item "><a href="std_misc/file/create.html"><strong aria-hidden="true">20.4.2.</strong> create</a></li><li class="chapter-item "><a href="std_misc/file/read_lines.html"><strong aria-hidden="true">20.4.3.</strong> read lines</a></li></ol></li><li class="chapter-item "><a href="std_misc/process.html"><strong aria-hidden="true">20.5.</strong> 子プロセス</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/process/pipe.html"><strong aria-hidden="true">20.5.1.</strong> パイプ</a></li><li class="chapter-item "><a href="std_misc/process/wait.html"><strong aria-hidden="true">20.5.2.</strong> ウェイト</a></li></ol></li><li class="chapter-item "><a href="std_misc/fs.html"><strong aria-hidden="true">20.6.</strong> ファイルシステム制御</a></li><li class="chapter-item "><a href="std_misc/arg.html"><strong aria-hidden="true">20.7.</strong> プログラム引数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std_misc/arg/matching.html"><strong aria-hidden="true">20.7.1.</strong> 引数解析</a></li></ol></li><li class="chapter-item "><a href="std_misc/ffi.html"><strong aria-hidden="true">20.8.</strong> 外部関数インターフェース</a></li></ol></li><li class="chapter-item "><a href="testing.html"><strong aria-hidden="true">21.</strong> テスト</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/unit_testing.html"><strong aria-hidden="true">21.1.</strong> ユニットテスト</a></li><li class="chapter-item "><a href="testing/doc_testing.html"><strong aria-hidden="true">21.2.</strong> ドキュメンテーションテスト</a></li><li class="chapter-item "><a href="testing/integration_testing.html"><strong aria-hidden="true">21.3.</strong> 整合性テスト</a></li><li class="chapter-item "><a href="testing/dev_dependencies.html"><strong aria-hidden="true">21.4.</strong> 開発時依存</a></li></ol></li><li class="chapter-item "><a href="unsafe.html"><strong aria-hidden="true">22.</strong> 安全でない操作</a></li><li class="chapter-item "><a href="compatibility.html"><strong aria-hidden="true">23.</strong> 互換性</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compatibility/raw_identifiers.html"><strong aria-hidden="true">23.1.</strong> Raw識別子</a></li></ol></li><li class="chapter-item "><a href="meta.html"><strong aria-hidden="true">24.</strong> メタデータ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="meta/doc.html"><strong aria-hidden="true">24.1.</strong> ドキュメント</a></li><li class="chapter-item "><a href="meta/playpen.html"><strong aria-hidden="true">24.2.</strong> Playpen</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust By Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rust-by-example" id="rust-by-example">Rust by Example</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a>は安全性、速度、並行性に焦点を当てたモダンなシステム
プログラミング言語です。これができるのは、ガベージコレクションなしでメモリ
安全であるためです。</p>
<p>Rust by Example (RBE)は、Rustの様々な概念や標準ライブラリを実行できる例で紹介
したサンプルコード集です。この例を活用するために、<a href="https://www.rust-lang.org/tools/install">Rustをローカルに
インストール</a>して、<a href="https://doc.rust-lang.org/std/">公式ドキュメント</a>を参照することを忘れないで
ください。
興味がある方は<a href="https://github.com/rust-lang/rust-by-example">このサイトのソースコード</a>もあります。(日本語版は<a href="https://github.com/watcol/rbe-ja">こちら
</a>。)</p>
<p>それでは、始めましょう!</p>
<ul>
<li>
<p><a href="hello.html">Hello World</a> - 伝統的な「Hello World」プログラムから始めます。</p>
</li>
<li>
<p><a href="primitives.html">プリミティブ</a> - 符号付き整数、符号なし整数などのプリミティブについて学びます。</p>
</li>
<li>
<p><a href="custom_types.html">カスタム型</a> - <code>struct</code>と<code>enum</code></p>
</li>
<li>
<p><a href="variable_bindings.html">変数束縛</a> - 可変束縛、スコープ、シャドーイング。</p>
</li>
<li>
<p><a href="types.html">型</a> - 型の変更と宣言について学びます。</p>
</li>
<li>
<p><a href="conversion.html">変換</a></p>
</li>
<li>
<p><a href="expression.html">式</a></p>
</li>
<li>
<p><a href="flow_control.html">制御フロー</a> - <code>if</code>/<code>else</code>、<code>for</code>など。</p>
</li>
<li>
<p><a href="fn.html">関数</a> - メソッド、クロージャ、高階関数などについて学びます。</p>
</li>
<li>
<p><a href="mod.html">モジュール</a> - モジュールでコードを整理する。</p>
</li>
<li>
<p><a href="crates.html">クレート</a> - クレートはRustの編集ユニットです。ライブラリの作り方を学びます。</p>
</li>
<li>
<p><a href="cargo.html">Cargo</a> - Rustの標準パッケージマネージャの基本的な機能について学びます。</p>
</li>
<li>
<p><a href="attribute.html">属性</a> - 属性とは、モジュールやクレート、その要素などに対して適用されるメタデータのことです。</p>
</li>
<li>
<p><a href="generics.html">ジェネリック</a> - 複数の型の引数に対して実行できる関数やデータ型について学びます.</p>
</li>
<li>
<p><a href="scope.html">スコープのルール</a> - スコープは所有権、借用、ライフタイムに関して重要な役割を担います。</p>
</li>
<li>
<p><a href="trait.html">トレイト</a> - トレイとは未知の型<code>Self</code>に対して実装されたメソッドの集合です。</p>
</li>
<li>
<p><a href="macros.html">マクロ</a></p>
</li>
<li>
<p><a href="error.html">エラー処理</a> - Rustで失敗を処理する方法について学びます。</p>
</li>
<li>
<p><a href="std.html">Stdライブラリの型</a> - <code>std</code>ライブラリで提供されるいくつかのカスタム型について学びます。</p>
</li>
<li>
<p><a href="std_misc.html">その他のStd</a> - ファイル処理、スレッドなどのその他のカスタム型。</p>
</li>
<li>
<p><a href="testing.html">テスト</a> - Rustにおけるすべての種類のテスト。</p>
</li>
<li>
<p><a href="unsafe.html">安全でない操作</a></p>
</li>
<li>
<p><a href="compatibility.html">互換性</a></p>
</li>
<li>
<p><a href="meta.html">メタデータ</a> - ドキュメント、ベンチマーク。</p>
</li>
</ul>
<h1><a class="header" href="#hello-world" id="hello-world">Hello World</a></h1>
<p>こちらが伝統的な「Hello World」プログラムのソースコードです。</p>
<pre><pre class="playpen"><code class="language-rust editable">// これはコメントで、コンパイラに無視されます。
// ここにある&quot;Run&quot;ボタンをクリックするとコードをテストできます -&gt;
// キーボードを使いたければ、&quot;Ctrl + Enter&quot;ショートカットを使うことができます

// このコードは編集できます。自由にハックしてください!
// &quot;Reset&quot;ボタンをクリックするといつでも元のコードに戻すことができます -&gt;

// これがmain関数です
fn main() {
    // ここにある式はバイナリが呼び出されたときに実行されます。

    // テキストをコンソールに出力します
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p><code>println!</code>はテキストをコンソールに出力する<a href="macros.html"><em>マクロ</em></a>です。</p>
<p>Rustのコンパイラ<code>rustc</code>を使うことでバイナリを生成できます。</p>
<pre><code class="language-bash">$ rustc hello.rs
</code></pre>
<p><code>rustc</code>は<code>hello</code>実行可能バイナリを出力します。</p>
<pre><code class="language-bash">$ ./hello
Hello World!
</code></pre>
<h3><a class="header" href="#演習" id="演習">演習</a></h3>
<p>'Run'で出力を確認してください. 次に, このように出力する
、2つ目の<code>println!</code>マクロを使った行を追加してください。</p>
<pre><code class="language-text">Hello World!
I'm a Rustacean!
</code></pre>
<h1><a class="header" href="#コメント" id="コメント">コメント</a></h1>
<p>どんなプログラムもコメントを必要とします。Rustはいくつかの形
をサポートしています。</p>
<ul>
<li>コンパイラに無視される<em>普通のコメント</em>
<ul>
<li><code>// 行の終わりまで続く行コメント。</code></li>
<li><code>/* コメントを終了するデリミタまで続くブロックコメント */</code></li>
</ul>
</li>
<li>HTMLライブラリに解析される<em>Docコメント</em>
<a href="hello/../meta/doc.html">ドキュメント</a>:
<ul>
<li><code>/// 下の要素のライブラリドキュメントを生成する。</code></li>
<li><code>//! //!で囲った要素のライブラリドキュメントを生成する。</code></li>
</ul>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // これは行コメントの例です。
    // 行頭に2つのスラッシュがあります。
    // この中のものはすべてコンパイラに読まれません。

    // println!(&quot;Hello, world!&quot;);

    // これを実行してみてください。わかりましたか? 次に2つのスラッシュを消して、もう1度実行してください。

    /* 
     * これはもう1つのタイプのコメント、ブロックコメントです。通常、
     * 行コメントが推奨されます。しかし、ブロックコメントはある部分のコードを
     * 無効化するのに有用です。/* ブロックコメントは /* ネストできます。 */ */
     * なので少しのキーストロークで main()関数をすべてコメントアウトできます。
     * /*/*/* 試してみてください! */*/*/
     */

    /*
    注意: 前の行の`*`は完全にスタイルのためのものです。本当は
    必要ありません。
    */

    // ブロックコメントで、行コメントよりも簡単に式を
    // 操ることができます。 コメントデリミタを削除して
    // 結果を変えてみてください。
    let x = 5 + /* 90 + */ 5;
    println!(&quot;Is `x` 10 or 100? x = {}&quot;, x);
}

</code></pre></pre>
<h3><a class="header" href="#こちらも参照" id="こちらも参照">こちらも参照:</a></h3>
<ul>
<li><a href="hello/../meta/doc.html">ライブラリドキュメント</a></li>
</ul>
<h1><a class="header" href="#フォーマットしてプリント" id="フォーマットしてプリント">フォーマットしてプリント</a></h1>
<p>プリントは<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>で定義されているいくつかの<a href="hello/../macros.html"><code>マクロ</code></a>によって
制御されています。そのいくつかを紹介します。</p>
<ul>
<li><code>format!</code>: フォーマットされたテキストを<a href="hello/../std/str.html"><code>String</code></a>に書き込む。</li>
<li><code>print!</code>: <code>format!</code>と同様だが、コンソール(io::stdout)に書き込む。</li>
<li><code>println!</code>: <code>print!</code>と同様だが、改行が追加される。</li>
<li><code>eprint!</code>: <code>format!</code>と同様だが、標準エラー出力(io::stderr)に書き込む。</li>
<li><code>eprintln!</code>: <code>eprint!</code>と同様だが、改行が追加される。</li>
</ul>
<p>すべてのものは、同じやり方で解析し、 コンパイル時に正しくフォーマットできるか
チェックします。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // 一般的に、`{}`が自動的に引数に変換されます。
    // 自動的に文字列に変換します。
    println!(&quot;{} days&quot;, 31); // {}日

    // 示唆しなければ、31はi32になります。示唆を加えることで、31の型を
    // 変えられます。例えば31i64はi64として解釈されます。

    // 引数の位置を使って、埋め込まれる場所を指定することができます。
    println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;Alice&quot;, &quot;Bob&quot;); // {0}、こちらが{1}です。{1}、こちらが{0}です。

    // 名前を付けても良いです。
    println!(&quot;{subject} {verb} {object}&quot;, // 素早い茶色の狐はのろまな犬を飛び越える
             object=&quot;the lazy dog&quot;,
             subject=&quot;the quick brown fox&quot;,
             verb=&quot;jumps over&quot;);

    // `:`の後にフォーマット型を指定すると特殊なフォーマットができます。
    println!(&quot;{} of {:b} people know binary, the other half doesn't&quot;, 1, 2); // {:b}(2つ目)人に{}(1つ目)人はバイナリを知っていますが、残りの半分は知りません。

    // 幅を指定して右寄せにできます。 この例は
    // &quot;     1&quot;. 5 white spaces and a &quot;1&quot;と出力します。
    println!(&quot;{number:&gt;width$}&quot;, number=1, width=6);

    // 余分なゼロで数字を埋めることができます。この例は&quot;000001&quot;と出力します。
    println!(&quot;{number:&gt;0width$}&quot;, number=1, width=6);

    // Rustは指定された数の引数が使われているかもチェック
    // します。
    println!(&quot;My name is {0}, {1} {0}&quot;, &quot;Bond&quot;); // 私の名前は{0}、{1} {0}です。
    // FIXME ^ 足りない引数、&quot;James&quot;を追加してください。

    // `i32`を含む`Structure`という構造体を作ります。
    #[allow(dead_code)]
    struct Structure(i32);

    // しかし、この構造体のようなカスタム型はもう少し複雑です。
    // これは動作しません。
    println!(&quot;This struct `{}` won't print...&quot;, Structure(3)); // この構造体`{}`は出力できません...
    // FIXME ^ この行をコメントアウトしてください。
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>はテキストを出力するための多くの<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits"><code>トレイト</code></a>を持って
います。2つの重要なものを挙げます。</p>
<ul>
<li><code>fmt::Debug</code>: <code>{:?}</code>マーカーを使います。デバッグ用にテキストをフォーマットします。</li>
<li><code>fmt::Display</code>: <code>{}</code>マーカーを使います。もっと美しく、ユーザーフレンドリーに
表示します。</li>
</ul>
<p>この例で使われている型は、標準ライブラリに含まれているため、ここでは<code>fmt::Display</code>
を使用しています。カスタム型を扱う場合はもう少し複雑です。</p>
<p><code>fmt::Display</code>トレイトを実装すると、自動的に<a href="hello/../std/str.html"><code>String</code></a>に<a href="hello/../conversion/string.html">変換</a>する
<a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>トレイトが実装されます。</p>
<h3><a class="header" href="#演習-1" id="演習-1">演習</a></h3>
<ul>
<li>上のコードの、2つの箇所を変更して(FIXMEを見てください)エラーなく実行できる
ようにしてください。</li>
<li>表示される小数の桁数を調整し、<code>Pi is roughly 3.142</code>(Piは大体3.142です)
と出力される<code>println!</code>マクロを追加してください。ただし、円周率の値は
<code>let pi = 3.141592</code>を使ってください。(ヒント: 小数の桁数を調整して出力
する方法について、<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>ドキュメントをチェックしてみてください。)</li>
</ul>
<h3><a class="header" href="#こちらも参照-1" id="こちらも参照-1">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a></li>
<li><a href="hello/../macros.html"><code>macros</code></a></li>
<li><a href="hello/../custom_types/structs.html"><code>structs</code></a></li>
<li><a href="https://doc.rust-lang.org/std/fmt/#formatting-traits"><code>traits</code></a></li>
</ul>
<h1><a class="header" href="#デバッグ" id="デバッグ">デバッグ</a></h1>
<p><code>std::fmt</code>のフォーマット用の<code>トレイト</code>を使用したい型は、すべてプリント可能
なように実装されている必要があります。<code>std</code>ライブラリにあるような型にしか
実装は提供されていません。他は手動で実装<em>しなければいけません</em>。</p>
<p><code>fmt::Debug</code>という<code>トレイト</code>でこれを簡略化できます。<em>すべての</em>型は
<code>fmt::Debug</code>の実装を<code>継承</code>(自動で作成)できるからです。ただし、
<code>fmt::Display</code>の場合は手動で実装しなければいけません。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// この構造体は`fmt::Display`でも
// `fmt::Debug`でもプリントできません。
struct UnPrintable(i32);

// `derive`属性は、自動的にこの`struct`を`fmt::Debug`で
// プリントできるように実装を作成します。
#[derive(Debug)]
struct DebugPrintable(i32);
<span class="boring">}
</span></code></pre></pre>
<p>すべての<code>std</code>ライブラリの型も自動的に<code>{:?}</code>でプリントできます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// `fmt::Debug`の実装を`Structure`に継承する. `Structure`
// は一つの`i32`をメンバに持っています。
#[derive(Debug)]
struct Structure(i32);

// `Structure`を中に持つ構造体`Deep`を作る。 これもプリント可能
// にする。
#[derive(Debug)]
struct Deep(Structure);

fn main() {
    // `{:?}`は`{}`と似たようなものです。
    println!(&quot;{:?} months in a year.&quot;, 12);
    println!(&quot;{1:?} {0:?} is the {actor:?} name.&quot;,
             &quot;Slater&quot;,
             &quot;Christian&quot;,
             actor=&quot;actor's&quot;);

    // `Structure`はプリントできます!
    println!(&quot;Now {:?} will print!&quot;, Structure(3)); // 今、{:?}がプリントされます。
    
    // `derive`の問題点は、結果の見た目を制御できない点です。
    // 出力を`7`だけにするにはどうすればよいでしょう?
    println!(&quot;Now {:?} will print!&quot;, Deep(Structure(7)));
}
</code></pre></pre>
<p><code>fmt::Debug</code>は確実にプリントを可能にしてくれるのですが、ある意味で美しさを
犠牲にしています。Rustは<code>{:#?}</code>による「美しいプリント」も提供しています。</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8
}

fn main() {
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // 美しいプリント
    println!(&quot;{:#?}&quot;, peter);
}
</code></pre></pre>
<p>出力をコントロールするために手動で<code>fmt::Display</code>を実装することもできます。</p>
<h3><a class="header" href="#こちらも参照-2" id="こちらも参照-2">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/reference/attributes.html">属性</a></li>
<li><a href="hello/print/../../trait/derive.html"><code>derive</code></a></li>
<li><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a></li>
<li><a href="hello/print/../../custom_types/structs.html"><code>structs</code></a></li>
</ul>
<h1><a class="header" href="#ディスプレイ" id="ディスプレイ">ディスプレイ</a></h1>
<p><code>fmt::Debug</code>はコンパクトでもきれいでもありません。なので、たいていの場合は
出力をカスタマイズするのが好ましいでしょう。これは<code>{}</code>プリントマーカーを使う
<a href="https://doc.rust-lang.org/std/fmt/"><code>fmt::Display</code></a>を手動で実装することで可能です。次のように実装できます。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// (`use`で) `fmt`モジュールをインポートすることで利用可能にします。
use std::fmt;

// を`fmt::Display`実装する構造体を定義します。これは`i32`を含む
// `Structure`というタプル構造体です。
struct Structure(i32);

// `{}`マーカーを使用するには、その型のための`fmt::Display`トレイトが手動で
// 実装されている必要があります。
impl fmt::Display for Structure {
    // このトレイとは`fmt`が想定通りのものであることを要求します。
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 必ず最初の要素が出力されるようにします。
        // `f`ストリームはオペレーションが成功したがどうかを表す`fmt::Result`
        // を返します。`write!`は`println!`にとても良く似た構文を持っていることに
        // 注目してください。
        write!(f, &quot;{}&quot;, self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>fmt::Display</code>は<code>fmt::Debug</code>よりも簡潔に見えますが、<code>std</code>ライブラリでは
問題が生じます。曖昧な型ではどのように表示すればよいでしょうか?
例えば、<code>std</code> ライブラリがすべての<code>Vec&lt;T&gt;</code>に対して同じスタイルを提供する
とすれば、どのスタイルにすれば良いでしょう? 以下のどちらを選べばよいでしょうか?</p>
<ul>
<li><code>Vec&lt;path&gt;</code>: <code>/:/etc:/home/username:/bin</code> (<code>:</code>で分割)</li>
<li><code>Vec&lt;number&gt;</code>: <code>1,2,3</code> (<code>,</code>で分割)</li>
</ul>
<p>どちらも正解ではありません。あらゆる方に対して理想的なスタイルは存在しませんし、
<code>std</code>ライブラリがそれを提供しているわけではありません。<code>fmt::Display</code>は<code>Vec&lt;T&gt;</code>
などのジェネリックなコンテナには定義していません。このような場合は<code>fmt::Debug</code>
<code>fmt::Debug</code>を使用するべきです。</p>
<p>ジェネリックで<em>ない</em>ような<em>コンテナ</em>型ではこのような問題は生じませんので、
<code>fmt::Display</code>を実装できます。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt; // `fmt`をインポート

// 構造体は2つの値を持っています。出力を`Display`と比較するために
// `Debug`をderiveしています。
#[derive(Debug)]
struct MinMax(i64, i64);

// `Display`を`MinMax`に実装する。
impl fmt::Display for MinMax {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // `self.数字`でそれぞれの位置のデータを参照できます。
        write!(f, &quot;({}, {})&quot;, self.0, self.1)
    }
}

// 比較のため、フィールド上の点に名前をつける構造体を定義しましょう。
#[derive(Debug)]
struct Point2D {
    x: f64,
    y: f64,
}

// `Display`を`Point2D`にも実装しましょう
impl fmt::Display for Point2D {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // `x`と`y`のみが明示的になるようにカスタマイズ。
        write!(f, &quot;x: {}, y: {}&quot;, self.x, self.y)
    }
}

fn main() {
    let minmax = MinMax(0, 14);

    println!(&quot;Compare structures:&quot;);
    println!(&quot;Display: {}&quot;, minmax);
    println!(&quot;Debug: {:?}&quot;, minmax);

    let big_range =   MinMax(-300, 300);
    let small_range = MinMax(-3, 3);

    println!(&quot;The big range is {big} and the small is {small}&quot;,
             small = small_range,
             big = big_range);

    let point = Point2D { x: 3.3, y: 7.2 };

    println!(&quot;Compare points:&quot;);
    println!(&quot;Display: {}&quot;, point);
    println!(&quot;Debug: {:?}&quot;, point);

    // `Debug`と`Display`は実装されていますが、`{:b}`は、`fmt::Binary`
    // が実装されていないと使えないので、この例はエラーになります。
    // println!(&quot;What does Point2D look like in binary: {:b}?&quot;, point);
}
</code></pre></pre>
<p><code>fmt::Display</code>は実装されていますが、<code>fmt::Binary</code> されていないので、
使うことができません。<code>std::fmt</code>は多くのこのような<a href="hello/print/../../trait.html"><code>トレイト</code></a>があり、
それぞれに独自の実装が必要です。詳細は<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>を参照してください。</p>
<h3><a class="header" href="#演習-2" id="演習-2">演習</a></h3>
<p>上の例の出力を確認して、<code>Point2D</code>構造体を参考にして、例として複素数構造体を定義
しましょう. うまくいけば、次のように出力されます。</p>
<pre><code class="language-txt">Display: 3.3 + 7.2i
Debug: Complex { real: 3.3, imag: 7.2 }
</code></pre>
<h3><a class="header" href="#こちらも参照-3" id="こちらも参照-3">こちらも参照:</a></h3>
<ul>
<li><a href="hello/print/../../trait/derive.html"><code>derive</code></a></li>
<li><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a></li>
<li><a href="hello/print/../../macros.html">マクロ</a></li>
<li><a href="hello/print/../../custom_types/structs.html"><code>structs</code></a></li>
<li><a href="hello/print/../../trait.html"><code>traits</code></a></li>
<li><a href="hello/print/../../mod/use.html">use</a></li>
</ul>
<h1><a class="header" href="#テストケース-リスト" id="テストケース-リスト">テストケース: リスト</a></h1>
<p>要素が順番に処理されていくような構造体に対して<code>fmt::Display</code>を実装するのは
トリッキーです。なぜなら、それぞれの<code>write!</code>が<code>fmt::Result</code>を返すからです。
適切に処理するには<em>すべての</em>Resultに対して処理を行わなければいけません。
Rust はこのような目的のために<code>?</code>演算子を用意しています。</p>
<p>次のように<code>?</code>を<code>write!</code>に対して使えます。</p>
<pre><code class="language-rust ignore">// `write!`を実行し、エラーが出た場合はerrorを返し、
// そうでなければ処理を続行する。
write!(f, &quot;{}&quot;, value)?;
</code></pre>
<p>もう1つ、同じように動く<code>try!</code>マクロを使うこともできます。
これは少し冗長であり、もはや推奨されていませんが、古い
Rustのコードを読むときは。このように<code>try!</code>を使っています。</p>
<pre><code class="language-rust ignore">try!(write!(f, &quot;{}&quot;, value));
</code></pre>
<p><code>?</code>を使うことができれば、<code>fmt::Display</code>を<code>Vec</code>に実装する
のはより簡単です。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt; // `fmt`モジュールをインポートする。

// `vec`を含む構造体`List`を実装する。
struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // タプルインデックスで要素を展開し、
        // `vec`という参照を作る。
        let vec = &amp;self.0;

        write!(f, &quot;[&quot;)?;

        // `v`で`vec`を反復し、enumerateで
        // `count`にカウントを取得する。
        for (count, v) in vec.iter().enumerate() {
            // 最初の要素以外、全ての要素の前にコンマをつける。
            // ?演算子かtry!を使って、エラーのときにそれを返す。
            if count != 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}&quot;, v)?;
        }

        // 開いた括弧を閉じ、fmt::Resultを返す。
        write!(f, &quot;]&quot;)
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<h3><a class="header" href="#演習-3" id="演習-3">演習</a></h3>
<p>ベクタのインデックスも表示するようにプログラムを変更しましょう。
新しい出力は以下のようになるはずです。</p>
<pre><code class="language-rust ignore">[0: 1, 1: 2, 2: 3]
</code></pre>
<h3><a class="header" href="#こちらも参照-4" id="こちらも参照-4">こちらも参照:</a></h3>
<ul>
<li><a href="hello/print/print_display/../../../flow_control/for.html"><code>for</code></a></li>
<li><a href="hello/print/print_display/../../../scope/borrow/ref.html"><code>ref</code></a></li>
<li><a href="hello/print/print_display/../../../std/result.html"><code>Result</code></a></li>
<li><a href="hello/print/print_display/../../../custom_types/structs.html"><code>struct</code></a></li>
<li><a href="hello/print/print_display/../../../std/result/question_mark.html"><code>?</code></a></li>
<li><a href="hello/print/print_display/../../../std/vec.html"><code>vec!</code></a></li>
</ul>
<h1><a class="header" href="#フォーマット" id="フォーマット">フォーマット</a></h1>
<p>文字列がどのようにフォーマットされるかは<em>フォーマット文字列</em>によって決まります。</p>
<ul>
<li><code>format!(&quot;{}&quot;, foo)</code> -&gt; <code>&quot;3735928559&quot;</code></li>
<li><code>format!(&quot;0x{:X}&quot;, foo)</code> -&gt;
<a href="https://en.wikipedia.org/wiki/Deadbeef#Magic_debug_values"><code>&quot;0xDEADBEEF&quot;</code></a></li>
<li><code>format!(&quot;0o{:o}&quot;, foo)</code> -&gt; <code>&quot;0o33653337357&quot;</code></li>
</ul>
<p>同じ変数(<code>foo</code>)が<code>X</code>、<code>o</code>、<em>指定なし</em>のような様々な引数タイプ
によってフォーマットされます。</p>
<p>これらのフォーマットはそれぞれの引数タイプに応じたトレイトによって定義されています。
最も一般的なトレイとは<code>Display</code>で、これは引数タイプが未指定(例えば<code>{}</code>)のときに
呼び出されます。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::{self, Formatter, Display};

struct City {
    name: &amp;'static str,
    // 緯度
    lat: f32,
    // 経度
    lon: f32,
}

impl Display for City {
    // `f`はバッファで、ここにフォーマットした結果を書き込む必要があります。
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        let lat_c = if self.lat &gt;= 0.0 { 'N' } else { 'S' };
        let lon_c = if self.lon &gt;= 0.0 { 'E' } else { 'W' };

        // `write!`は`format!`のようなものですが、これはフォーマットされた文字列を
        // 第1引数に指定されたバッファに書き込みます。
        write!(f, &quot;{}: {:.3}°{} {:.3}°{}&quot;,
               self.name, self.lat.abs(), lat_c, self.lon.abs(), lon_c)
    }
}

#[derive(Debug)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

fn main() {
    for city in [
        City { name: &quot;Dublin&quot;, lat: 53.347778, lon: -6.259722 },
        City { name: &quot;Oslo&quot;, lat: 59.95, lon: 10.75 },
        City { name: &quot;Vancouver&quot;, lat: 49.25, lon: -123.1 },
    ].iter() {
        println!(&quot;{}&quot;, *city);
    }
    for color in [
        Color { red: 128, green: 255, blue: 90 },
        Color { red: 0, green: 3, blue: 254 },
        Color { red: 0, green: 0, blue: 0 },
    ].iter() {
        // fmt::Displayに実装を追加したら、そちらを使うように変更
        // してください。
        println!(&quot;{:?}&quot;, *color);
    }
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">フォーマット用のトレイト一覧</a>とその引数タイプ<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>
をドキュメントで確認できます。</p>
<h3><a class="header" href="#演習-4" id="演習-4">演習</a></h3>
<p>次のように出力する、上の<code>Color</code>構造体のための<code>fmt::Display</code>トレイトの実装を
してください。</p>
<pre><code class="language-text">RGB (128, 255, 90) 0x80FF5A
RGB (0, 3, 254) 0x0003FE
RGB (0, 0, 0) 0x000000
</code></pre>
<p>詰まったら次の2つがヒントになるかもしれません。</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/fmt/#named-parameters">それぞれの色を2回以上出力する必要があるかもしれません</a>,</li>
<li><code>:02</code>で<a href="https://doc.rust-lang.org/std/fmt/#width">2桁ゼロ埋め</a> できます。</li>
</ul>
<h3><a class="header" href="#こちらも参照-5" id="こちらも参照-5">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a></li>
</ul>
<h1><a class="header" href="#プリミティブ" id="プリミティブ">プリミティブ</a></h1>
<p>Rustは、様々な<code>プリミティブ</code>を提供しています。以下がその例です。</p>
<h3><a class="header" href="#スカラー型" id="スカラー型">スカラー型</a></h3>
<ul>
<li>符号付き整数: <code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>、そして<code>isize</code> (ポインタサイズ)</li>
<li>符号なし整数: <code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code>、そして<code>usize</code> (ポインタサイズ)</li>
<li>浮動小数点: <code>f32</code>, <code>f64</code></li>
<li><code>char</code> Unicodeのスカラー値。例えば<code>'a'</code>、<code>'α'</code>、そして<code>'∞'</code> (それぞれ4バイト)</li>
<li><code>bool</code> <code>true</code>または<code>false</code></li>
<li>ユニット型。唯一の値が空タプル<code>()</code>。</li>
</ul>
<p>ユニット型はタプルですが、複数の値を含むことができないため、
複合型ではありません。</p>
<h3><a class="header" href="#複合型" id="複合型">複合型</a></h3>
<ul>
<li><code>[1, 2, 3]</code>のような配列</li>
<li><code>(1, true)</code>のようなタプル</li>
</ul>
<p>変数は常に<em>型指定</em>可能です。数値型は更に<em>サフィックス</em>の指定が可能で、
指定しない場合はデフォルトになります。整数値のデフォルトは<code>i32</code>で、
浮動小数点数は<code>f64</code>です。Rustはさらに文脈から型推論ができることに注意
してください。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // 変数には型の注釈が付けられます。
    let logical: bool = true;

    let a_float: f64 = 1.0;  // ふつうの注釈
    let an_integer   = 5i32; // サフィックスで注釈

    // デフォルトを選択することもできます。
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`
    
    //  文脈から型推論する
    let mut inferred_type = 12; // 他の行からi64であると推論する。
    inferred_type = 4294967296i64;
    
    // 可変な変数は変更できます。
    let mut mutable = 12; // 可変な`i32`
    mutable = 21;
    
    // エラーします! 変数の型は変更できません。
    mutable = true;
    
    // 変数はシャドーイングで上書きできます。
    let mutable = true;
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-6" id="こちらも参照-6">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/"><code>std</code>ライブラリ</a></li>
<li><a href="variable_bindings/mut.html"><code>mut</code></a></li>
<li><a href="types/inference.html">推論</a></li>
<li><a href="variable_bindings/scope.html">シャドーイング</a></li>
</ul>
<h1><a class="header" href="#リテラルと演算子" id="リテラルと演算子">リテラルと演算子</a></h1>
<p>整数の<code>1</code>、浮動小数点数の<code>1.2</code>、文字の<code>'a'</code>、文字列の<code>&quot;abc&quot;</code>、真偽値の<code>true</code>、
そしてユニット型の<code>()</code>などは、リテラルで表すことができます。</p>
<p>整数は<code>0x</code>、<code>0o</code>、<code>0b</code>などのプレフィックスをつけることで、
16進数、8進数、2進数でも表すことができます。</p>
<p>また、可読性のため、数値にアンダースコアを挟むことができます。 例えば
<code>1_000</code>は<code>1000</code>と同じで、<code>0.000_001</code>は<code>0.000001</code>と同じです。</p>
<p>コンパイラにリテラルの型を教えてあげなければいけません. 現在は、
<code>u32</code>サフィックスでリテラル32ビット符号なし整数になり、<code>i32</code>サフィックス
で32ビット符号付き整数になります。</p>
<p>Rustで使える<a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">演算子や、その優先順位</a>は、<a href="https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages">Cのような言語</a>
と似ています。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // 整数の足し算
    println!(&quot;1 + 2 = {}&quot;, 1u32 + 2);

    // 整数の引き算
    println!(&quot;1 - 2 = {}&quot;, 1i32 - 2);
    // TODO ^ `1i32`を`1u32`に変えてみて、型の重要さを実感してみてください。

    // 真偽値の短絡評価
    println!(&quot;true AND false is {}&quot;, true &amp;&amp; false);
    println!(&quot;true OR false is {}&quot;, true || false);
    println!(&quot;NOT true is {}&quot;, !true); // 真でないものは{}

    // ビット演算
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);

    // アンダースコアを使って可読性を上げましょう!
    println!(&quot;One million is written as {}&quot;, 1_000_000u32); // 100万は{}と書きます
}
</code></pre></pre>
<h1><a class="header" href="#タプル" id="タプル">タプル</a></h1>
<p>タプルは異なる型の値の集合です。タプルは<code>()</code>を使って表し、タプル自身の型は
<code>T1</code>、<code>T2</code>をメンバーの型だとして<code>(T1, T2, ...)</code>のように表します。タプルに
大きさの制限がないので、関数で複数の値を返すのにタプルが使われています。</p>
<pre><pre class="playpen"><code class="language-rust editable">// タプルは、関数の引数や、返り値としても使えます。
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {
    // `let` can be used to bind the members of a tuple to variables
    let (integer, boolean) = pair;

    (boolean, integer)
}

// これは演習のための構造体です。
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // 複数の異なる型の値を束ねたタプル
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // タプルのインデックスを利用して、値を取り出すことができます。
    println!(&quot;long tuple first value: {}&quot;, long_tuple.0);
    println!(&quot;long tuple second value: {}&quot;, long_tuple.1);

    // タプルはタプルのメンバーになれます。
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // タプルは出力できます。
    println!(&quot;tuple of tuples: {:?}&quot;, tuple_of_tuples);
    
    // ただし、長いタプルは出力できません。
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);
    // TODO ^ コンパイルエラーを確認するために上の2行をアンコメントしてください。

    let pair = (1, true);
    println!(&quot;pair is {:?}&quot;, pair);

    println!(&quot;the reversed pair is {:?}&quot;, reverse(pair));

    // 一つしか要素がないタプルは、リテラルを括弧で囲ったものと
    // 区別するため、コンマが必要です。
    println!(&quot;one element tuple: {:?}&quot;, (5u32,)); // 要素1つのタプル: {:?}
    println!(&quot;just an integer: {:?}&quot;, (5u32)); // ただの整数: {:?}

    //タプルを分解してそれぞれを別の変数に束縛する。
    let tuple = (1, &quot;hello&quot;, 4.5, true);

    let (a, b, c, d) = tuple;
    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!(&quot;{:?}&quot;, matrix);

}
</code></pre></pre>
<h3><a class="header" href="#演習-5" id="演習-5">演習</a></h3>
<ol>
<li>
<p><em>復習</em>: <code>fmt::Display</code>トレイトを上の例のMatrix構造体に実装し、
デバッグフォーマット<code>{:?}</code>をディスプレイフォーマット<code>{}</code>に変えたときに
以下のように表示されるようにしてください。</p>
<pre><code class="language-text">( 1.1 1.2 )
( 2.1 2.2 )
</code></pre>
<p><a href="primitives/../hello/print/print_display.html">ディスプレイ</a>の例に戻る必要があるかもしれません。</p>
</li>
<li>
<p><code>reverse</code>関数をテンプレートとして、下のように、引数として
Matrixを受け取り、2つの要素を交換したMatrixを返す関数<code>transpose</code>を追加
してください。</p>
<pre><code class="language-rust ignore">println!(&quot;Matrix:\n{}&quot;, matrix);
println!(&quot;Transpose:\n{}&quot;, transpose(matrix));
</code></pre>
<p>出力結果:</p>
<pre><code class="language-text">Matrix:
( 1.1 1.2 )
( 2.1 2.2 )
Transpose:
( 1.1 2.1 )
( 1.2 2.2 )
</code></pre>
</li>
</ol>
<h1><a class="header" href="#配列とスライス" id="配列とスライス">配列とスライス</a></h1>
<p>配列は、メモリ上に連続して保存される、同じ型<code>T</code>の値の集合です。配列は角括弧<code>[]</code>
で作ることができます。また、長さはコンパイル時にわかっていなければならず、
<code>[T; size]</code>で型の定義ができます。</p>
<p>Slicesは配列と似ていますが、コンパイル時に長さが決まっていなくても良いです。
その代わり、データへのポインタと、スライスの長さという2つのデータを格納しなければ
なりません。1つのデータのサイズはアーキテクチャ依存(例えばx86-64なら64ビット)で、
<code>usize</code>と同じ大きさです。
スライスは配列の一部分の借用として使うことができ、<code>&amp;[T]</code>という型指定子が使えます。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">use std::mem;

// この関数はスライスを借用します。
fn analyze_slice(slice: &amp;[i32]) {
    println!(&quot;first element of the slice: {}&quot;, slice[0]);
    println!(&quot;the slice has {} elements&quot;, slice.len());
}

fn main() {
    // 固定長配列 (型シグネチャは余計です)
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // すべての要素を同じ値で初期化することができます。
    let ys: [i32; 500] = [0; 500];

    // インデックスは0から始まります。
    println!(&quot;first element of the array: {}&quot;, xs[0]);  // 配列の最初の要素: {}
    println!(&quot;second element of the array: {}&quot;, xs[1]);  // 配列の2つ目の要素: {}

    // `len`は配列の長さを返します。
    println!(&quot;array size: {}&quot;, xs.len());

    // 配列はスタック上に置かれます。
    println!(&quot;array occupies {} bytes&quot;, mem::size_of_val(&amp;xs));  // 配列は{}バイト占有しています。

    // 配列は自動的にスライスとして借用されます。
    println!(&quot;borrow the whole array as a slice&quot;);  // 配列の全体をスライスとして借用する
    analyze_slice(&amp;xs);

    // スライスで配列の部分を指す
    // [スタート..エンド]のようにして指定します。
    // ただし、スタートはスライスの最初の位置のインデックス
    // エンドは1より大きいスライスの最後の位置のインデックスです。
    println!(&quot;borrow a section of the array as a slice&quot;);  // 配列の部分をスライスとして借用する。
    analyze_slice(&amp;ys[1 .. 4]);

    // 範囲外の位置を指定するとコンパイルエラーが起こる。
    println!(&quot;{}&quot;, xs[5]);
}
</code></pre></pre>
<h1><a class="header" href="#カスタム型" id="カスタム型">カスタム型</a></h1>
<p>Rustのカスタムデータ型は主にこの2つのキーワードで作ることができます。</p>
<ul>
<li><code>struct</code>: 構造体を定義する</li>
<li><code>enum</code>: 列挙体を定義する</li>
</ul>
<p>定数は<code>const</code>や<code>static</code>キーワードで作ることができます。</p>
<h1><a class="header" href="#構造体" id="構造体">構造体</a></h1>
<p><code>struct</code>キーワードで作ることができる構造体には3つのタイプがあります。</p>
<ul>
<li>タプル構造体。基本的な名前がついたタプル。</li>
<li>古典的な<a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">Cの構造体</a></li>
<li>ユニット構造体。フィールドを持たず、ジェネリックを扱うときに有用です。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    // 'aでライフタイムを定義しています。
    name: &amp;'a str,
    age: u8,
}

// ユニット構造体
struct Unit;

// タプル構造体
struct Pair(i32, f32);

// 2個のフィールドを持つ構造体
struct Point {
    x: f32,
    y: f32,
}

// 構造体は構造体のフィールドとして再利用できます。
#[allow(dead_code)]
struct Rectangle {
    // 長方形は左上と右下の位置で定義できます。
    // corners are in space.
    top_left: Point,
    bottom_right: Point,
}

fn main() {
    // 構造体を作って簡潔に初期化する。
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // 構造体のデバッグプリント
    println!(&quot;{:?}&quot;, peter);


    // `Point`をインスタンス化する
    let point: Point = Point { x: 10.3, y: 0.4 };

    // Pointのフィールドにアクセスする
    println!(&quot;point coordinates: ({}, {})&quot;, point.x, point.y);

    // アップデート構文で他の構造体のフィールドを再利用して新しい構造体を作る。
    let bottom_right = Point { x: 5.2, ..point };

    // `point`からフィールドを再利用したため、`bottom_right.y`は`point.y`と
    // 同じになります。
    println!(&quot;second point: ({}, {})&quot;, bottom_right.x, bottom_right.y);

    // `let`でpointを分割代入して束縛する
    let Point { x: top_edge, y: left_edge } = point;

    let _rectangle = Rectangle {
        // 構造体のインスタンス化も式です。
        top_left: Point { x: left_edge, y: top_edge },
        bottom_right: bottom_right,
    };

    // ユニット構造体のインスタンス化
    let _unit = Unit;

    // タプル構造体のインスタンス化
    let pair = Pair(1, 0.1);

    // タプル構造体のフィールドにアクセスする
    println!(&quot;pair contains {:?} and {:?}&quot;, pair.0, pair.1);

    // タプル構造体を分割代入
    let Pair(integer, decimal) = pair;

    println!(&quot;pair contains {:?} and {:?}&quot;, integer, decimal);
}
</code></pre></pre>
<h3><a class="header" href="#演習-6" id="演習-6">演習</a></h3>
<ol>
<li>長方形の面積を計算する<code>rect_area</code>関数を追加してください。(ネスト分割代入を試してみてください。)</li>
<li><code>Point</code>と<code>f32</code>を引数にとり、<code>Point</code>を左上の点、<code>f32</code>を一辺の長さとして正方形を作成して<code>Rectangle</code>として返す関数<code>square</code>を追加してください。</li>
</ol>
<h3><a class="header" href="#こちらも参照-7" id="こちらも参照-7">こちらも参照:</a></h3>
<ul>
<li><a href="custom_types/../attribute.html"><code>attributes</code></a></li>
<li><a href="custom_types/../scope/lifetime.html">ライフタイム</a></li>
<li><a href="custom_types/../flow_control/match/destructuring.html">分割代入</a></li>
</ul>
<h1><a class="header" href="#enum" id="enum">Enum</a></h1>
<p><code>enum</code>はいくつかの型から1つ選ぶような型を作るときに使う。<code>構造体</code>の定義を満たすものは
すべて<code>enum</code>内で使える。</p>
<pre><pre class="playpen"><code class="language-rust editable">//  Webのイベントを分類するのに`enum`を使う。名前と型情報を
// 合わせて列挙子を定義することに注意してください。
// `PageLoad != PageUnload`で、`KeyPress(char) != Paste(String)`です。
// それぞれは異なっていて、独立です。
enum WebEvent {
    // `enum`は`unit`や、
    PageLoad,
    PageUnload,
    // タプル構造体や、
    KeyPress(char),
    Paste(String),
    // cライク構造体のようにできます。
    Click { x: i64, y: i64 },
}

// `WebEvent` enumを引数としてとり、何も返さない関数。
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad =&gt; println!(&quot;page loaded&quot;),
        WebEvent::PageUnload =&gt; println!(&quot;page unloaded&quot;),
        // `enum`内の`c`を分割代入する。
        WebEvent::KeyPress(c) =&gt; println!(&quot;pressed '{}'.&quot;, c),
        WebEvent::Paste(s) =&gt; println!(&quot;pasted \&quot;{}\&quot;.&quot;, s),
        // `Click`を`x`と`y`に分割代入する。
        WebEvent::Click { x, y } =&gt; {
            println!(&quot;clicked at x={}, y={}.&quot;, x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()`は文字列のスライスから所有権を持つ`String`を作成します。
    let pasted  = WebEvent::Paste(&quot;my text&quot;.to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}

</code></pre></pre>
<h2><a class="header" href="#型エイリアス" id="型エイリアス">型エイリアス</a></h2>
<p>型エイリアスを使うと、そのエイリアスからenumの列挙子を参照できます。
これはenumの名前が長過ぎたり、汎用的すぎたりして、名前を変えたいときに
使えるかもしれません。</p>
<pre><pre class="playpen"><code class="language-rust editable">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

// 型エイリアスを作る
type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;

fn main() {
    // エイリアスを通してenumを参照できます。
    // 長くも不便でもないです。
    let x = Operations::Add;
}
</code></pre></pre>
<p>これの最も一般的な使い道は、<code>impl</code>ブロック内で<code>Self</code>エイリアスとして使われるときです。</p>
<pre><pre class="playpen"><code class="language-rust editable">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

impl VeryVerboseEnumOfThingsToDoWithNumbers {
    fn run(&amp;self, x: i32, y: i32) -&gt; i32 {
        match self {
            Self::Add =&gt; x + y,
            Self::Subtract =&gt; x - y,
        }
    }
}
</code></pre></pre>
<p>enumと型エイリアスについてもっと知りたければ、この機能がRustの安定版に導入されたときの
<a href="https://github.com/rust-lang/rust/pull/61682/#issuecomment-502472847">安定化レポート</a>を読んでください。</p>
<h3><a class="header" href="#こちらも参照-8" id="こちらも参照-8">こちらも参照:</a></h3>
<ul>
<li><a href="custom_types/../flow_control/match.html"><code>match</code></a></li>
<li><a href="custom_types/../fn.html"><code>fn</code></a></li>
<li><a href="custom_types/../std/str.html"><code>String</code></a></li>
<li><a href="https://rust-lang.github.io/rfcs/2338-type-alias-enum-variants.html">&quot;Type alias enum variants&quot; RFC</a></li>
</ul>
<h1><a class="header" href="#use" id="use">use</a></h1>
<p><code>use</code>宣言を使うと、変数のスコープを絶対名で指定する必要がなくなります。</p>
<pre><pre class="playpen"><code class="language-rust editable">// 使われていないコードの警告をなくす属性
#![allow(dead_code)]

enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}

fn main() {
    // 明示的に名前を指定して`use`して、
    // 絶対名で指定しなくても使用できるようになる。
    use crate::Status::{Poor, Rich};
    // `Work`の中の名前をすべて自動的に`use`する。
    use crate::Work::*;

    // `Status::Poor`と等しい。
    let status = Poor;
    // `Work::Civilian`と等しい。
    let work = Civilian;

    match status {
        // 上で`use`しているので、スコープは不要です。
        Rich =&gt; println!(&quot;The rich have lots of money!&quot;),  // 富豪はたくさんの金を持っています!
        Poor =&gt; println!(&quot;The poor have no money...&quot;),  // 貧民は金を持っていません...
    }

    match work {
        // これも同じです。
        Civilian =&gt; println!(&quot;Civilians work!&quot;),  // 民間人は働きます!
        Soldier  =&gt; println!(&quot;Soldiers fight!&quot;),  // 兵士は戦います!
    }
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-9" id="こちらも参照-9">こちらも参照:</a></h3>
<ul>
<li><a href="custom_types/enum/../../flow_control/match.html"><code>match</code></a></li>
<li><a href="custom_types/enum/../../mod/use.html"><code>use</code></a> </li>
</ul>
<h1><a class="header" href="#cライクなenum" id="cライクなenum">CライクなEnum</a></h1>
<p><code>enum</code>はCライクにも使えます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// 使用されていないコードの警告をなくす属性
#![allow(dead_code)]

// 値を明示しない場合、0から順に入る。
enum Number {
    Zero,
    One,
    Two,
}

// 明確な指定をするenum
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enums`は整数にキャストできる。
    println!(&quot;zero is {}&quot;, Number::Zero as i32);
    println!(&quot;one is {}&quot;, Number::One as i32);

    println!(&quot;roses are #{:06x}&quot;, Color::Red as i32);  // バラは#{:06x}
    println!(&quot;violets are #{:06x}&quot;, Color::Blue as i32);  // スミレは#{:06x}
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-10" id="こちらも参照-10">こちらも参照:</a></h3>
<ul>
<li><a href="custom_types/enum/../../types/cast.html">キャスト</a></li>
</ul>
<h1><a class="header" href="#テストケース-連結リスト" id="テストケース-連結リスト">テストケース: 連結リスト</a></h1>
<p><code>enums</code>は連結リストを作るのに適当です。</p>
<pre><pre class="playpen"><code class="language-rust editable">use crate::List::*;

enum List {
    // Cons: 要素と次のノードを指すポインタからなるタプル構造体
    Cons(u32, Box&lt;List&gt;),
    // Nil: 連結リストの終わりを指すノード
    Nil,
}

// enumに関連付けられた関数
impl List {
    // 空のリストを作る。
    fn new() -&gt; List {
        // `Nil`は`List`型を持つ
        Nil
    }

    // リストを受け取り、前に要素を追加したものを返す。
    fn prepend(self, elem: u32) -&gt; List {
        // `Cons`も`List`型を持つ。
        Cons(elem, Box::new(self))
    }

    // Listの長さを返す
    fn len(&amp;self) -&gt; u32 {
        // このメソッドの振る舞いは`self`の列挙子によって変化するため、
        // matchを使う必要があります。
        // `self`の型は`&amp;List`なので、`*self`の型は`List`になる。match
        // するときは参照`&amp;T`より実体`T`を使う方が好ましい。
        match *self {
            // `self`は借用なので、tailの所有権は取れない。
            // 代わりにtailの参照を取る。
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // 空リストの長さは0
            Nil =&gt; 0
        }
    }

    // Listを(ヒープ上の)文字列として返す。
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!`は`print!`に似ているが、コンソールに出力せず、
                // ヒープ上の文字列を返す。
                format!(&quot;{}, {}&quot;, head, tail.stringify())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // 空リストを作る
    let mut list = List::new();

    // 要素をいくつか追加する
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // 最終的なリストの状態を見る
    println!(&quot;linked list has length: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-11" id="こちらも参照-11">こちらも参照:</a></h3>
<ul>
<li><a href="custom_types/enum/../../std/box.html"><code>Box</code></a></li>
<li><a href="custom_types/enum/../../fn/methods.html">メソッド</a></li>
</ul>
<h1><a class="header" href="#定数" id="定数">定数</a></h1>
<p>Rustには2つの異なるタイプの定数があり、グローバルスコープを含むすべての場所で
宣言できます。どちらも明示的な型注釈が必要です。</p>
<ul>
<li><code>const</code>: 変更できない値(普通はこっち)。</li>
<li><code>static</code>: <code>mut</code>にすることができる<a href="custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code></a>ライフタイムを持つ変数。
'staticライフタイムであることは推論されるので、明示的に指定しなくても良い。
可変なstatic変数にアクセス、変更することは<a href="custom_types/../unsafe.html"><code>unsafe</code></a>です。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// グローバル変数はあらゆるスコープの外で定義します。
static LANGUAGE: &amp;str = &quot;Rust&quot;;
const THRESHOLD: i32 = 10;  // THRESHOLD: しきい値

fn is_big(n: i32) -&gt; bool {
    // 関数内から定数を参照
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // main関数で定数にアクセス
    println!(&quot;This is {}&quot;, LANGUAGE);
    println!(&quot;The threshold is {}&quot;, THRESHOLD);
    println!(&quot;{} is {}&quot;, n, if is_big(n) { &quot;big&quot; } else { &quot;small&quot; });

    // エラー: `const`は変更できません。
    THRESHOLD = 5;
    // FIXME ^ この行をコメントアウトしてください
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-12" id="こちらも参照-12">こちらも参照:</a></h3>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md">The <code>const</code>/<code>static</code> RFC</a></li>
<li><a href="custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code>ライフタイム</a></li>
</ul>
<h1><a class="header" href="#変数束縛" id="変数束縛">変数束縛</a></h1>
<p>Rustは静的型付けによる型安全性を提供しています。宣言時に型注釈をつけることもできますが、
ほとんどの場合、注釈の労力を軽減するため、コンパイラが変数の型を文脈から推論することが
できます。</p>
<p>(リテラルのような)値は、<code>let</code>を使って変数に束縛することができます。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let an_integer = 1u32;
    let a_boolean = true;
    let unit = ();

    // `an_integer`を`copied_integer`にコピーする
    let copied_integer = an_integer;

    println!(&quot;An integer: {:?}&quot;, copied_integer);
    println!(&quot;A boolean: {:?}&quot;, a_boolean);
    println!(&quot;Meet the unit value: {:?}&quot;, unit);

    // コンパイラは、使われていない変数の束縛に対して警告をします。
    // 変数名の最初にアンダースコアを付けることによって無効化できます。
    let _unused_variable = 3u32;

    let noisy_unused_variable = 2u32;
    // FIXME ^ 警告を消すため、アンダースコアを付けてください。
}
</code></pre></pre>
<h1><a class="header" href="#可変性" id="可変性">可変性</a></h1>
<p>変数束縛はデフォルトで不変ですが、<code>mut</code>修飾子で上書きできます。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let _immutable_binding = 1;
    let mut mutable_binding = 1;

    println!(&quot;Before mutation: {}&quot;, mutable_binding); // 変更する前: {}

    // Ok
    mutable_binding += 1;

    println!(&quot;After mutation: {}&quot;, mutable_binding); // 変更した後: {}

    // エラー!
    _immutable_binding += 1;
    // FIXME ^ この行をコメントアウトしてください。
}
</code></pre></pre>
<p>コンパイラは可変性に関するエラーに対して詳細な診断をします。</p>
<h1><a class="header" href="#スコープとシャドーイング" id="スコープとシャドーイング">スコープとシャドーイング</a></h1>
<p>変数束縛は、スコープを持ち、それは<em>ブロック</em>内で有効です。ブロックは、
波括弧<code>{}</code>でくくられた文の集合のことです。さらに、<a href="https://en.wikipedia.org/wiki/Variable_shadowing">変数のシャドーイング
</a>も許可されています。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // この束縛はmain関数内で有効です。
    let long_lived_binding = 1;

    // これはブロックで、main関数より小さいスコープを持っています。
    {
        // このブロック内でのみ有効。
        let short_lived_binding = 2;

        println!(&quot;inner short: {}&quot;, short_lived_binding);

        // 外側の束縛を*覆い隠す*ことができます。
        let long_lived_binding = 5_f32;

        println!(&quot;inner long: {}&quot;, long_lived_binding);
    }
    // ブロックの終わり

    // エラー! `short_lived_binding`はこのスコープに存在しません。
    println!(&quot;outer short: {}&quot;, short_lived_binding);
    // FIXME ^ この行をコメントアウトしてください。

    println!(&quot;outer long: {}&quot;, long_lived_binding);
    
    // この束縛も前の束縛を*覆い隠し*ます。
    let long_lived_binding = 'a';
    
    println!(&quot;outer long: {}&quot;, long_lived_binding);
}
</code></pre></pre>
<h1><a class="header" href="#宣言" id="宣言">宣言</a></h1>
<p>変数を最初に宣言して、後で初期化することができます。
しかし、初期化されていない変数を使う危険性があるので、めったに
使いません。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // 変数束縛の宣言
    let a_binding;

    {
        let x = 2;

        // 束縛の初期化
        a_binding = x * x;
    }

    println!(&quot;a binding: {}&quot;, a_binding);

    let another_binding;

    // エラー! 初期化されていない変数を使用しています。
    println!(&quot;another binding: {}&quot;, another_binding);
    // FIXME ^ この行をコメントアウトする

    another_binding = 1;

    println!(&quot;another binding: {}&quot;, another_binding);
}
</code></pre></pre>
<p>未定義な動作をする危険があるので、コンパイラは初期化されていない変数の使用を禁止しています。</p>
<h1><a class="header" href="#フリーズ" id="フリーズ">フリーズ</a></h1>
<p>データが同じ名前の不変な変数に覆い隠された時、これも<em>フリーズ</em>します。
<em>フリーズされた</em>データは、不変な束縛がスコープを外れるまで、変更できません。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let mut _mutable_integer = 7i32;

    {
        // 不変な`_mutable_integer`で覆い隠す
        let _mutable_integer = _mutable_integer;

        // エラー! `_mutable_integer`はこのスコープではフリーズされています。
        _mutable_integer = 50;
        // FIXME ^ この行をコメントアウトする

        // `_mutable_integer`がスコープを出る
    }

    // Ok! このスコープでは`_mutable_integer`はフリーズされていません。
    _mutable_integer = 3;
}
</code></pre></pre>
<h1><a class="header" href="#型" id="型">型</a></h1>
<p>Rustは、プリミティブやユーザー定義型を変更、定義できるいくつかのメカニズム
を提供しています。以下の節でカバーします。</p>
<ul>
<li>プリミティブ型の間で<a href="types/cast.html">キャスト</a>する</li>
<li>希望する<a href="types/literals.html">リテラル</a>のを指定する</li>
<li><a href="types/inference.html">型推論</a>を使う</li>
<li>型を<a href="types/alias.html">エイリアシング</a>する</li>
</ul>
<h1><a class="header" href="#キャスト" id="キャスト">キャスト</a></h1>
<p>Rustはプリミティブ型の暗黙的な変換(強制)を提供していません。しかし、
<code>as</code>キーワードで明示的な変換(キャスト)ができます。</p>
<p>整数型の変換に関する規則はCと基本的に同じですが、Cには未定義動作があり、
Rustはすべての型キャストがうまく定義されています。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// キャストでの桁溢れに関する警告をなくす。
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // エラー! 暗黙的な変換はしません
    let integer: u8 = decimal;
    // FIXME ^ この行をコメントアウトしてください

    // 明示的な変換
    let integer = decimal as u8;
    let character = integer as char;

    // エラー! これは変換規則によって禁止されています。浮動小数点は文字に直接変換できません。
    let character = decimal as char;
    // FIXME ^ この行をコメントアウトしてください

    println!(&quot;Casting: {} -&gt; {} -&gt; {}&quot;, decimal, integer, character);

    // 値を符号なし整数型Tにキャストするときは、T::MAX + 1
    // を新しい型にフィットするように加減します。

    // 1000はu16にフィットしています。
    println!(&quot;1000 as a u16 is: {}&quot;, 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // 内部時には、最初の8最下位ビット(LSB)は保存され、
    // 残りの最上位ビットは切り捨てられます。
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // -1 + 256 = 255
    println!(&quot;  -1 as a u8 is : {}&quot;, (-1i8) as u8);

    // 正の数は、剰余と同じです。
    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);

    // 符号付き整数型に変換する時、(ビット処理)結果は対応する符号なし整数型への
    // キャストの結果と同じです。最上位ビットが1の時、その値は負です。

    // もちろん、これはすでにフィットしています。
    println!(&quot; 128 as a i16 is: {}&quot;, 128 as i16);
    // 128 as u8 -&gt; 128  これの8ビットでの2の補数は
    println!(&quot; 128 as a i8 is : {}&quot;, 128 as i8);

    // 上の例を繰り返します。
    // 1000 as u8 -&gt; 232
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // 232の2の補数は-24
    println!(&quot; 232 as a i8 is : {}&quot;, 232 as i8);
}
</code></pre></pre>
<h1><a class="header" href="#リテラル" id="リテラル">リテラル</a></h1>
<p>数値リテラルはサフィックスで型の注釈が付けられます。例として、
<code>42</code>というリテラルの型を<code>i32</code>であると指定するには、<code>42i32</code>と書きます。</p>
<p>サフィックスされていない数値リテラルの型は、それががどう使われるかによります。もし
制約がなければ、コンパイラは整数に<code>i32</code>を、浮動小数点数に<code>f64</code>を使います。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // サフィックスされたリテラル。これらの型は初期化時に特定されます。
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // サフィックスされていないリテラル。どのように使われるかによって型が決まる。
    let i = 1;
    let f = 1.0;

    // `size_of_val` は変数のバイト数を返します。
    println!(&quot;size of `x` in bytes: {}&quot;, std::mem::size_of_val(&amp;x));
    println!(&quot;size of `y` in bytes: {}&quot;, std::mem::size_of_val(&amp;y));
    println!(&quot;size of `z` in bytes: {}&quot;, std::mem::size_of_val(&amp;z));
    println!(&quot;size of `i` in bytes: {}&quot;, std::mem::size_of_val(&amp;i));
    println!(&quot;size of `f` in bytes: {}&quot;, std::mem::size_of_val(&amp;f));
}
</code></pre></pre>
<p>このコードにはまだ説明していないいくつかのまだ説明していない概念が使われています。
ここで短気な読者のために簡単に説明します。</p>
<ul>
<li><code>std::mem::size_of_val</code>は関数ですが、<em>フルパス</em>で呼び出されています。コードは
<em>モジュール</em>と呼ばれる論理ユニットで分割できます。ここでは、<code>size_of_val</code>関数は
<code>mem</code>モジュールで定義され、<code>mem</code>モジュールは<code>std</code><em>クレート</em>で定義されています。
詳細は、<a href="types/../mod.html">モジュール</a>と<a href="types/../crates.html">クレート</a>を見てください。</li>
</ul>
<h1><a class="header" href="#推論" id="推論">推論</a></h1>
<p>型推論システムはとても賢いです。初期化時の式の値の型だけでなく、
その変数が後でどのように使われるかによって型を推論します。
ここに型推論についての高度な例があります。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // 注釈によって、コンパイラは`elem`の型がu8であることを知ります。
    let elem = 5u8;

    // 空のベクター(可変長配列)を作ります。
    let mut vec = Vec::new();
    // この時点では、コンパイラは`vec`の型を正確には知りません。
    // なにかのベクター(`Vec&lt;_&gt;`)であることだけわかっています。

    // `elem`をベクターにプッシュします。
    vec.push(elem);
    // ああ! 今、コンパイラは`vec`が`u8`のベクター(`Vec&lt;u8&gt;`)であることを知りました。
    // TODO ^ `vec.push(elem)`行をコメントアウトしてみてください。

    println!(&quot;{:?}&quot;, vec);
}
</code></pre></pre>
<p>型の注釈が必要なくなると、コンパイラもプログラマも幸せになれます!</p>
<h1><a class="header" href="#エイリアシング" id="エイリアシング">エイリアシング</a></h1>
<p><code>type</code>文は存在する型に新しい名前を付けるのに使えます。型は<code>UpperCamelCase</code>
(単語のはじめが大文字)の名前を持つ必要があり、そうでないとコンパイラは警告
を出します。ただし、<code>usize</code>、<code>f32</code>などのプリミティブ型は例外です。</p>
<pre><pre class="playpen"><code class="language-rust editable">// `NanoSecond`は`u64`の新しい名前です。
type NanoSecond = u64;
type Inch = u64;

// 警告が出ないように属性を付けます。
#[allow(non_camel_case_types)]
type u64_t = u64;
// TODO ^ 属性を消してみてください。

fn main() {
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    // 型エイリアスは新しい型ではないので、余分な型安全性を提供しない
    // ことに注意してください。
    println!(&quot;{} nanoseconds + {} inches = {} unit?&quot;,
             nanoseconds,
             inches,
             nanoseconds + inches);
}
</code></pre></pre>
<p>エイリアスは主に冗長性を軽減するために使われます。例えば、<code>IoResult&lt;T&gt;</code>型は
<code>Result&lt;T, IoError&gt;</code>型のエイリアスです。</p>
<h3><a class="header" href="#こちらも参照-13" id="こちらも参照-13">こちらも参照</a></h3>
<ul>
<li><a href="types/../attribute.html">属性</a></li>
</ul>
<h1><a class="header" href="#変換" id="変換">変換</a></h1>
<p>プリミティブ型は<a href="types/cast.html">キャスト</a>で変換できます。</p>
<p>Rustはカスタム型(<code>struct</code>と<code>enum</code>のこと)の変換を<a href="trait.html">トレイト</a>を使って
処理しています。汎用的な変換は<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>トレイトや<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>トレイトを使って行われます。
しかし、 特に<code>String</code>へ、<code>String</code>からの変換など、より一般的なケースのため、より
具体的な変換が必要になることがあります。</p>
<h1><a class="header" href="#fromとinto" id="fromとinto"><code>From</code>と<code>Into</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>トレイトと<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>トレイとは本質的にリンクされていて、これは実際には
その実装の一部です。もし型Aから型Bに変換できたら、型Bから型Aに変換できると
信じるのは簡単でしょう。</p>
<h2><a class="header" href="#from" id="from"><code>From</code></a></h2>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>トレイトで、他の型からどのように自分自身を作ることができるかを定義できます。
これによって、いくつかの型と変換するとてもシンプルなメカニズムを提供しています。
標準ライブラリに、一般的な型とプリミティブ型を変換するための、このトレイトの
数多くの実装があります。</p>
<p>例として、<code>str</code>は<code>String</code>に簡単に変換できます。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let my_str = &quot;hello&quot;;
let my_string = String::from(my_str);
<span class="boring">}
</span></code></pre></pre>
<p>同じように、独自の型に対して実装できます。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<h2><a class="header" href="#into" id="into"><code>Into</code></a></h2>
<p><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>トレイトは単純に<code>From</code>トレイトの逆です。もし<code>From</code>トレイトが
あなたの型に実装されていたら、<code>Into</code>は必要に応じてこれを呼び出します。</p>
<p>コンパイラはほとんどの場合変換する型を決めることができないので、<code>Into</code>
トレイトを使うには、それを指定する必要があります。しかし、これは自由に
機能が得られることを考えれば小さなトレードオフです。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // 型の宣言を削除してみてください
    let num: Number = int.into();
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<h1><a class="header" href="#tryfromとtryinto" id="tryfromとtryinto"><code>TryFrom</code>と<code>TryInto</code></a></h1>
<p>S<a href="conversion/from_into.html"><code>From</code>と<code>Into</code></a>に似ていますが、<a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a>と<a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a>は
型を変換するための汎用的なトレイトです。<code>From</code>/<code>Into</code>とは違い、<code>TryFrom</code>/
<code>TryInto</code>は、失敗するかもしれない変換ができ、<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>を返します。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::convert::TryFrom;
use std::convert::TryInto;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32);

impl TryFrom&lt;i32&gt; for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();
    assert_eq!(result, Err(()));
}
</code></pre></pre>
<h1><a class="header" href="#stringsから変換stringに変換" id="stringsから変換stringに変換">Stringsから変換、Stringに変換</a></h1>
<h2><a class="header" href="#stringに変換" id="stringに変換">Stringに変換</a></h2>
<p>ある型から<code>String</code>に変換するには、その型に<a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>トレイトを実装するだけで
良いです。 直接実装するより、<a href="conversion/../hello/print.html"><code>print!</code></a>節で説明したように、<a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>を
自動的に提供する<a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>fmt::Display</code></a>トレイトを実装した方が良いです。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt;

struct Circle {
    radius: i32
}

impl fmt::Display for Circle {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;Circle of radius {}&quot;, self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!(&quot;{}&quot;, circle.to_string());
}
</code></pre></pre>
<h2><a class="header" href="#stringを解析する" id="stringを解析する">Stringを解析する</a></h2>
<p>文字列から変換される最も一般的な型は数値型です。慣用的なアプローチは、
<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code></a>関数を使い、型推論か「ターボフィッシュ(turbofish)」構文を
使って型を指定することです。両方の例が以下に紹介されています。</p>
<p>これで文字列をその型に<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a>トレイトが実装されている限り、指定した型に変換することが
できます。これは標準ライブラリ内の数多くの型で実装できます。この機能をユーザー定義型に
追加するには、単純に<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a>トレイトを実装すればよいだけです。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let parsed: i32 = &quot;5&quot;.parse().unwrap();
    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();

    let sum = parsed + turbo_parsed;
    println!(&quot;Sum: {:?}&quot;, sum);
}
</code></pre></pre>
<h1><a class="header" href="#式" id="式">式</a></h1>
<p>Rustプログラムは(ほとんど)文の集合でできています。</p>
<pre><code>fn main() {
    // 文
    // 文
    // 文
}
</code></pre>
<p>Rustの文にはいくつかの種類があります。最も一般的な2つは変数束縛と、
<code>;</code>を使った式です。</p>
<pre><code>fn main() {
    // 変数束縛
    let x = 5;

    // 式;
    x;
    x + 1;
    15;
}
</code></pre>
<p>ブロックも式です。なので、値として扱うことができます。その場合、
ブロックの最後の式がローカル変数のような場所を表す式に代入されます。
ただし、ブロックの最後の式がセミコロンで終わる場合は、返り値は<code>()</code>に
なります。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // This expression will be assigned to `y`
        x_cube + x_squared + x
    };

    let z = {
        // セミコロンがあるので、`z`には`()`が代入されます。
        2 * x;
    };

    println!(&quot;x is {:?}&quot;, x);
    println!(&quot;y is {:?}&quot;, y);
    println!(&quot;z is {:?}&quot;, z);
}
</code></pre></pre>
<h1><a class="header" href="#フロー制御" id="フロー制御">フロー制御</a></h1>
<p><code>if</code>/<code>else</code>、<code>for</code>などのフロー制御は、あらゆるプログラミング言語にとって
重要な要素です。Rustのフロー制御について見ていきましょう。</p>
<h1><a class="header" href="#ifelse" id="ifelse">if/else</a></h1>
<p><code>if</code>-<code>else</code>での条件分岐は他の言語とほぼ同じです。多くの言語と違って、
条件を括弧で囲む必要はありません。また、条件の後にはブロックが続きます。
<code>if</code>-<code>else</code>は式の一種であり、すべての枝が同じ型を返す必要があります。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let n = 5;

    if n &lt; 0 {
        print!(&quot;{} is negative&quot;, n);  // {}は負です
    } else if n &gt; 0 {
        print!(&quot;{} is positive&quot;, n);  // {}は正です
    } else {
        print!(&quot;{} is zero&quot;, n);  // {}はゼロです
    }

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, and is a small number, increase ten-fold&quot;);  // そして、小さいので、10倍します

            // この式は`i32`を返します。
            10 * n
        } else {
            println!(&quot;, and is a big number, halve the number&quot;);  // そして、大きいので、半分にします

            // この式は`i32`を返す必要があります
            n / 2
            // TODO ^ この式にセミコロンを付けてみてください。
        };
    //   ^ ここにセミコロンを付けるのを忘れないでください! すべての`let`文に必要です。

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
}
</code></pre></pre>
<h1><a class="header" href="#loop" id="loop">loop</a></h1>
<p>Rustは、無限ループを作る<code>loop</code>キーワードを提供しています。</p>
<p><code>break</code>文でいつでもループを抜けることができ、<code>continue</code>文で残りの
部分を飛ばして次の繰り返しに進むことができます。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut count = 0u32;

    println!(&quot;Let's count until infinity!&quot;);  // 無限まで数えましょう!

    // 無限ループ
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;three&quot;);

            // 残りの処理を飛ばして次に行く。
            continue;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;OK, that's enough&quot;);  // OK, これで十分

            // このループを抜ける
            break;
        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#ネストとラベル" id="ネストとラベル">ネストとラベル</a></h1>
<p>ネストされたループを扱っている時、外側のループを<code>break</code>、<code>continue</code> できます。
その時は、ループはラベル<code>'label</code>で注釈されている必要があり、<code>break</code>/<code>continue</code>文
にラベルを渡さなければいけません。</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(unreachable_code)]

fn main() {
    'outer: loop {
        println!(&quot;Entered the outer loop&quot;);  // 外側のループに入りました

        'inner: loop {
            println!(&quot;Entered the inner loop&quot;);  // 内側のループに入りました

            // 内側のループだけから抜けます
            //break;

            // 外側のループを抜けます
            break 'outer;
        }

        println!(&quot;This point will never be reached&quot;);  // ここは決して実行されません
    }

    println!(&quot;Exited the outer loop&quot;);  // 外側のループを出ました
}
</code></pre></pre>
<h1><a class="header" href="#ループの返り値" id="ループの返り値">ループの返り値</a></h1>
<p><code>loop</code>の使い道の一つは成功するまでオペレーションを繰り返すことです。オペレーション
が値を返す時、それを残りのコードに渡す必要があるかもしれません。
それを<code>break</code>に渡せば、<code>loop</code>式から値が返されます。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<h1><a class="header" href="#while" id="while">while</a></h1>
<p><code>while</code>キーワードは条件が真である間ループするのに使います。</p>
<p>悪名高き<a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a>を<code>while</code>ループで書いてみましょう。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // カウンタ変数
    let mut n = 1;

    // `n`が101より小さい間ループする
    while n &lt; 101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }

        // カウンタをインクリメントする
        n += 1;
    }
}
</code></pre></pre>
<h1><a class="header" href="#forループ" id="forループ">forループ</a></h1>
<h2><a class="header" href="#forとrange" id="forとrange">forとrange</a></h2>
<p><code>for in</code>文は<code>イテレータ</code>を使って繰り返し処理をするのに使います。
イテレータを作る最も簡単な方法の一つは、<code>a..b</code>のように書くことです。
これは<code>a</code>(含む)から<code>b</code>(除く)までの数値を順に産出(<code>yield</code>)します。</p>
<p><code>while</code>の代わりに<code>for</code>を使ってFizzBuzzを書いてみましょう。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `n`はそれぞれの繰り返しで1, 2, ..., 100の値をとります
    for n in 1..101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<p>代わりに<code>a..=b</code>で両端を含むことができます。
上の例は次のように書けます。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `n`はそれぞれの繰り返しで1, 2, ..., 100の値をとります
    for n in 1..=100 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<h2><a class="header" href="#forとイテレータ" id="forとイテレータ">forとイテレータ</a></h2>
<p><code>for in</code>文は<code>イテレータ</code>といくつかの方法で相互作用することができます。
<a href="flow_control/../trait/iter.html">イテレータ</a>トレイトの節で議論したように、デフォルトで<code>for</code>ループは
コレクションの<code>into_iter</code>関数を実行しますが、これだけがコレクションを
イテレータに変換するわけではありません。</p>
<p><code>into_iter</code>、<code>iter</code>、<code>iter_mut</code>はその中のデータに対する異なる見方を使って、
違った方法でコレクションをイテレータに変換します。</p>
<ul>
<li><code>iter</code> - これは、コレクションの各要素を各イテレーションで借用します。
コレクション変更しないため、ループの後に再利用できます。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter() {
        match name {
            &amp;&quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),  // 私達のようなRustaceanがいます
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<ul>
<li><code>into_iter</code> - これはコレクションを消費し、各繰り返しで正確なデータを提供します。
一度コレクションが消費されると、データを「move」し、もはや再利用できないようになります。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.into_iter() {
        match name {
            &quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<ul>
<li><code>iter_mut</code> - コレクションの各要素を可変的に借用し、コレクションをその場で変更できる
ようにします。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter_mut() {
        *name = match name {
            &amp;mut &quot;Ferris&quot; =&gt; &quot;There is a rustacean among us!&quot;,
            _ =&gt; &quot;Hello&quot;,
        }
    }

    println!(&quot;names: {:?}&quot;, names);
}
</code></pre></pre>
<p>上記の例では<code>match</code>分岐の型が、繰り返しのタイプの違いを示すキーになります。
タイプの違いによって、違った振る舞いができることが分かるでしょう。</p>
<h3><a class="header" href="#こちらも参照-14" id="こちらも参照-14">こちらも参照:</a></h3>
<ul>
<li><a href="flow_control/../trait/iter.html">イテレータ</a></li>
</ul>
<h1><a class="header" href="#match" id="match">match</a></h1>
<p>RustはCの<code>switch</code>のような、<code>match</code>キーワードによる条件分岐を提供しています。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let number = 13;
    // TODO ^ `number`を違う値にして試してみてください。

    println!(&quot;Tell me about {}&quot;, number);  // {}について教えて
    match number {
        //一つの値にマッチする
        1 =&gt; println!(&quot;One!&quot;),
        // いくつかの値にマッチする
        2 | 3 | 5 | 7 | 11 =&gt; println!(&quot;This is a prime&quot;),
        // 最後の値を含むrangeにマッチする
        13..=19 =&gt; println!(&quot;A teen&quot;),
        // Handle the rest of cases
        _ =&gt; println!(&quot;Ain't special&quot;),
    }

    let boolean = true;
    // Matchも式です
    let binary = match boolean {
        // matchのアームはとりうるすべての値を網羅しなければなりません。
        false =&gt; 0,
        true =&gt; 1,
        // TODO ^ 上のどちらかをコメントアウトしてしてください。
    };

    println!(&quot;{} -&gt; {}&quot;, boolean, binary);
}
</code></pre></pre>
<h1><a class="header" href="#分割代入" id="分割代入">分割代入</a></h1>
<p><code>match</code>ブロックで、は様々な方法でアイテムを分割代入できます。</p>
<ul>
<li><a href="flow_control/match/destructuring/destructure_tuple.html">タプルの分割代入</a></li>
<li><a href="flow_control/match/destructuring/destructure_enum.html">Enumの分割代入</a></li>
<li><a href="flow_control/match/destructuring/destructure_pointers.html">ポインタの分割代入</a></li>
<li><a href="flow_control/match/destructuring/destructure_structures.html">構造体の分割代入</a></li>
</ul>
<h1><a class="header" href="#タプル-1" id="タプル-1">タプル</a></h1>
<p>タプルは<code>match</code>内で以下のように分割代入できます。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let pair = (0, -2);
    // TODO ^ `pair`を違う値にして試してみてください

    println!(&quot;Tell me about {:?}&quot;, pair);  // {:?}について教えて
    // matchはタプルの分割代入に使えます。
    match pair {
        // 2つ目を分割代入する
        (0, y) =&gt; println!(&quot;First is `0` and `y` is `{:?}`&quot;, y),  // 最初は`0`で`y`は`{:?}`です
        (x, 0) =&gt; println!(&quot;`x` is `{:?}` and last is `0`&quot;, x),  // `x`は`{:?}`で最後は`0`です
        _      =&gt; println!(&quot;It doesn't matter what they are&quot;),  // これが何なのかわかりません
        // `_` は値を変数として束縛しないことを意味します。
    }
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-15" id="こちらも参照-15">こちらも参照:</a></h3>
<ul>
<li><a href="flow_control/match/destructuring/../../../primitives/tuples.html">タプル</a></li>
</ul>
<h1><a class="header" href="#enum-1" id="enum-1">enum</a></h1>
<p><code>enum</code>も似たように分割代入できます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// 列挙子を一つしか使わないので、警告を消すために
// `allow`が必要です。
#[allow(dead_code)]
enum Color {
    // この3つは名前だけで扱います。
    Red,
    Blue,
    Green,
    // これらは、カラーモデルと言って、`u32`タプルを併せて扱います。
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    let color = Color::RGB(122, 17, 40);
    // TODO ^ `color`の違う列挙子で試してみてください。

    println!(&quot;What color is it?&quot;);
    //  `enum`は`match`を使って分割代入できます。
    match color {
        Color::Red   =&gt; println!(&quot;The color is Red!&quot;),
        Color::Blue  =&gt; println!(&quot;The color is Blue!&quot;),
        Color::Green =&gt; println!(&quot;The color is Green!&quot;),
        Color::RGB(r, g, b) =&gt;
            println!(&quot;Red: {}, green: {}, and blue: {}!&quot;, r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!(&quot;Hue: {}, saturation: {}, value: {}!&quot;, h, s, v),  // 色相: {}, 彩度: {}, 明度: {}
        Color::HSL(h, s, l) =&gt;
            println!(&quot;Hue: {}, saturation: {}, lightness: {}!&quot;, h, s, l),  // 色相: {}, 彩度: {}, 輝度: {}
        Color::CMY(c, m, y) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}!&quot;, c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}, key (black): {}!&quot;,
                c, m, y, k),
        // すべての列挙子を使っったので、もう1つのアームは必要ありません。
    }
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-16" id="こちらも参照-16">こちらも参照:</a></h3>
<ul>
<li><a href="flow_control/match/destructuring/../../../attribute/unused.html"><code>#[allow(...)]</code></a></li>
<li><a href="https://en.wikipedia.org/wiki/Color_model">カラーモデル</a></li>
<li><a href="flow_control/match/destructuring/../../../custom_types/enum.html"><code>enum</code></a></li>
</ul>
<h1><a class="header" href="#ポインタ参照" id="ポインタ参照">ポインタ/参照</a></h1>
<p>Rustのポインタは、<code>C</code>のような言語とは違い、間接参照と分割代入を区別する
必要があります。</p>
<ul>
<li>間接参照には<code>*</code>を使う</li>
<li>分割代入には<code>&amp;</code>、<code>ref</code>、<code>ref mut</code>を使う</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `i32`の参照を代入する。`&amp;`で参照であることを
    // 明示している。
    let reference = &amp;4;

    match reference {
        // `reference`が`&amp;val`にマッチした時、次の2つが
        // 比較されている。
        // `&amp;i32`
        // `&amp;val`
        // ^ よって`&amp;`が外れると、`i32`が
        // `val`に代入される。
        &amp;val =&gt; println!(&quot;Got a value via destructuring: {:?}&quot;, val),  // 分割代入で値を取得しました: {:?}
    }

    // `&amp;`をなくしたいときは、マッチする前に間接参照する
    match *reference {
        val =&gt; println!(&quot;Got a value via dereferencing: {:?}&quot;, val),  // 間接参照で値を取得しました: {:?}
    }

    // 参照を代入しない場合はどうでしょうか? `reference`は右辺値が`&amp;`で
    // 始まっていたので参照でしたが、これは参照ではありません。
    let _not_a_reference = 3;

    // Rustはちょうどこの場合のために`ref`を提供しています。要素の参照が
    // 作られ、それが代入されます。
    let ref _is_a_reference = 3;

    // 同様に、参照を使わずに値を定義し、`ref`や`ref mut`で参照
    // を取得することができます。
    let value = 5;
    let mut mut_value = 6;

    // `ref`キーワードで参照を作りましょう
    match value {
        ref r =&gt; println!(&quot;Got a reference to a value: {:?}&quot;, r),  // 値の参照を取得しました
    }

    // 同様に`ref mut`を使います。
    match mut_value {
        ref mut m =&gt; {
            // 参照を取得して、値を変更するには間接参照する必要がある。
            *m += 10;
            println!(&quot;We added 10. `mut_value`: {:?}&quot;, m);  // 10加えました。`mut_value`: {:?}
        },
    }
}
</code></pre></pre>
<h1><a class="header" href="#構造体-1" id="構造体-1">構造体</a></h1>
<p>同様に、<code>struct</code>も以下のように分割代入できます。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    struct Foo {
        x: (u32, u32),
        y: u32,
    }

    // 値を変更して、何が起こるか見てみましょう。
    let foo = Foo { x: (1, 2), y: 3 };

    match foo {
        Foo { x: (1, b), y } =&gt; println!(&quot;First of x is 1, b = {},  y = {} &quot;, b, y),  // xの最初は1, b = {}, y = {}

        // 構造体を分割代入して、変数を改名することができます。
        // 順番は関係ありません
        Foo { y: 2, x: i } =&gt; println!(&quot;y is 2, i = {:?}&quot;, i),  // yは2, i = {:?}

        // いくつかの変数を無視することができます。
        Foo { y, .. } =&gt; println!(&quot;y = {}, we don't care about x&quot;, y),  // y = {}, xについてはわかりません
        // `x`に言及していないため、エラーになります。
        //Foo { y } =&gt; println!(&quot;y = {}&quot;, y),
    }
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-17" id="こちらも参照-17">こちらも参照:</a></h3>
<ul>
<li><a href="flow_control/match/destructuring/../../../custom_types/structs.html">構造体</a></li>
<li><a href="flow_control/match/destructuring/../../../scope/borrow/ref.html">refパターン</a></li>
</ul>
<h1><a class="header" href="#ガード" id="ガード">ガード</a></h1>
<p><code>match</code>ではアームをふるい分けするのに<em>ガード</em>が使えます。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let pair = (2, -2);
    // TODO ^ `pair`を違う値にしてみてください。

    println!(&quot;Tell me about {:?}&quot;, pair);  // {:?}についておしえて
    match pair {
        (x, y) if x == y =&gt; println!(&quot;These are twins&quot;),  // これらは対です
        // ^ `if 条件`がガードとして働きます
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),  // ドドーン!
        (x, _) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),  // はじめの要素が奇数です
        _ =&gt; println!(&quot;No correlation...&quot;),  // 相関がありません
    }
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-18" id="こちらも参照-18">こちらも参照:</a></h3>
<p><a href="flow_control/match/../../primitives/tuples.html">タプル</a></p>
<h1><a class="header" href="#束縛" id="束縛">束縛</a></h1>
<p>変数を直接マッチさせないときは、分割代入なしで自分自身を参照
できません。<code>match</code>は自分自身を束縛する<code>@</code>記号を提供しています。</p>
<pre><pre class="playpen"><code class="language-rust editable">// `age`関数は`u32`を返します
fn age() -&gt; u32 {
    15
}

fn main() {
    println!(&quot;Tell me what type of person you are&quot;);  // あなたがどんな人かおしえて

    match age() {
        0             =&gt; println!(&quot;I'm not born yet I guess&quot;),  // 多分私はまだ生まれていません。
        // 1 ..= 12にはマッチできますが、この子供の歳がわかりません。
        // 代わりに、1 ..= 12の数値を束縛する変数nを用意します。
        // これで歳がわかります。
        n @ 1  ..= 12 =&gt; println!(&quot;I'm a child of age {:?}&quot;, n),  // 私は{:?}歳の子供です
        n @ 13 ..= 19 =&gt; println!(&quot;I'm a teen of age {:?}&quot;, n),  // 私は{:?}歳のティーン(訳注: 10代の若者)です。
        // マッチしなかった場合の処理
        n             =&gt; println!(&quot;I'm an old person of age {:?}&quot;, n),
    }
}
</code></pre></pre>
<p><code>Option</code>のように、「分割代入」した<code>enum</code>の列挙子にも使えます。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn some_number() -&gt; Option&lt;u32&gt; {
    Some(42)
}

fn main() {
    match some_number() {
        // `Some`列挙子で、値が42に等しかったときに、マッチして
        // `n`に束縛する。
        Some(n @ 42) =&gt; println!(&quot;The Answer: {}!&quot;, n),  // 答え: {}!
        // 他の数値にマッチする。
        Some(n)      =&gt; println!(&quot;Not interesting... {}&quot;, n),  // 面白くない... {}
        // 他のもの(`None`列挙子)にマッチする。
        _            =&gt; (),
    }
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-19" id="こちらも参照-19">こちらも参照:</a></h3>
<ul>
<li><a href="flow_control/match/../../fn.html"><code>functions</code></a></li>
<li><a href="flow_control/match/../../custom_types/enum.html"><code>enums</code></a></li>
<li><a href="flow_control/match/../../std/option.html"><code>Option</code></a></li>
</ul>
<h1><a class="header" href="#if-let" id="if-let">if let</a></h1>
<p>enumをマッチする時、しばしば<code>match</code>は冗長です。例えば</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// `Option&lt;i32&gt;`型の`optional`を作成する
let optional = Some(7);

match optional {
    Some(i) =&gt; {
        println!(&quot;This is a really long string and `{:?}`&quot;, i);  // これは本当に長い文字列で、`{:?}`です
        // ^ iをoptionから分割代入しているので、2つインデントが必要です。
    },
    _ =&gt; {},
    // ^ `match`はすべてを網羅しないといけないため、必要です。
    // 無駄だと思いませんか?
};

<span class="boring">}
</span></code></pre></pre>
<p><code>if let</code>はこの場合おいて簡潔な上、失敗時の処理も柔軟にできます。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // すべて`Option&lt;i32&gt;`型です
    let number = Some(7);
    let letter: Option&lt;i32&gt; = None;
    let emoticon: Option&lt;i32&gt; = None;

    // `if let`は、「もし`let`が`number`を分解した
    // 結果が`Some(i)`なら、ブロックを実行する。」
    // という意味です。
    if let Some(i) = number {
        println!(&quot;Matched {:?}!&quot;, i);  // {:?}にマッチしました!
    }

    // もし失敗を扱いたければ、elseを使います。
    if let Some(i) = letter {
        println!(&quot;Matched {:?}!&quot;, i);
    } else {
        // 分解に失敗した時、このブロックを実行します。
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);  // 数字にマッチしませんでした。文字で行きましょう!
    }

    // もう一つ失敗したときの処理を作る
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!(&quot;Matched {:?}!&quot;, i);
    // 失敗した時、`else if`の条件を見て、分岐します。
    } else if i_like_letters {
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    } else {
        // 条件がfalseの時、この枝を実行します。
        println!(&quot;I don't like letters. Let's go with an emoticon :)!&quot;);  // 文字は嫌いです。絵文字で行きましょう :)
    }
}
</code></pre></pre>
<p>同じように、<code>if let</code>はすべてのenumで使えます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// 例で使うenum
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    // 例で使う変数
    let a = Foo::Bar;
    let b = Foo::Baz;
    let c = Foo::Qux(100);
    
    // 変数aはFoo::Barにマッチする
    if let Foo::Bar = a {
        println!(&quot;a is foobar&quot;);
    }
    
    // 変数bはFoo::Barにマッチしないので、
    // 何も出力しない。
    if let Foo::Bar = b {
        println!(&quot;b is foobar&quot;);
    }
    
    // 変数cは値を持つFoo::Quxにマッチし、
    // 前の例のSome()と同じような挙動をする。
    if let Foo::Qux(value) = c {
        println!(&quot;c is {}&quot;, value);
    }

    // `if let`でも束縛は使えます。
    if let Foo::Qux(value @ 100) = c {
        println!(&quot;c is one hundred&quot;);
    }
}
</code></pre></pre>
<p>もう一つの<code>if let</code>の恩恵は、enumのパラメータなしの列挙子にマッチできることです。enumは<code>PartialEq</code>を実装も継承もしないため、enumのインスタンスは比較できず、
<code>if Foo::Bar == a</code> はコンパイルに失敗しますが、 <code>if let</code>で同じことができます。</p>
<p>挑戦しますか? 次の例を<code>if let</code>を使うように修正してください。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// このenumはPartialEqを実装も継承もしません。
// よって、下のFoo::Bar == aは失敗します。
enum Foo {Bar}

fn main() {
    let a = Foo::Bar;

    // 変数aはFoo::Barにマッチします
    if Foo::Bar == a {
    // ^-- この節はコンパイルエラーを起こします。代わりに`if let`を使ってください。
        println!(&quot;a is foobar&quot;);
    }
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-20" id="こちらも参照-20">こちらも参照:</a></h3>
<ul>
<li><a href="flow_control/../custom_types/enum.html"><code>enum</code></a></li>
<li><a href="flow_control/../std/option.html"><code>Option</code></a></li>
<li><a href="https://github.com/rust-lang/rfcs/pull/160">RFC</a></li>
</ul>
<h1><a class="header" href="#while-let" id="while-let">while let</a></h1>
<p><code>if let</code>と同様に、<code>while let</code>も冗長な<code>match</code>文を簡略化するのに使えます。
<code>i</code>をインクリメントする次の節を見てください。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// `Option&lt;i32&gt;`型の`optional`を作ります
let mut optional = Some(0);

// この試行を繰り返します。
loop {
    match optional {
        // `optional`がSome(i)にマッチすれば、このブロックを実行します。
        Some(i) =&gt; {
            if i &gt; 9 {
                println!(&quot;Greater than 9, quit!&quot;);  // 0より大きいので、終了します!
                optional = None;
            } else {
                println!(&quot;`i` is `{:?}`. Try again.&quot;, i);  // `i`は`{:?}`です。もう1度試してください。
                optional = Some(i + 1);
            }
            // ^ 3インデント必要です!
        },
        // マッチしなければ、ループを出ます。
        _ =&gt; { break; }
        // ^ これは必要でしょうか? もっと良い方法があります!
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>while let</code>を使えば、この節をより良くなります。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `Option&lt;i32&gt;`型の`optional`を作ります
    let mut optional = Some(0);

    // 「`let`が`optional`を`Some(i)`に分解できる限り、ブロック(`{}`)を実行し、
    // そうでなければ`break`する」という意味
    while let Some(i) = optional {
        if i &gt; 9 {
            println!(&quot;Greater than 9, quit!&quot;);
            optional = None;
        } else {
            println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
            optional = Some(i + 1);
        }
        // ^ インデントも少なく、明示的な失敗の処理も不要です。
    }
    // ^ `if let`は`else`/`else if`節を持っていますが、
    // `while let`にはありません。
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-21" id="こちらも参照-21">こちらも参照:</a></h3>
<ul>
<li><a href="flow_control/../custom_types/enum.html"><code>enum</code></a></li>
<li><a href="flow_control/../std/option.html"><code>Option</code></a></li>
<li><a href="https://github.com/rust-lang/rfcs/pull/214">RFC</a></li>
</ul>
<h1><a class="header" href="#関数" id="関数">関数</a></h1>
<p>関数は<code>fn</code>キーワードで宣言できます。引数の型は変数のように注釈し、
関数が値を返すときは、その型を矢印<code>-&gt;</code>の後に指定する必要があります。</p>
<p>関数内の最後の式が返されます。また、<code>return</code>文でループや<code>if</code>の中など、
関数の途中で値を返すことができます。</p>
<p>FizzBuzzを関数を使って書き直してみましょう!</p>
<pre><pre class="playpen"><code class="language-rust editable">// C/C++と違い、関数定義の順番に決まりはないです。
fn main() {
    // ここで関数を使い、あとで宣言することができます。
    fizzbuzz_to(100);
}

// 真偽値を返す関数。
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    // コーナーケースでは、関数が終わる前に値を返します。
    if rhs == 0 {
        return false;
    }

    // これは式であり、ここには`return`キーワードが必要ありません。
    lhs % rhs == 0
}

// 値を返さない関数です。実際にはユニット型`()`を返しています。
fn fizzbuzz(n: u32) -&gt; () {
    if is_divisible_by(n, 15) {
        println!(&quot;fizzbuzz&quot;);
    } else if is_divisible_by(n, 3) {
        println!(&quot;fizz&quot;);
    } else if is_divisible_by(n, 5) {
        println!(&quot;buzz&quot;);
    } else {
        println!(&quot;{}&quot;, n);
    }
}

// 関数が`()`を返す時、返り値の型は省略できます。
fn fizzbuzz_to(n: u32) {
    for n in 1..n + 1 {
        fizzbuzz(n);
    }
}
</code></pre></pre>
<h1><a class="header" href="#メソッド" id="メソッド">メソッド</a></h1>
<p>メソッドはオブジェクトに関連付けられた関数です。メソッドは<code>self</code>キーワードで
オブジェクトのデータや、他のメソッドにアクセスできます。メソッドは<code>impl</code>
ブロック内で定義します。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Point {
    x: f64,
    y: f64,
}

// 実装ブロックです。`Point`のすべてのメソッドはここで定義されます。
impl Point {
    // これは静的メソッドです。
    // 静的メソッドは、インスタンスから呼び出す必要はなく、
    // 一般的にコンストラクタとして使われます。
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // 2つの引数をとるもう一つの静的メソッドです。
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // これはインスタンスメソッドです。
    // `&amp;self`は`self: &amp;Self`の糖衣構文であり、`Self`は呼び出し元の
    // オブジェクトの型です。ここでは`Self`は`Rectangle`と等価です。
    fn area(&amp;self) -&gt; f64 {
        // ドット演算子で`self`のフィールドにアクセスできます。
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs`は`f64`のメソッドで、呼び出し元の絶対値を返します。
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // このメソッドは呼び出し元を可変にする必要があります。
    // `&amp;mut self`は`self: &amp;mut Self`の糖衣構文です。
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair`は2つのヒープ上に割り当てられた整数を持ちます。
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // このメソッドは呼び出し元オブジェクトのリソースを「消費」します。
    // `self`は`self: Self`の糖衣構文です。
    fn destroy(self) {
        // `self`を分割代入する。
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);  // Pair({}, {})を破壊しました。

        // `first`と`second`はスコープを出て、開放されます。
    }
}

fn main() {
    let rectangle = Rectangle {
        // 静的メソッドはコロン2つで呼び出します。
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // インスタンスメソッドはドット演算子で呼び出します。つまり、
    // 第一引数`&amp;self`は暗示的に渡されます。`rectangle.perimeter()`は
    // `Rectangle::perimeter(&amp;rectangle)`と同等です。
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // エラー! `rectangle`は不変ですが、メソッドはオブジェクトが可変である
    // ことを要求しています。
    //rectangle.translate(1.0, 0.0);
    // TODO ^ この行をアンコメントしてみてください。

    // OK! 可変な変数は可変なメソッドを呼び出せます。
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // エラー! 前の`destroy`で`pair`を「消費」しました。
    //pair.destroy();
    // TODO ^ この行をアンコメントしてください。
}
</code></pre></pre>
<h1><a class="header" href="#クロージャ" id="クロージャ">クロージャ</a></h1>
<p>Rustのクロージャ(ラムダ式やラムダとも呼ばれる)は環境をキャプチャできる関数です。
例えば、このクロージャはxをキャプチャします。</p>
<pre><code class="language-Rust">|val| val + x
</code></pre>
<p>クロージャの構文と機能はその場での使用に便利です。関数を呼ぶようにクロージャ
を呼び出すことができます。しかし、入力値と返り値の型は推論できますが、入力の変数名は
指定する必要があります。</p>
<p>クロージャの他の特徴としては</p>
<ul>
<li>入力変数名を<code>()</code>ではなく<code>||</code>で囲む。</li>
<li>式が一つのときは<code>{}</code>で囲む必要はありません(他は必須です)。</li>
<li>外部の変数をキャプチャできます。.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // 関数とクロージャでのインクリメント
    fn  function            (i: i32) -&gt; i32 { i + 1 }

    // クロージャは名無しなので、参照に束縛します。
    // 注釈は関数の注釈と同じですが、本体を`{}`で囲む必要は
    // ありません。名無しのクロージャはは呼び出すために
    // 変数に代入する必要があります。
    let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
    let closure_inferred  = |i     |          i + 1  ;

    let i = 1;
    // 関数とクロージャを呼び出す。
    println!(&quot;function: {}&quot;, function(i));
    println!(&quot;closure_annotated: {}&quot;, closure_annotated(i));
    println!(&quot;closure_inferred: {}&quot;, closure_inferred(i));

    // 引数をとらず、`i32`を返すクロージャ。
    // 返り値は推論されます。
    let one = || 1;
    println!(&quot;closure returning one: {}&quot;, one());

}
</code></pre></pre>
<h1><a class="header" href="#キャプチャ" id="キャプチャ">キャプチャ</a></h1>
<p>クロージャは柔軟で、型注釈がなくても動きます。これのおかげで、
場合に応じて所有権をもらったり借用したりすることができます。
クロージャは変数を捕捉(キャプチャ)できます。</p>
<ul>
<li>参照として(<code>&amp;T</code>)</li>
<li>可変参照として(<code>&amp;mut T</code>)</li>
<li>値として(<code>T</code>)</li>
</ul>
<p>クロージャははじめ参照を取得しようとし、場合に応じて他のものも取得します。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    use std::mem;

    let color = String::from(&quot;green&quot;);

    // `color`を借用(`&amp;`)して出力するクロージャを作り、借用と共に変数
    // `print`に保存します。`print`が最後に使われるまで借用は続きます。
    // `println!`は不変参照があれば機能するので、これ以上なにかする必要はない。
    let print = || println!(&quot;`color`: {}&quot;, color);

    // 借用を使ったクロージャを呼び出す。
    print();

    // クロージャは不変な借用しか保持していないため、
    // `color`はもう1度借用できます。
    let _reborrow = &amp;color;
    print();

    // `print`の最後の使用のあとでのみ所有権を渡せます。
    let _color_moved = color;


    let mut count = 0;
    // `count`をインクリメントするクロージャは`&amp;mut count`または`count`を
    // 必要としますが、`&amp;mut count`で事足りるのでそれを使います。よって
    // `count`を借用します。
    //
    // 内部に可変な型があるので、`inc`には`mut`が必要です。
    // 可変なクロージャは呼び出す度に内部変数を変更します。
    let mut inc = || {
        count += 1;
        println!(&quot;`count`: {}&quot;, count);
    };

    // 可変借用を使ったクロージャを呼ぶ。
    inc();

    // あとで呼び出されるため、クロージャはまだ`count`を可変借用しています。
    // なので、もう1度借用とするとエラーになります。
    // let _reborrow = &amp;count; 
    // ^ TODO: この行をアンコメントしてみてください。
    inc();

    // クロージャはもう使われないので、`&amp;mut count`を借用する必要はありません。
    // なので、エラーなく再借用できます。
    let _count_reborrowed = &amp;mut count; 

    
    // コピーできない型
    let movable = Box::new(3);

    // `mem::drop`は`T`を必要とするので、値そのものが必要である。
    // コピーできる型はコピーし、できない型は値をそのまま移動させます。
    let consume = || {
        println!(&quot;`movable`: {:?}&quot;, movable);
        mem::drop(movable);
    };

    // `consume`は変数を消費するため、一度しか呼べません。
    consume();
    // consume();
    // ^ TODO: この行をアンコメントしてみてください。
}
</code></pre></pre>
<p>バーティカルバー(<code>|</code>)の前に<code>move</code>を付けると、キャプチャした変数の
所有権をもらいます。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `Vec`はコピーできない型です。
    let haystack = vec![1, 2, 3];

    let contains = move |needle| haystack.contains(needle);

    println!(&quot;{}&quot;, contains(&amp;1));
    println!(&quot;{}&quot;, contains(&amp;4));

    // println!(&quot;There're {} elements in vec&quot;, haystack.len());
    // ^ ボローチェッカーは移動させた後の変数の再利用を禁止しているので、
    // 上をアンコメントすると、コンパイルエラーになります。
    
    // `move`をクロージャから削除すると、クロージャは変数haystackを不変借用するので、
    // haystackはまだ使え、上をアンコメントしてもエラーしなくなります。
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-22" id="こちらも参照-22">こちらも参照:</a></h3>
<ul>
<li><a href="fn/closures/../../std/box.html"><code>Box</code></a></li>
<li><a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a></li>
</ul>
<h1><a class="header" href="#引数として" id="引数として">引数として</a></h1>
<p>Rustでその場で変数をキャプチャするときは型注釈を省略しましたが、関数を書くときは
この曖昧さは許されません。クロージャを引数として受け取るときは、いくつかの
<code>トレイト</code>を使います。制限の少ない順に、以下の通りです。</p>
<ul>
<li><code>Fn</code>: 参照(<code>&amp;T</code>)をキャプチャするクロージャ</li>
<li><code>FnMut</code>: 可変参照(<code>&amp;mut T</code>)をキャプチャするクロージャ</li>
<li><code>FnOnce</code>: 値(<code>T</code>)をキャプチャするクロージャ</li>
</ul>
<p>コンパイラはできる限り制限が最小になるように変数をキャプチャします。</p>
<p>例えば、引数は<code>FnOnce</code>を注釈していたとしたら、クロージャは<code>&amp;T</code>、<code>&amp;mut T</code>、<code>T</code>
をキャプチャする可能性がありますが、コンパイラはクロージャがどのように
使われているかに応じてこれを決定します。</p>
<p>なぜなら、値の移動ができる時、どのタイプの借用もできるからです。
その逆はできないことに注意してください。引数が<code>Fn</code>を注釈していた場合、
<code>&amp;mut T</code>や<code>T</code>のキャプチャはできません。</p>
<p>次の例で、<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>を入れ替えて何が起こるか試してください。</p>
<pre><pre class="playpen"><code class="language-rust editable">// クロージャを引数として取り、呼び出す関数
// &lt;F&gt;はFが「ジェネリック型の引数」であることを表します。
fn apply&lt;F&gt;(f: F) where
    // このクロージャは引数を取らず、何も返しません
    F: FnOnce() {
    // ^ TODO: `Fn`や`FnMat`に変えてみてください。

    f();
}

// クロージャをとり、`i32`をとる関数
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    // `i32`をとり`i32`を取るクロージャ
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = &quot;hello&quot;;
    // コピーできない型
    // `to_owned`は借用したデータから自分のデータを作成するのに使います。
    let mut farewell = &quot;goodbye&quot;.to_owned();

    // `greeting`という参照と`farewell`という値の2つを
    // キャプチャする
    let diary = || {
        // `greeting`は参照なので`Fn`が必要です。
        println!(&quot;I said {}.&quot;, greeting);  // {}と言った。

        // `farewell`は変更が必要なので可変参照として
        // キャプチャする。ここで`FnMut`が必要になる。
        farewell.push_str(&quot;!!!&quot;);
        println!(&quot;Then I screamed {}.&quot;, farewell);  // そして{}と叫んだ。
        println!(&quot;Now I can sleep. zzzzz&quot;);  // いま寝る。zzzzz

        // `farewell`を手動でDropするため、値としてキャプチャする。
        // ここで`FnOnce`が必要となる。
        mem::drop(farewell);
    };

    // クロージャを実行する関数を呼び出す
    apply(diary);

    // `double`は`apply_to_3`のトレイトの要件を満たす
    let double = |x| 2 * x;

    println!(&quot;3 doubled: {}&quot;, apply_to_3(double));
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-23" id="こちらも参照-23">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a></li>
<li><a href="fn/closures/../../generics.html">ジェネリック</a></li>
<li><a href="fn/closures/../../generics/where.html">where</a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></li>
</ul>
<h1><a class="header" href="#型匿名性" id="型匿名性">型匿名性</a></h1>
<p>クロージャで簡潔にスコープから変数をキャプチャできます。なにか注意する点は
あるのでしょうか? もちろんです。クロージャを引数として取る時、<a href="fn/closures/../../generics.html">ジェネリック
</a>を使わなくてはいけません。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// `F`はジェネリックである必要がある。
fn apply&lt;F&gt;(f: F) where
    F: FnOnce() {
    f();
}
<span class="boring">}
</span></code></pre></pre>
<p>クロージャが作られた時、コンパイラはキャプチャした変数を保存する匿名の
、<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>の3つのトレイトの内一つをその型に対して実装した
構造体を作成し、呼び出されるまで待ちます。</p>
<p>この構造体は型が未指定なため、関数での使用にはジェネリックが必要です。
しかし、型パラメータ<code>&lt;T&gt;</code>を指定するだけではまだ曖昧です。そのため、<code>Fn</code>、
<code>FnMut</code>、<code>FnOnce</code>のどれを実装しているか明示する必要があります。</p>
<pre><pre class="playpen"><code class="language-rust editable">// `F`は`Fn`を実装している必要があり、クロージャは何もとらず何も返さない。
// `print`にはこれが正しい。
fn apply&lt;F&gt;(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // `x`を匿名の型としてキャプチャし、それに
    // `Fn`を実装する。これを`print`に格納する。
    let print = || println!(&quot;{}&quot;, x);

    apply(print);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-24" id="こちらも参照-24">こちらも参照:</a></h3>
<ul>
<li><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">解析</a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></li>
</ul>
<h1><a class="header" href="#入力関数" id="入力関数">入力関数</a></h1>
<p>クロージャが引数として使えることから、関数も同じようにできないのかと思った人も
いるかもしれません。その通り、できます! クロージャを引数に取る関数を定義したら、
そのクロージャのトレイト境界を満たすすべての関数を引数として渡すことができます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// `Fn`を境界としたジェネリック型`F`を引数に取る
// 関数を定義し、渡されたクロージャを即座に呼び出す。
fn call_me&lt;F: Fn()&gt;(f: F) {
    f();
}

// `Fn`境界を満たす関数を定義する。
fn function() {
    println!(&quot;I'm a function!&quot;);
}

fn main() {
    // `Fn`境界を満たすクロージャを定義する。
    let closure = || println!(&quot;I'm a closure!&quot;);

    call_me(closure);
    call_me(function);
}
</code></pre></pre>
<p>クロージャの捕捉について詳しく見たいときは、<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>
トレイトのドキュメントを参照してください。</p>
<h3><a class="header" href="#こちらも参照-25" id="こちらも参照-25">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></li>
</ul>
<h1><a class="header" href="#返り値として" id="返り値として">返り値として</a></h1>
<p>クロージャを引数として取ることができるのなら、クロージャを返す
こともできるはずです。しかし、匿名なクロージャの型は、定義時点では
不明です。そのため、クロージャを返すには<code>impl Trait</code>を使う必要が
あります。</p>
<p>クロージャを返すのに使われるトレイトは以下の通りです。</p>
<ul>
<li><code>Fn</code></li>
<li><code>FnMut</code></li>
<li><code>FnOnce</code></li>
</ul>
<p>キャプチャしている値をすべて渡すため、<code>move</code>キーワードが必要です。これがないと
変数は関数終了と同時にdropされ、クロージャ内のキャプチャしている参照が無効に
なります。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn create_fn() -&gt; impl Fn() {
    let text = &quot;Fn&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnmut() -&gt; impl FnMut() {
    let text = &quot;FnMut&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnonce() -&gt; impl FnOnce() {
    let text = &quot;FnOnce&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();
    let fn_once = create_fnonce();

    fn_plain();
    fn_mut();
    fn_once();
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-26" id="こちらも参照-26">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a></li>
<li><a href="fn/closures/../../generics.html">ジェネリック</a></li>
<li><a href="fn/closures/../../trait/impl_trait.html">impl Trait</a></li>
</ul>
<h1><a class="header" href="#stdでの例" id="stdでの例"><code>std</code>での例</a></h1>
<p>この節では<code>std</code>ライブラリ内でのクロージャの使用例をいくつか紹介します。</p>
<h1><a class="header" href="#iteratorany" id="iteratorany">Iterator::any</a></h1>
<p><code>Iterator::any</code>はイテレータ内に一つでも条件を満たす要素があれば<code>true</code>を、
なければ<code>false</code>を返すメソッドです。</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // イテレータ内の要素の型。
    type Item;

    // `any`は`&amp;mut self`をとるため、呼び出し元を借用し、変更するかも
    // しれませんが、消費はしません。
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where
        // `FnMut`はクロージャがキャプチャした値を変更するかもしれないが、
        // 消費はしないことを表します。`Self::Item`はクロージャに
        // 値を引数として渡すことを意味します。
        F: FnMut(Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // ベクターの`iter()`は`&amp;i32`を産出するので、`i32`に分割代入する必要があります。
    println!(&quot;2 in vec1: {}&quot;, vec1.iter()     .any(|&amp;x| x == 2));
    // ベクターの`into_iter()`は`i32`を産出するので、分割代入は必要ありません。
    println!(&quot;2 in vec2: {}&quot;, vec2.into_iter().any(| x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // 配列の`iter()`は`&amp;i32`を産出します。
    println!(&quot;2 in array1: {}&quot;, array1.iter()     .any(|&amp;x| x == 2));
    // 配列の`into_iter()`もなんと`&amp;i32`を産出します。
    println!(&quot;2 in array2: {}&quot;, array2.into_iter().any(|&amp;x| x == 2));
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-27" id="こちらも参照-27">こちらも参照:</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>std::iter::Iterator::any</code></a></p>
<h1><a class="header" href="#イテレータを検索する" id="イテレータを検索する">イテレータを検索する</a></h1>
<p><code>Iterator::find</code>はイテレータ内で条件を満たす関数を検索する関数です。もし
一つも条件を満たさなかったときは、<code>None</code>を返します。型シグネチャは以下の
通りです。</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // 要素の型
    type Item;

    // `find`は`&amp;mut self`をとります。よって呼び出し元は借用され、変更される
    // かもしれませんが、消費はされません。
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where
        // `FnMut`はキャプチャする値が変更される可能性はあるが、
        // 消費はされないことを表します。`&amp;Self::Item`はクロージャに
        // 参照を渡すことを意味します。
        P: FnMut(&amp;Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // ベクターの`iter()`は`&amp;i32`を産出します。
    let mut iter = vec1.iter();
    // ベクターの`into_iter()`は`i32`を産出します。
    let mut into_iter = vec2.into_iter();

    // ベクターの`iter()`は`&amp;i32`を産出します。要素の参照をとる必要があるので、
    // `&amp;&amp;i32`を`i32`に分割代入する必要があります。
    println!(&quot;Find 2 in vec1: {:?}&quot;, iter     .find(|&amp;&amp;x| x == 2));
    // `into_iter()`は`i32`を産出します。なので同様に、`&amp;i32`を`i32`
    // に分割代入する必要があります。
    println!(&quot;Find 2 in vec2: {:?}&quot;, into_iter.find(| &amp;x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // 配列の`iter()`は`&amp;i32`を産出します。
    println!(&quot;Find 2 in array1: {:?}&quot;, array1.iter()     .find(|&amp;&amp;x| x == 2));
    // 配列の`into_iter()`も`&amp;i32`を産出します。
    println!(&quot;Find 2 in array2: {:?}&quot;, array2.into_iter().find(|&amp;&amp;x| x == 2));
}
</code></pre></pre>
<p><code>Iterator::find</code>は要素の参照を渡します。要素の_インデックス_がほしいときは
<code>Iterator::position</code>を使ってください。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let vec = vec![1, 9, 3, 3, 13, 2];

    let index_of_first_even_number = vec.iter().position(|x| x % 2 == 0);
    assert_eq!(index_of_first_even_number, Some(5));
    
    
    let index_of_first_negative_number = vec.iter().position(|x| x &lt; &amp;0);
    assert_eq!(index_of_first_negative_number, None);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-28" id="こちらも参照-28">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>std::iter::Iterator::find</code></a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find_map"><code>std::iter::Iterator::find_map</code></a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.position"><code>std::iter::Iterator::position</code></a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rposition"><code>std::iter::Iterator::rposition</code></a></li>
</ul>
<h1><a class="header" href="#高階関数" id="高階関数">高階関数</a></h1>
<p>Rustは高階関数(HOF)を提供しています。これは1つ以上の関数を引数にとることで、
より使いやすい関数を作る機能です。高階関数と遅延イテレータはRustの関数型機能です。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}

fn main() {
    println!(&quot;Find the sum of all the squared odd numbers under 1000&quot;);  // 1000以下の奇数かつ平方数の和を求めます
    let upper = 1000;

    // 命令型のアプローチ
    // 蓄積用変数を定義する
    let mut acc = 0;
    // 0, 1, 2, ... と無限まで繰り返す
    for n in 0.. {
        // 数を2乗する
        let n_squared = n * n;

        if n_squared &gt;= upper {
            // 上限を超えれば終了する
            break;
        } else if is_odd(n_squared) {
            // 奇数ならばaccに追加する
            acc += n_squared;
        }
    }
    println!(&quot;imperative style: {}&quot;, acc);  // 命令型: {}

    // 関数型のアプローチ
    let sum_of_squared_odd_numbers: u32 =
        (0..).map(|n| n * n)                             // すべての自然数を2乗する
             .take_while(|&amp;n_squared| n_squared &lt; upper) // 上限まで
             .filter(|&amp;n_squared| is_odd(n_squared))     // 奇数ならば
             .fold(0, |acc, n_squared| acc + n_squared); // 合計する
    println!(&quot;functional style: {}&quot;, sum_of_squared_odd_numbers); // 関数型: {}
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/core/option/enum.Option.html">Option型</a>と<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">イテレータ</a>の実装には高階関数が使われています。</p>
<h1><a class="header" href="#発散関数" id="発散関数">発散関数</a></h1>
<p>発散関数は値を返しません。空の型である<code>!</code>を使って示してください。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; ! {
    panic!(&quot;This call never returns.&quot;);  // この呼び出しは決して返りません。
}
<span class="boring">}
</span></code></pre></pre>
<p>他の方とは違い、この型はインスタンス化できません。この型には持ちうる値
がないからです。一つの値を持ちうる<code>()</code>型とは違うことに注意してください。</p>
<p>例えば、この関数は、返り値の型に関する情報がありませんが、
普通に値を返します。</p>
<pre><pre class="playpen"><code class="language-rust">fn some_fn() {
    ()
}

fn main() {
    let a: () = some_fn();
    println!(&quot;This function returns and you can see this line.&quot;)  // この関数は値を返し、この行が出力されます。
}
</code></pre></pre>
<p>この関数とは違い、呼び出し元に制御が戻ることはありません。</p>
<pre><code class="language-rust ignore">#![feature(never_type)]

fn main() {
    let x: ! = panic!(&quot;This call never returns.&quot;);
    println!(&quot;You will never see this line!&quot;);  // この行は出力されません。
}
</code></pre>
<p>これは、抽象的な概念に見えますが、実はとても有用で、手頃です。
この型の主な利点は、どんな型にもキャストでき、<code>match</code>の枝など、
正確な型が必要なときに使えます。これを使って、このような関数が書けます。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    fn sum_odd_numbers(up_to: u32) -&gt; u32 {
        let mut acc = 0;
        for i in 0..up_to {
            // このmatch式は、変数additionの型であるu32を返さなければ
            // いけないことに注意してください。
            let addition: u32 = match i%2 == 1 {
                // 変数iは u32になるので、問題ありません。
                true =&gt; i,
                // 一方、&quot;continue&quot;式はu32を返しませんが、何も返さないことは、
                // match式の型の要件に違反しないので、これでも問題ありません。
                false =&gt; continue,
            };
            acc += addition;
        }
        acc
    }
    println!(&quot;Sum of odd numbers up to 9 (excluding): {}&quot;, sum_odd_numbers(9));  // 9未満の奇数の和: {}
}
</code></pre></pre>
<p>ネットワークサーバのように、永遠にループ(例えば<code>loop {}</code>)する処理や、
プロセスを終了する関数(例えば<code>exit()</code>)などに使われます。</p>
<h1><a class="header" href="#モジュール" id="モジュール">モジュール</a></h1>
<p>Rustは階層的に論理ユニット(モジュール)によってコードを分割する強力なモジュールシステムを
備えており、その間で可視性(public/private)を操作できます。</p>
<p>モジュールは関数、構造体、トレイト、<code>impl</code>ブロック、そして他のモジュール
などの集合体です。</p>
<h1><a class="header" href="#可視性" id="可視性">可視性</a></h1>
<p>デフォルトで、モジュールの要素はプライベートです。しかし、<code>pub</code>修飾子でこれを
上書きすることができます。パブリックな要素のみがモジュールスコープの外からアクセス
できます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// `my_mod`というモジュールを定義する
mod my_mod {
    // モジュールの要素はデフォルトでプライベートです。
    fn private_function() {
        println!(&quot;called `my_mod::private_function()`&quot;);
    }

    // `pub`修飾子を使って上書きできます。
    pub fn function() {
        println!(&quot;called `my_mod::function()`&quot;);
    }

    // モジュール内では、プライベートな要素を含むすべての
    // 他の要素にアクセスできます。
    pub fn indirect_access() {
        print!(&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;);
        private_function();
    }

    // モジュールはネストできます
    pub mod nested {
        pub fn function() {
            println!(&quot;called `my_mod::nested::function()`&quot;);
        }

        #[allow(dead_code)]
        fn private_function() {
            println!(&quot;called `my_mod::nested::private_function()`&quot;);
        }

        // 関数を`pub(in パス)`構文を使って宣言すると、指定したパスからのみ
        // アクセスできます。`path`は自分の親か、先祖のモジュールでなければいけません。
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!(&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n&gt; &quot;);
            public_function_in_nested();
        }

        // 関数を`pub(self)`構文を使って宣言すると、現在のモジュールでのみ
        // アクセスでき、プライベートと同じになります。
        pub(self) fn public_function_in_nested() {
            println!(&quot;called `my_mod::nested::public_function_in_nested()`&quot;);
        }

        // 関数を`pub(super)`を構文を使って宣言すると、親のモジュールからのみ
        // アクセスできます。
        pub(super) fn public_function_in_super_mod() {
            println!(&quot;called `my_mod::nested::public_function_in_super_mod()`&quot;);
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!(&quot;called `my_mod::call_public_function_in_my_mod()`, that\n&gt; &quot;);
        nested::public_function_in_my_mod();
        print!(&quot;&gt; &quot;);
        nested::public_function_in_super_mod();
    }

    // pub(crate)で関数が現在のクレート内でアクセスできるようになります。
    pub(crate) fn public_function_in_crate() {
        println!(&quot;called `my_mod::public_function_in_crate()`&quot;);
    }

    // ネストされたモジュールも同じ規則に従います。
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!(&quot;called `my_mod::private_nested::function()`&quot;);
        }

        // 親モジュールのプライベートな要素にもアクセスできます。
        // 先祖のモジュールでも同じです。
        #[allow(dead_code)]
        pub(crate) fn restricted_function() {
            println!(&quot;called `my_mod::private_nested::restricted_function()`&quot;);
        }
    }
}

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    // モジュールで同じ名前をもつ要素の明確化ができます。
    function();
    my_mod::function();

    // ネストされたモジュールも含めて、パブリックな要素には
    // 親モジュールの外からでもアクセスできます。
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate)の要素は同じクレート内のどこからでもアクセスできます。
    my_mod::public_function_in_crate();

    // pub(in パス)の要素は指定したモジュールからのみアクセスできます。
    // エラー! `public_function_in_my_mod`関数はプライベートです
    //my_mod::nested::public_function_in_my_mod();
    // TODO ^ この行をアンコメントしてみてください

    // プライベートな要素は、パブリックなモジュールにネスト
    // されていたとしても、直接アクセスできません。

    // エラー! `private_function`はプライベートです。
    //my_mod::private_function();
    // TODO ^ この行をアンコメントしてみてください

    // エラー! `private_function`はプライベートです
    //my_mod::nested::private_function();
    // TODO ^ この行をアンコメントしてみてください

    // エラー! `private_nested`はプライベートモジュールです
    //my_mod::private_nested::function();
    // TODO ^ この行をアンコメントしてみてください

    // エラー! `private_nested`はプライベートモジュールです
    //my_mod::private_nested::restricted_function();
    // TODO ^ この行をアンコメントしてみてください
}
</code></pre></pre>
<h1><a class="header" href="#構造体の可視性" id="構造体の可視性">構造体の可視性</a></h1>
<p>構造体はフィールド内での可視性も持っています。デフォルトではプライベートで、
<code>pub</code>修飾子で上書きできます。この可視性は、定義されたモジュールの外からアクセスする
ときのみ有効で、情報を隠す(カプセル化する)ことを目的としています。</p>
<pre><pre class="playpen"><code class="language-rust editable">mod my {
    // ジェネリック型`T`のパブリックフィールドを持ったパブリックな構造体
    pub struct OpenBox&lt;T&gt; {
        pub contents: T,
    }

    // ジェネリック型`T`のプライベートフィールドを持ったパブリックな構造体
    #[allow(dead_code)]
    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        // パブリックなコンストラクタメソッド
        pub fn new(contents: T) -&gt; ClosedBox&lt;T&gt; {
            ClosedBox {
                contents: contents,
            }
        }
    }
}

fn main() {
    // パブリックフィールドを持ったパブリックな構造体はいつものように宣言できます。
    let open_box = my::OpenBox { contents: &quot;public information&quot; };

    // そしてフィールドにも普通にアクセスできます。
    println!(&quot;The open box contains: {}&quot;, open_box.contents);

    // プライベートフィールドを持ったパブリックな構造体はフィールド名で宣言できません。
    // エラー! `ClosedBox`にはプライベートフィールドがあります。
    //let closed_box = my::ClosedBox { contents: &quot;classified information&quot; };
    // TODO ^ この行をアンコメントしてみてください

    // しかし、パブリックなコンストラクタを使って初期化できます。
    let _closed_box = my::ClosedBox::new(&quot;classified information&quot;);

    // そしてプライベートなフィールドにはアクセスできません
    // エラー! `contents`フィールドはプライベートです
    //println!(&quot;The closed box contains: {}&quot;, _closed_box.contents);
    // TODO ^ この行をアンコメントしてみてください
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-29" id="こちらも参照-29">こちらも参照:</a></h3>
<ul>
<li><a href="mod/../generics.html">ジェネリック</a></li>
<li><a href="mod/../fn/methods.html">メソッド</a></li>
</ul>
<h1><a class="header" href="#use宣言" id="use宣言"><code>use</code>宣言</a></h1>
<p><code>use</code>宣言は、アクセスを簡単にするため、パスに新しい名前を束縛します。
このように使います。</p>
<pre><code class="language-rust editable ignore">// extern crate deeply; // 普通、この行はコメントアウトされていません!

use crate::deeply::nested::{
    my_first_function,
    my_second_function,
    AndATraitType
};

fn main() {
    my_first_function();
}
</code></pre>
<p>違う名前に束縛してインポートするのに<code>as</code>キーワードを使います。</p>
<pre><pre class="playpen"><code class="language-rust editable">// `deeply::nested::function`を`other_function`に束縛する。
use deeply::nested::function as other_function;

fn function() {
    println!(&quot;called `function()`&quot;);
}

mod deeply {
    pub mod nested {
        pub fn function() {
            println!(&quot;called `deeply::nested::function()`&quot;);
        }
    }
}

fn main() {
    // 簡単に`deeply::nested::function`にアクセスできる。
    other_function();

    println!(&quot;Entering block&quot;);
    {
        // これは`use deeply::nested::function as function`と等価で、
        // `function()`はもともとのものを覆い隠します。
        use crate::deeply::nested::function;
        function();

        // `use`束縛はローカルスコープを持っています。ここでは、
        // `function()`のシャドーイングはこのブロック内だけで有効です。
        println!(&quot;Leaving block&quot;);
    }

    function();
}
</code></pre></pre>
<h1><a class="header" href="#superとself" id="superとself"><code>super</code>と<code>self</code></a></h1>
<p><code>super</code>、<code>self</code>キーワードはパス内での要素へのアクセスで曖昧さをなくし、
パスの不要なハードコードを防ぐのに使われます。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn function() {
    println!(&quot;called `function()`&quot;);
}

mod cool {
    pub fn function() {
        println!(&quot;called `cool::function()`&quot;);
    }
}

mod my {
    fn function() {
        println!(&quot;called `my::function()`&quot;);
    }
    
    mod cool {
        pub fn function() {
            println!(&quot;called `my::cool::function()`&quot;);
        }
    }
    
    pub fn indirect_call() {
        // このスコープから`function`という名前のすべての関数にアクセスしましょう!
        print!(&quot;called `my::indirect_call()`, that\n&gt; &quot;);
        
        // `self`キーワードは現在のモジュール(ここでは`my`)を参照します。
        // `self::function()`と`function()`は等価で、同じ結果を返します。 
        self::function();
        function();
        
        // `self`で`my`内の他のモジュールにもアクセスできます。
        self::cool::function();
        
        // `super`キーワードで親スコープ(ここでは`my`モジュールの外側)にアクセスできます。
        super::function();
        
        // ここで*crate*スコープの`cool::function`を束縛します。
        // ここでcrateスコープとは一番外側のスコープのことです。
        {
            use crate::cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}
</code></pre></pre>
<h1><a class="header" href="#ファイル階層" id="ファイル階層">ファイル階層</a></h1>
<p>モジュールはファイル/ディレクトリ階層で表すことができます。
<a href="mod/visibility.html">可視性の例</a>をファイルで再現してみましょう。</p>
<pre><code class="language-shell">$ tree .
.
|-- my
|   |-- inaccessible.rs
|   |-- mod.rs
|   `-- nested.rs
`-- split.rs
</code></pre>
<p><code>split.rs</code>の中身:</p>
<pre><code class="language-rust ignore">// この宣言は`my.rs`または`my/mod.rs`を探索し、そこにあった要素を
// `my`モジュールとしてスコープに導入します。
mod my;

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}

</code></pre>
<p><code>my/mod.rs</code>の中身:</p>
<pre><code class="language-rust ignore">// 同様に`mod inaccessible`と`mod nested`は`nested.rs`や`inaccessible.rs`ファイルを
// 探索し、そのモジュールを導入します。
mod inaccessible;
pub mod nested;

pub fn function() {
    println!(&quot;called `my::function()`&quot;);
}

fn private_function() {
    println!(&quot;called `my::private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called `my::indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre>
<p><code>my/nested.rs</code>の中身:</p>
<pre><code class="language-rust ignore">pub fn function() {
    println!(&quot;called `my::nested::function()`&quot;);
}

#[allow(dead_code)]
fn private_function() {
    println!(&quot;called `my::nested::private_function()`&quot;);
}
</code></pre>
<p><code>my/inaccessible.rs</code>の中身:</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
pub fn public_function() {
    println!(&quot;called `my::inaccessible::public_function()`&quot;);
}
</code></pre>
<p>同じように動くか確かめましょう。</p>
<pre><code class="language-shell">$ rustc split.rs &amp;&amp; ./split
called `my::function()`
called `function()`
called `my::indirect_access()`, that
&gt; called `my::private_function()`
called `my::nested::function()`
</code></pre>
<h1><a class="header" href="#クレート" id="クレート">クレート</a></h1>
<p>クレートはRustにおける編集ユニットです。<code>rustc some_file.rs</code>が呼び出された時、
<code>some_file.rs</code> は<em>クレートファイル</em>として扱われます。もし<code>some_file.rs</code>内に<code>mod</code>
宣言があれば、モジュールファイルの要素がコンパイラを実行する<em>前</em>に挿入されます。
言い換えれば、モジュールは独立してコンパイルされず、クレートのみがコンパイルされる
ということです。</p>
<p>クレートはバイナリまたはライブラリとしてコンパイルできます。デフォルトで、<code>rustc</code>
はクレートからバイナリを作ります。このふるまいは<code>--crate-type</code>フラグに<code>lib</code>を立てる
ことによって上書きできます。</p>
<h1><a class="header" href="#ライブラリ" id="ライブラリ">ライブラリ</a></h1>
<p>ライブラリを作り、他のクレートにリンクしてみましょう。</p>
<pre><code class="language-rust ignore">pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre>
<pre><code class="language-shell">$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
</code></pre>
<p>ライブラリは&quot;lib&quot;で始まる必要があります。デフォルトでクレートファイル
の名前にちなんで名付けられます。しかし、これは<code>ructc</code>の<code>--crate-name</code>
オプションや、<a href="crates/../attribute/crate.html"><code>crate_name</code>属性</a>で上書きできます。</p>
<h1><a class="header" href="#extern-crate" id="extern-crate"><code>extern crate</code></a></h1>
<p>クレートにライブラリをリンクするには、<code>extern crate</code>宣言が必要です。
これはライブラリをリンクするだけでなく、ライブラリのモジュールを
ライブラリ名と同じ名前でインポートします。可視性のルールはモジュール
だけでなくライブラリにも適用されます。</p>
<pre><code class="language-rust ignore">// `library`とリンクし、`rary`モジュールの要素をインポートします。
extern crate rary;

fn main() {
    rary::public_function();

    // エラー! `private_function`はプライベートです
    //rary::private_function();

    rary::indirect_access();
}
</code></pre>
<pre><code class="language-txt"># library.rlibのようなコンパイルされたライブラリのパスは、
# 同じディレクトリにあることが想定されています。
$ rustc executable.rs --extern rary=library.rlib &amp;&amp; ./executable
called rary's `public_function()`
called rary's `indirect_access()`, that
&gt; called rary's `private_function()`
</code></pre>
<h1><a class="header" href="#cargo" id="cargo">Cargo</a></h1>
<p><code>cargo</code>はRustの公式パッケージマネージャです。これはコードの質や開発速度を上げる
のに非常に役立ちます。Cargoには次のような機能があります。</p>
<ul>
<li>依存管理と<a href="https://crates.io">crates.io</a>(Rustの公式パッケージレジストリ)
との連携</li>
<li>ユニットテストの自動化</li>
<li>ベンチマークの自動化</li>
</ul>
<p>この章では基本的な使い方を説明します。包括的な情報は<a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a>
を参照してください。</p>
<h1><a class="header" href="#依存" id="依存">依存</a></h1>
<p>ほとんどのプログラムはライブラリへの依存を持ちます。もし手動で依存を管理したことがないなら、
その苦痛はわからないでしょう。幸運なことに、Rustのエコシステムは<code>cargo</code>で標準化されています!
<code>cargo</code>でプロジェクトの依存を管理できます。</p>
<p>新しいRustプロジェクトを作る:</p>
<pre><code class="language-sh"># バイナリ
cargo new foo

# ライブラリ
cargo new --lib foo
</code></pre>
<p>この章では、バイナリを作ることを想定しています。しかし、コンセプト
はすべて同じです。</p>
<p>上のコマンドを入力すると、次のようなファイル階層になるでしょう:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p><code>main.rs</code>はソースファイルの根幹です。何も新しいことはありません。
<code>Cargo.toml</code>はこのプロジェクト(<code>foo</code>)用の<code>cargo</code>設定ファイルです。
中身はこのようになっているでしょう:</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
</code></pre>
<p><code>[package]</code>下の<code>name</code>フィールドはプロジェクト名です。これはクレートを
<code>crates.io</code>に公開するときに使われます。(詳しくは後で) これはコンパイルされた
バイナリの名前にもなります。</p>
<p><code>version</code>フィールドは<a href="http://semver.org/">セマンティックバージョニング</a>
をベースとしたバージョン番号です。</p>
<p><code>authors</code>フィールドはクレートを公開するときの開発者のリストです。</p>
<p><code>[dependencies]</code>節にプロジェクトの依存を記述します。</p>
<p>例えば、素晴らしいCLIツールを作りたいときは、<a href="https://crates.io">crates.io</a> (Rust
の公式パッケージレジストリ)にたくさんの素晴らしいクレートがあります。ポピュラーなものでは
<a href="https://crates.io/crates/clap">clap</a>などが良いでしょう。
これを書いている時点で、<code>clap</code>の最新版は<code>2.27.1</code>です。 プログラムに依存を追加するには、
<code>Cargo.toml</code>の<code>[dependencies]</code>節に、<code>clap = &quot;2.27.1&quot;</code>という行を加え、もちろん<code>main.rs</code>に
<code>extern crate clap</code>を加える必要がありますが、それだけで良いです! <code>clap</code>をプログラム内で
使えるようになります。</p>
<p><code>cargo</code>は<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">他のタイプの依存</a>もサポートしています。
こちらが小さなサンプルです。</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
clap = &quot;2.27.1&quot; # crates.ioから
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; } # オンラインリポジトリから
bar = { path = &quot;../bar&quot; } # ローカルファイルシステムから
</code></pre>
<p><code>cargo</code>は依存マネージャ以外の機能も備えています。<code>Cargo.toml</code>のすべての
設定オプションの一覧はは<a href="https://doc.rust-lang.org/cargo/reference/manifest.html">format specification</a>にあります。</p>
<p>プロジェクトを実行ファイルにビルドするには<code>cargo build</code>をプロジェクトディレクトリ内の
いずれかのディレクトリ(サブディレクトリでもOKです!)から実行してください。また、
<code>cargo run</code>でビルド後に実行できます。これらのコマンドは、依存関係を解決し、
必要に応じてクレートをダウンロードし、すべてをビルドします。(<code>make</code>のように、まだビルド
されていないもののみビルドします。)</p>
<p>たったこれだけです!</p>
<h1><a class="header" href="#慣習" id="慣習">慣習</a></h1>
<p>前の節で、このようなディレクトリ階層を見ました。</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>同じプロジェクト内でバイナリを2つ以上作るときはどうするのでしょうか?</p>
<p><code>cargo</code>はこれについてもサポートしています。前に見たように<code>main</code>がデフォルトのバイナリですが、
<code>bin/</code>ディレクトリ内で他のバイナリを作ることができます。</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    ├── main.rs
    └── bin
        └── my_other_bin.rs
</code></pre>
<p>そのバイナリをコンパイル&amp;実行したいときは、<code>cargo</code>にバイナリ名を<code>my_other_bin</code>として
<code>--bin my_other_bin</code>フラグを渡せばよいだけです。</p>
<p>複数のバイナリに加えて、<code>cargo</code>は、ベンチマーク、テスト、サンプルなど<a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">多くの機能</a>
を備えています。</p>
<p>次の節で、テストについて見ていきます。</p>
<h1><a class="header" href="#テスト" id="テスト">テスト</a></h1>
<p>あらゆるソフトにとって、テストは重要です! Rustはテストについての
サポートを提供しています。<em>The Rust Programming Language</em>の(<a href="https://doc.rust-lang.org/book/ch11-00-testing.html">この章
</a>を参照してください。</p>
<p>上のドキュメントでユニットテストと整合性テストの書き方について述べています。
ユニットテストや整合性テストは<code>tests/</code>ディレクトリに入れることになっています。</p>
<pre><code class="language-txt">foo
├── Cargo.toml
├── src
│   └── main.rs
└── tests
    ├── my_test.rs
    └── my_other_test.rs
</code></pre>
<p><code>tests</code>内のそれぞれのファイルが別のテストです。</p>
<p><code>cargo</code>はすべてのテストを自動的に実行する機能を提供しています!</p>
<pre><code class="language-shell">$ cargo test
</code></pre>
<p>このような出力が得られるはずです:</p>
<pre><code class="language-shell">$ cargo test
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 3 tests
test test_bar ... ok
test test_baz ... ok
test test_foo_bar ... ok
test test_foo ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>パターンにマッチするテストのみを実行することもできます:</p>
<pre><code class="language-shell">$ cargo test test_foo
</code></pre>
<pre><code class="language-shell">$ cargo test test_foo
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 2 tests
test test_foo ... ok
test test_foo_bar ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>注意として、Cargoは複数のテストを並列的に実行することがあります。そのため、
すべてのテストがお互いに競合しないようにする必要があります。例えば、それぞれの
テストがファイルに出力する時、違うファイル名に出力する必要があります。</p>
<h1><a class="header" href="#ビルドスクリプト" id="ビルドスクリプト">ビルドスクリプト</a></h1>
<p>時々、デフォルトの<code>cargo</code>のビルドでは不十分な場合があります。おそらくそれは<code>cargo</code>が
コンパイルを成功するのにコード生成、他のファイルのコンパイルなどを事前にしなければ
いけないときでしょう。この問題を解決するために、Cargoではビルドスクリプトが実行できます。</p>
<p><code>Cargo.toml</code>に以下のような行を加えると、ビルドスクリプトが追加できます。</p>
<pre><code class="language-toml">[package]
...
build = &quot;build.rs&quot;
</code></pre>
<p>デフォルトでCargoはプロジェクトディレクトリの<code>build.rs</code>ファイルがあれば、
実行します。</p>
<h2><a class="header" href="#ビルドスクリプトの使い方" id="ビルドスクリプトの使い方">ビルドスクリプトの使い方</a></h2>
<p>ビルドスクリプトは単純にはじめにコンパイルされ、パッケージ内の他のものをコンパイルする
Rustファイルです。これによってクレートの事前要件を満たすことができます。</p>
<p>Cargoは<a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">ここで指定された</a>環境変数を入力として実行されるスクリプトをいくつか提供しています。</p>
<p>また、スクリプトは標準出力を介して出力し、<code>target/debug/build/&lt;pkg&gt;/output</code>にすべての
出力が書き込まれます。さらに、<code>cargo:</code>で始まる行はCargoに解析され、パッケージをコンパイル
するときのひきすうとして使われます。</p>
<p>さらなる仕様やサンプルについては<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">Cargoのドキュメント</a>を参照してください。</p>
<h1><a class="header" href="#属性" id="属性">属性</a></h1>
<p>属性は、モジュール、クレート、またはその要素などに対して適用されるメタデータです。
このメタデータは次のような用途に使われます。</p>
<!-- TODO: Link these to their respective examples -->
<ul>
<li><a href="attribute/cfg.html">条件に合致するときのみコードをコンパイルする</a></li>
<li><a href="attribute/crate.html">クレート名、バージョン、タイプ(バイナリかライブラリ)を指定する</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lint_%28software%29">リント</a>(警告)を無効化する</li>
<li>コンパイラの機能を有効化する(マクロ、グロブ、インポートなど)</li>
<li>外部ライブラリにリンクする</li>
<li>関数をユニットテストとしてマークする</li>
<li>関数をベンチマークとしてマークする</li>
</ul>
<p>クレート全体に属性を適用するときは、<code>#![crate_attribute]</code>構文を使い、
モジュールや要素に対して適用するときは、<code>#[item_attribute]</code>構文を使います
(<code>!</code>を忘れないでください)。</p>
<p>属性はこのような構文で引数を取ることができます:</p>
<ul>
<li><code>#[attribute = &quot;value&quot;]</code></li>
<li><code>#[attribute(key = &quot;value&quot;)]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<p>属性はこのようにして複数の引数を取ることもできます:</p>
<pre><code class="language-rust ignore">#[attribute(value, value2)]


#[attribute(value, value2, value3,
            value4, value5)]
</code></pre>
<h1><a class="header" href="#dead_code" id="dead_code"><code>dead_code</code></a></h1>
<p>コンパイラは使っていない関数に対して警告する
<code>dead_code</code><a href="https://en.wikipedia.org/wiki/Lint_%28software%29"><em>リント</em></a>を提供します。これを無効化
するための<em>属性</em>があります。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn used_function() {}

// `#[allow(dead_code)]`は`dead_code`リントを無効化します
#[allow(dead_code)]
fn unused_function() {}

fn noisy_unused_function() {}
// FIXME ^ 警告を消すために属性を加えてください

fn main() {
    used_function();
}
</code></pre></pre>
<p>実用のプログラムでは使わない関数は取り除いたほうが良いです。しかし、このような
サンプルでは自然なサンプルになるように所々でこの属性を使います。</p>
<h1><a class="header" href="#クレート-1" id="クレート-1">クレート</a></h1>
<p><code>crate_type</code>属性でクレートがバイナリかライブラリか(そしてどのタイプのライブラリか)
を指定し、<code>crate_name</code>属性でクレート名を設定します。</p>
<p>しかし、<code>crate_type</code>や<code>crate_name</code>は、Cargoを使う場合は使わ<strong>ない</strong>方が良いことに
注意してください。これとCargoがメジャーなツールであることから、実用でこれが使われる
ケースは限られています。</p>
<pre><pre class="playpen"><code class="language-rust editable">// このクレートはライブラリです
#![crate_type = &quot;lib&quot;]
// そしてライブラリ名は&quot;rary&quot;です
#![crate_name = &quot;rary&quot;]

pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre></pre>
<p><code>crate_type</code>属性を使えば、<code>--crate-type</code>フラグを<code>rustc</code>に
渡す必要はもはやありません。</p>
<pre><code class="language-shell">$ rustc lib.rs
$ ls lib*
library.rlib
</code></pre>
<h1><a class="header" href="#cfg" id="cfg"><code>cfg</code></a></h1>
<p>条件付きコンパイルは次の2つのオペレータによって行われます。</p>
<ul>
<li><code>cfg</code>属性: 属性としての<code>#[cfg(...)]</code></li>
<li><code>cfg!</code>マクロ: 真偽値式を使ったマクロ<code>cfg!(...)</code></li>
</ul>
<p>後者は実行時にチェックされ、<code>true</code>や<code>false</code>などのリテラルも使えます。
どちらも適切な構文で記述する必要があります。</p>
<pre><pre class="playpen"><code class="language-rust editable">// この関数はターゲットOSがlinuxである場合のみコンパイルされます
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
    println!(&quot;You are running linux!&quot;);
}

// この関数はターゲットOSがlinuxで*ない*場合のみコンパイルされます
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
    println!(&quot;You are *not* running linux!&quot;);
}

fn main() {
    are_you_on_linux();

    println!(&quot;Are you sure?&quot;);
    if cfg!(target_os = &quot;linux&quot;) {
        println!(&quot;Yes. It's definitely linux!&quot;);
    } else {
        println!(&quot;Yes. It's definitely *not* linux!&quot;);
    }
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-30" id="こちらも参照-30">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">参照</a></li>
<li><a href="https://doc.rust-lang.org/std/macro.cfg!.html"><code>cfg!</code></a></li>
<li><a href="attribute/../macros.html">マクロ</a></li>
</ul>
<h1><a class="header" href="#カスタマイズ" id="カスタマイズ">カスタマイズ</a></h1>
<p><code>target_os</code>など、いくつかの条件は<code>rustc</code>によって提供されますが、<code>ructc</code>に
<code>--cfg</code>フラグを追加することで指定できるカスタム条件もあります。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">#[cfg(some_condition)]
fn conditional_function() {
    println!(&quot;condition met!&quot;);
}

fn main() {
    conditional_function();
}
</code></pre></pre>
<p><code>cfg</code>フラグがないとどうなるか試してみてください。</p>
<p><code>cfg</code>フラグを指定すると:</p>
<pre><code class="language-shell">$ rustc --cfg some_condition custom.rs &amp;&amp; ./custom
condition met!
</code></pre>
<h1><a class="header" href="#ジェネリック" id="ジェネリック">ジェネリック</a></h1>
<p><em>ジェネリック</em>は違う型の間で同じ機能を提供するのに使う機構です。
これはコードの重複を減らすのに有用ですが、複雑な構文が必要になります。
ジェネリック型を使うにはきちんと機能するか最新の注意を払わなければ
いけません。そして、型パラメータとしての使い方が最も単純で一般的です。</p>
<p>ジェネリック型の型パラメータはカギ括弧と<a href="https://en.wikipedia.org/wiki/CamelCase">キャメルケース</a>(<code>&lt;Aaa, Bbb, ...&gt;</code>)
が使われます。「ジェネリックな型パラメータ」は普通<code>&lt;T&gt;</code>で表します。Rustでは、
「ジェネリック」には「ジェネリックな型パラメータ<code>&lt;T&gt;</code>を1つ以上受け入れるもの」という
意味もあります。ジェネリックな型パラメータを指定された場合それはジェネリック型になり、
それ以外はすべて具象型(非ジェネリック)として扱われます。</p>
<p>例として、あらゆる型<code>T</code>の引数を受け取る<em>ジェネリック関数</em><code>foo</code>を定義します。</p>
<pre><code class="language-rust ignore">fn foo&lt;T&gt;(arg: T) { ... }
</code></pre>
<p><code>T</code>は<code>&lt;T&gt;</code>によってジェネリックな型パラメータとして指定されているので、<code>(arg: T)</code>のように
ジェネリック型として使うことができます。前に<code>T</code>が構造体として定義されていたとしても、
ジェネリックが優先されます。</p>
<p>次の例で、手を動かしながらジェネリックを学んでいきましょう。</p>
<pre><pre class="playpen"><code class="language-rust editable">// 具象型`A`
struct A;

// `Single`型の宣言では、前に`&lt;A&gt;`がないことと、`A`が具象型として定義されていることから、
// `Single`は具象型になります。
struct Single(A);
//            ^ `Single`内で初めて型`A`が出てくる。

// ここで、ジェネリックな型パラメータ`&lt;T&gt;`が出てくるので、`T`はジェネリック型になり、
// `SingleGen`もジェネリック型になります。`T`どんな型にもなり得るので、上で定義した
// 型`A`も受け取れます。

fn main() {
    // `Single`は具象型で、`A`をとります。
    let _s = Single(A);
    
    // `SingleGen&lt;char&gt;`型の変数`_char`を作り、
    // `SingleGen('a')`で初期化します。
    // ここで、`SingleGen`には明示的に型パラメータが与えられています。
    let _char: SingleGen&lt;char&gt; = SingleGen('a');

    // `SingleGen`型の変数には明示的に型パラメータを与えなくても良い。
    let _t    = SingleGen(A); // Uses `A` defined at the top.
    let _i32  = SingleGen(6); // Uses `i32`.
    let _char = SingleGen('a'); // Uses `char`.
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-31" id="こちらも参照-31">こちらも参照:</a></h3>
<ul>
<li><a href="custom_types/structs.html"><code>structs</code></a></li>
</ul>
<h1><a class="header" href="#関数-1" id="関数-1">関数</a></h1>
<p>同じことが関数でも言えます。つまり、<code>&lt;T&gt;</code>のように指定された型<code>T</code>は
ジェネリックになります。</p>
<p>ジェネリックな関数を使う時は、返り値がジェネリック型であり、それをコンパイラ
が推論できない場合、明示的な型パラメータが必要になります。</p>
<p>このように、明示的な型宣言を使って関数を呼び出すことができます。
<code>fun::&lt;A, B, ...&gt;()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct A;          // 具象型`A`
struct S(A);       // 具象型`S`
struct SGen&lt;T&gt;(T); // ジェネリック型`SGen`

// 以下の関数はすべて変数の所有権をもらい、すぐにスコープを抜けるため、
// 変数を開放します。

// `S`型の引数`_s`を取る関数`reg_fn`を定義する。
// ジェネリックな関数ではないので、`&lt;T&gt;`を使わない。
fn reg_fn(_s: S) {}

// `SGen&lt;A&gt;`型の引数`_s`を取る関数`gen_spec_t`を定義する。
// `A`はジェネリックな型パラメータとして定義されていないため、
// これはジェネリックではない。
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// `SGen&lt;i32&gt;`型の引数`_s`を取る関数`gen_spec_i32`を定義する。
// `i32`はジェネリックではないので、この関数もジェネリックでない。
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// `SGen&lt;T&gt;`型の引数`_s`をとる関数`generic`を定義する。
// `&lt;T&gt;`があるため、`SGen&lt;T&gt;`はジェネリックであり、この関数は`T`に対してジェネリックです。
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // 非ジェネリックな関数を使う
    reg_fn(S(A));          // 具象型
    gen_spec_t(SGen(A));   // 型パラメータ`A`を暗示的に渡す。
    gen_spec_i32(SGen(6)); // 型パラメータ`i32`を暗示的に渡す。

    // 明示的に`char`を`generic()`の型パラメータとして渡す。
    generic::&lt;char&gt;(SGen('a'));

    // 暗示的に`char`が`generic()`の型パラメータとなる。
    generic(SGen('c'));
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-32" id="こちらも参照-32">こちらも参照:</a></h3>
<ul>
<li><a href="generics/../fn.html">functions</a></li>
<li><a href="generics/../custom_types/structs.html"><code>struct</code></a></li>
</ul>
<h1><a class="header" href="#実装" id="実装">実装</a></h1>
<p>関数のように、メソッドの実装に関してもジェネリック型特有の記法が必要です。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct S; // 具象型`S`
struct GenericVal&lt;T&gt;(T); // ジェネリック型`GenericVal`

// GenericValを明示的に型パラメータを指定して実装する。
impl GenericVal&lt;f32&gt; {} // `f32`を指定する
impl GenericVal&lt;S&gt; {} // 上で定義した`S`を指定する

// ジェネリックにするには`&lt;T&gt;`が必要です。
impl&lt;T&gt; GenericVal&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">struct Val {
    val: f64,
}

struct GenVal&lt;T&gt; {
    gen_val: T,
}

// impl of Val
impl Val {
    fn value(&amp;self) -&gt; &amp;f64 {
        &amp;self.val
    }
}

// ジェネリック型`T`に対するGenValの実装
impl&lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T {
        &amp;self.gen_val
    }
}

fn main() {
    let x = Val { val: 3.0 };
    let y = GenVal { gen_val: 3i32 };

    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-33" id="こちらも参照-33">こちらも参照:</a></h3>
<ul>
<li><a href="generics/../scope/lifetime/fn.html">参照を返す関数</a></li>
<li><a href="generics/../fn/methods.html"><code>impl</code></a></li>
<li><a href="generics/../custom_types/structs.html"><code>struct</code></a></li>
</ul>
<h1><a class="header" href="#トレイト" id="トレイト">トレイト</a></h1>
<p>もちろん<code>トレイト</code>もジェネリックにできます。自分自身を入力とした
ジェネリックなメソッド<code>drop</code>をもつ<code>Drop</code>トレイトをジェネリックで
再実装します。</p>
<pre><pre class="playpen"><code class="language-rust editable">// コピーできない型
struct Empty;
struct Null;

// `T`に対してジェネリックなトレイト
trait DoubleDrop&lt;T&gt; {
    // 呼び出し元と`T`型の引数をとり、何もしないメソッド。
    fn double_drop(self, _: T);
}

// `DoubleDrop&lt;T&gt;`をジェネリックな引数`T`と
// 呼び出し元`U`に対して実装する。
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // このメソッドは両方の所有権をとり、
    // 両方開放する。
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // `empty`と`null`を開放する。
    empty.double_drop(null);

    //empty;
    //null;
    // ^ TODO: これらの行をアンコメントしてみてください
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-34" id="こちらも参照-34">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a></li>
<li><a href="generics/../custom_types/structs.html"><code>struct</code></a></li>
<li><a href="generics/../trait.html"><code>trait</code></a></li>
</ul>
<h1><a class="header" href="#境界" id="境界">境界</a></h1>
<p>ジェネリックを使っていると、型パラメータが特定の機能を持っていることを規定するために、
トレイトを<em>境界</em>として使うことがあります。例えば、次の例は変数をプリントするため、
型<code>T</code>が<code>Display</code>トレイトを実装していることを規定しています。つまり、<code>T</code>は<code>Display</code>
を実装していなければならないのです。</p>
<pre><code class="language-rust ignore">// `Display`トレイトを実装している型`T`に対してジェネリックな
// 関数`printer`を定義する。
fn printer&lt;T: Display&gt;(t: T) {
    println!(&quot;{}&quot;, t);
}
</code></pre>
<p>境界はジェネリックをすべての型ではなく、あるトレイトを実装している
型だけに対して適用するためにあります。つまり</p>
<pre><code class="language-rust ignore">struct S&lt;T: Display&gt;(T);

// エラー! `Vec&lt;T&gt;`は`Display`を実装していません。
// この特殊化は失敗します。
let s = S(vec![1]);
</code></pre>
<p>境界のもう一つの効果は、境界となるトレイトに実装されているメソッドを使用できることです。
例えば</p>
<pre><pre class="playpen"><code class="language-rust editable">// プリントマーカー`{:?}`を実装するトレイト
use std::fmt::Debug;

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Rectangle {
    fn area(&amp;self) -&gt; f64 { self.length * self.height }
}

#[derive(Debug)]
struct Rectangle { length: f64, height: f64 }
#[allow(dead_code)]
struct Triangle  { length: f64, height: f64 }

// ジェネリック型`T`は`Debug`を実装している必要があります。型に関係なく、
// これは動作します。
fn print_debug&lt;T: Debug&gt;(t: &amp;T) {
    println!(&quot;{:?}&quot;, t);
}

// `T`は`HasArea`を実装している必要があります。`HasArea`のメソッド`area`
// を使用するための境界です。
fn area&lt;T: HasArea&gt;(t: &amp;T) -&gt; f64 { t.area() }

fn main() {
    let rectangle = Rectangle { length: 3.0, height: 4.0 };
    let _triangle = Triangle  { length: 3.0, height: 4.0 };

    print_debug(&amp;rectangle);
    println!(&quot;Area: {}&quot;, area(&amp;rectangle));

    //print_debug(&amp;_triangle);
    //println!(&quot;Area: {}&quot;, area(&amp;_triangle));
    // ^ TODO: これらをアンコメントしてみてください。
    // | エラー: `Debug`または`HasArea`を実装していません。
}
</code></pre></pre>
<p>さらに、読みやすくするため、場合によっては<a href="generics/../generics/where.html"><code>where</code></a>節も
境界を適用するのに使われます。</p>
<h3><a class="header" href="#こちらも参照-35" id="こちらも参照-35">こちらも参照:</a></h3>
<ul>
<li><a href="generics/../hello/print.html"><code>std::fmt</code></a></li>
<li><a href="generics/../custom_types/structs.html"><code>struct</code>s</a></li>
<li><a href="generics/../trait.html"><code>trait</code>s</a></li>
</ul>
<h1><a class="header" href="#テストケース-空の境界" id="テストケース-空の境界">テストケース: 空の境界</a></h1>
<p><code>トレイト</code>がもし何も機能を含んでいなくても、境界として使うことができます。
<code>Eq</code>や<code>Copy</code>は<code>std</code>ライブラリ内でのそのようなトレイトの例です。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// 以下の関数はトレイト境界を設けているが、そのトレイトが空かどうか
// は関係ありません。
fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { &quot;red&quot; }
fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { &quot;blue&quot; }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;

    // 境界があるため、`red()`は`blue jay`に対して実行できない。
    println!(&quot;A cardinal is {}&quot;, red(&amp;cardinal));
    println!(&quot;A blue jay is {}&quot;, blue(&amp;blue_jay));
    //println!(&quot;A turkey is {}&quot;, red(&amp;_turkey));
    // ^ TODO: この行をアンコメントしてみてください
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-36" id="こちらも参照-36">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>std::cmp::Eq</code></a></li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>std::marker::Copy</code></a></li>
<li><a href="generics/bounds/../../trait.html"><code>trait</code></a></li>
</ul>
<h1><a class="header" href="#複数の境界" id="複数の境界">複数の境界</a></h1>
<p><code>+</code>で複数の境界が適用できます。複数の引数を受け取るときは、
通常通り<code>,</code>で分割します。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::{Debug, Display};

fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T) {
    println!(&quot;Debug: `{:?}`&quot;, t);
    println!(&quot;Display: `{}`&quot;, t);
}

fn compare_types&lt;T: Debug, U: Debug&gt;(t: &amp;T, u: &amp;U) {
    println!(&quot;t: `{:?}`&quot;, t);
    println!(&quot;u: `{:?}`&quot;, u);
}

fn main() {
    let string = &quot;words&quot;;
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&amp;string);
    //compare_prints(&amp;array);
    // TODO ^ この行をアンコメントしてみてください

    compare_types(&amp;array, &amp;vec);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-37" id="こちらも参照-37">こちらも参照:</a></h3>
<ul>
<li><a href="generics/../hello/print.html"><code>std::fmt</code></a></li>
<li><a href="generics/../trait.html"><code>trait</code></a></li>
</ul>
<h1><a class="header" href="#where節" id="where節">Where節</a></h1>
<p>境界は<code>where</code>節を<code>{</code>の直前に置くことでも表現できます。
さらに、<code>where</code>節は境界を型パラメータだけでなく、任意の型に
適用することもできます。</p>
<p>場合によっては<code>where</code>節は有用です。</p>
<ul>
<li>ジェネリック型の指定と境界の指定を明確に分けたい時</li>
</ul>
<pre><code class="language-rust ignore">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// `where`節で境界を表現する
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
</code></pre>
<ul>
<li><code>where</code>節の方が通常の構文より表現力が高いときがあります。
この例の<code>impl</code>は<code>where</code>節を使わないと表現できません。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// この例は他に`T: Debug`を使うか他の直接的でない方法を使うしかありません。
// これには`where`節が必要です。
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // プリントされるものが`Option&lt;T&gt;`型なので、`Option&lt;T&gt;: Debug`に
    // 境界を設定したい。他の方法では間違った境界しか設定できない。
    fn print_in_option(self) {
        println!(&quot;{:?}&quot;, Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-38" id="こちらも参照-38">こちらも参照:</a></h3>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">RFC</a></li>
<li><a href="generics/../custom_types/structs.html"><code>struct</code></a></li>
<li><a href="generics/../trait.html"><code>trait</code></a></li>
</ul>
<h1><a class="header" href="#new-typeイディオム" id="new-typeイディオム">New Typeイディオム</a></h1>
<p><code>newtype</code>イディオムは正しい型の値が供給されることをコンパイル時に保証します。</p>
<p>例えば、年齢確認プログラムでは、<code>Years</code>型の値が関数に渡される必要があります。</p>
<blockquote>
<p>訳注: わかりにくかったので補足すると、年を表す数値も日数を表す数値も<code>i64</code>
ですが、だからといって年齢確認用の関数に日数を渡されても困ります。なので、
新しい型を作って数値の意味を明示する、ということです。</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust editable">struct Years(i64);

struct Days(i64);

impl Years {
    pub fn to_days(&amp;self) -&gt; Days {
        Days(self.0 * 365)
    }
}


impl Days {
    /// 部分的な年を切り捨てます
    pub fn to_years(&amp;self) -&gt; Years {
        Years(self.0 / 365)
    }
}

fn old_enough(age: &amp;Years) -&gt; bool {
    age.0 &gt;= 18
}

fn main() {
    let age = Years(5);
    let age_days = age.to_days();
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age));
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days.to_years()));
    // println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days));
}
</code></pre></pre>
<p>最後のprint文をアンコメントしても、コンパイルが通りません。</p>
<p>基本型の値を<code>newtype</code>として作ると、このようにタプルのような構文で値が参照できます。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Years(i64);

fn main() {
    let years = Years(42);
    let years_as_primitive: i64 = years.0;
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-39" id="こちらも参照-39">こちらも参照:</a></h3>
<ul>
<li><a href="generics/../custom_types/structs.html"><code>structs</code></a></li>
</ul>
<h1><a class="header" href="#関連要素" id="関連要素">関連要素</a></h1>
<p>「関連要素」とはある規則に従った様々な型の<a href="https://doc.rust-lang.org/reference/items.html">要素</a>の集合のことです。
これは<code>トレイト</code>の拡張であり、トレイト内で要素を定義できます。</p>
<p>そのような要素の一つに<em>関連型</em>があります。これにより、<code>トレイト</code>でジェネリックな
コンテナ型を扱うときに、よりシンプルな書き方ができます。</p>
<h3><a class="header" href="#こちらも参照-40" id="こちらも参照-40">こちらも参照:</a></h3>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md">RFC</a></li>
</ul>
<h1><a class="header" href="#問題" id="問題">問題</a></h1>
<p>コンテナ型に、その要素に対してジェネリックなトレイトを実装した時、そのトレイトを
使用する人は、すべてのジェネリック型を明記する必要があります。</p>
<p>以下の例では、<code>Contains</code>トレイトはジェネリック型AとBの使用を許可しています。
このトレイトは、その後<code>Container</code>型に対して実装されていますが、その際、後で
<code>fn difference()</code>が使用できるように、<code>A</code>と<code>B</code>が<code>i32</code>であると明記しています。</p>
<p><code>Contains</code>はジェネリックであるため、明示的に<em>すべて</em>のジェネリック型を<code>fn difference()</code>
にする必要があります。しかし、<code>C</code>によって<code>A</code>と<code>B</code>は決定できるはずです。次の節で紹介する
関連型で、この冗長さを解消できます。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Container(i32, i32);

// 2つの要素がコンテナの中にあることをチェックするトレイト
// 最初と最後の値を取得することもできる。
trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool; // 明示的に`A`と`B`が必要。
    fn first(&amp;self) -&gt; i32; // `A`と`B`は不要。
    fn last(&amp;self) -&gt; i32;  // `A`と`B`は不要。
}

impl Contains&lt;i32, i32&gt; for Container {
    // 保存されている値が等しければtrueを返す
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // 最初の値を返す。
    fn first(&amp;self) -&gt; i32 { self.0 }

    // 最後の値を返す。
    fn last(&amp;self) -&gt; i32 { self.1 }
}

// `C`は`A`を`B`含んでいるため、`A`と`B`の記述は冗長。
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());

    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-41" id="こちらも参照-41">こちらも参照:</a></h3>
<ul>
<li><a href="generics/assoc_items/../../custom_types/structs.html"><code>struct</code></a></li>
<li><a href="generics/assoc_items/../../trait.html"><code>trait</code>s</a></li>
</ul>
<h1><a class="header" href="#関連型" id="関連型">関連型</a></h1>
<p>「関連型」を使えば、コンテナ型の中の要素を<em>出力型</em>として書くことができるため、
可読性が上げられます。トレイトを定義する構文は以下の通りです。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// `A`と`B`はトレイト内で`type`キーワードを使って定義できる。
// (注意: この文脈での`type`は型エイリアスを作る`type`とは別物です。)
trait Contains {
    type A;
    type B;

    // これらの型をジェネリックに使うため、構文を変える。
    fn contains(&amp;self, &amp;Self::A, &amp;Self::B) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Contains</code>トレイトを使用する時に、<code>A</code>と<code>B</code>を明示することは
もはや必要ありません。</p>
<pre><code class="language-rust ignore">// 関連型を使わない時
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; { ... }

// 関連型を使った時
fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }
</code></pre>
<p>前の節の例を関連型を使って書き直しましょう。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Container(i32, i32);

// コンテナが2つの要素を持つことをチェックするトレイト
// 最初と最後の要素も取得できます。
trait Contains {
    // メソッドで使われるジェネリック型を定義する
    type A;
    type B;

    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains for Container {
    // `A`と`B`の型を定義します。もし入力型が`Container(i32, i32)`なら、
    // 出力型は`i32`と`i32`になります。
    type A = i32;
    type B = i32;

    // `&amp;Self::A`と`&amp;Self::B`も利用可能です。
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }
    // 最初の値を取得する
    fn first(&amp;self) -&gt; i32 { self.0 }

    // 最後の値を取得する
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());
    
    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h1><a class="header" href="#幽霊型パラメータ" id="幽霊型パラメータ">幽霊型パラメータ</a></h1>
<p>幽霊型は実行時には存在しませんが、コンパイル時に静的に
型チェックをするような型です。</p>
<p>データ型はマーカーとして余分なジェネリック型パラメータを持ち、それを使って
コンパイル時に型チェックすることができます。このパラメータはストレージの
余分なスペースを消費せず、実行時の動作にも影響しません。</p>
<p>以下の例では、幽霊型(<a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">std::marker::PhantomData</a>)というマーカーを使って
それぞれ異なった型の値を持つタプルを作成します。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::marker::PhantomData;

// ジェネリックな幽霊型タプル構造体。`A`と幽霊型`B`からなる。
#[derive(PartialEq)] // この型で`==`での比較を可能にする。
struct PhantomTuple&lt;A, B&gt;(A,PhantomData&lt;B&gt;);

// 同様に構造体を定義
#[derive(PartialEq)] // Allow equality test for this type.
struct PhantomStruct&lt;A, B&gt; { first: A, phantom: PhantomData&lt;B&gt; }

// 注意: ストレージはジェネリック型`A`のために確保されますが、`B`に対してはされません。
//       なので、`B`を処理に使うことはできません。

fn main() {
    // ここでは、`f32`と`f64`は幽霊型パラメータです。
    // PhantomTupleを`&lt;char, f32&gt;`で定義する。
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);
    // PhantomTupleを`&lt;char, f64&gt;`で定義する。
    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    // `&lt;char, f32&gt;`で定義する
    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    // `&lt;char, f64&gt;`で定義する。
    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    
    // コンパイルエラー! 型が違うため比較できません
    //println!(&quot;_tuple1 == _tuple2 yields: {}&quot;,
    //          _tuple1 == _tuple2);
    
    // コンパイルエラー! 型が違うため比較できません
    //println!(&quot;_struct1 == _struct2 yields: {}&quot;,
    //          _struct1 == _struct2);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-42" id="こちらも参照-42">こちらも参照:</a></h3>
<ul>
<li><a href="generics/../trait/derive.html">継承</a></li>
<li><a href="generics/../custom_types/structs.html">構造体</a></li>
<li><a href="generics/../custom_types/structs.html">タプル構造体</a></li>
</ul>
<h1><a class="header" href="#テストケース-単位の明確化" id="テストケース-単位の明確化">テストケース: 単位の明確化</a></h1>
<p>共通の単位同士を扱う際のチェックのために、<code>Add</code>を幽霊型を用いた実装に
すると便利です。その場合<code>Add</code>トレイトは以下のようになります。</p>
<pre><code class="language-rust ignore">// このように定義しておくと、`Self + RHS(右辺値) = Output`であることが保証され、
// 実装時にRHSを省略すると、デフォルトでSelfと同じになります。
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}

// `T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`であるため、`Output`は`T&lt;U&gt;`である必要があります。
impl&lt;U&gt; Add for T&lt;U&gt; {
    type Output = T&lt;U&gt;;
    ...
}
</code></pre>
<p>以下は全体を示した例です。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops::Add;
use std::marker::PhantomData;

/// ユニット型を定義する。
#[derive(Debug, Clone, Copy)]
enum Inch {}
#[derive(Debug, Clone, Copy)]
enum Mm {}

/// `Length`は`Unit`型の幽霊型パラメータを持つ型
/// そして長さの型はジェネリックではありません(`f64`です)。
///
/// `f64`ははじめから`Clone`と`Copy`トレイトを実装しています。
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);

/// `Add`トレイトで`+`演算子の振る舞いを定義します。
impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
     type Output = Length&lt;Unit&gt;;

    // add()は合計値を含む新しい`Length`構造体を返します。
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // `+`は`f64`に対する`Add`の実装を呼び出します。
        Length(self.0 + rhs.0, PhantomData)
    }
}

fn main() {
    // `one_foot`は幽霊型パラメータ`Inch`を持つ
    let one_foot:  Length&lt;Inch&gt; = Length(12.0, PhantomData);
    // `one_meter`は幽霊型パラメータ`Mm`を持つ
    let one_meter: Length&lt;Mm&gt;   = Length(1000.0, PhantomData);

    // `+`は`Length&lt;Unit&gt;`の`add()`メソッドを呼び出します。
    //
    // `Length`は`Copy`を実装しているので、`add()`は
    // `one_foot`や`one_meter`を消費せず、コピーします。
    let two_feet = one_foot + one_foot;
    let two_meters = one_meter + one_meter;

    // 問題なく実行されていることの確認
    println!(&quot;one foot + one_foot = {:?} in&quot;, two_feet.0);
    println!(&quot;one meter + one_meter = {:?} mm&quot;, two_meters.0);

    // 違う単位間では計算できない。
    // コンパイルエラー: 型が違います。
    //let one_feter = one_foot + one_meter;
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-43" id="こちらも参照-43">こちらも参照:</a></h3>
<ul>
<li><a href="generics/phantom/../../scope/borrow.html">借用(<code>&amp;</code>)</a></li>
<li><a href="generics/phantom/../../generics/bounds.html">境界(<code>X:Y</code>)</a></li>
<li><a href="generics/phantom/../../custom_types/enum.html">enum</a></li>
<li><a href="generics/phantom/../../fn/methods.html">implとself</a></li>
<li><a href="generics/phantom/../../trait/ops.html">オーバーロード</a></li>
<li><a href="generics/phantom/../../scope/borrow/ref.html">参照</a></li>
<li><a href="generics/phantom/../../trait.html">トレイト(<code>X for Y</code>)</a></li>
<li><a href="generics/phantom/../../custom_types/structs.html">タプル構造体</a></li>
</ul>
<h1><a class="header" href="#スコープのルール" id="スコープのルール">スコープのルール</a></h1>
<p>スコープは所有権や借用、ライフタイムを考える上で重要な概念です。
スコープで、いつ参照が有効になり、いつリソースが開放され、
そしていつ変数が作られ、破棄されるかを示すことができます。</p>
<h1><a class="header" href="#raii" id="raii">RAII</a></h1>
<p>Rustの変数はスタック上のデータを保持するだけでなく、リソースを<em>所有</em>します。
例えば、<code>Box&lt;T&gt;</code>はヒープ上のメモリを所有します。Rustは<a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>(Resource
Acquisition Is Initialization、リソースの取得は初期化である)に従っているため、
オブジェクトがスコープを出ると、デストラクタが呼び出され、所有していたリソースが
開放されます。</p>
<p>この振る舞いによって、手動でメモリを開放しなくて良いため、<em>リソースリーク</em>が防げます。
もうメモリリークを気にする必要はないのです! 以下に例があります。</p>
<pre><pre class="playpen"><code class="language-rust editable">// raii.rs
fn create_box() {
    // ヒープに整数を格納する
    let _box1 = Box::new(3i32);

    // `_box1`は破棄され、メモリが開放されます。
}

fn main() {
    // ヒープに整数を格納する
    let _box2 = Box::new(5i32);

    // ネストされたスコープ
    {
        // ヒープに整数を格納する
        let _box3 = Box::new(4i32);

        // `_box3`は破棄され、メモリが開放されます
    }

    // 遊びでたくさんメモリを確保してみる
    // 手動でメモリを開放する必要はありません!
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2`が破棄され、メモリが開放されます
}
</code></pre></pre>
<p>もちろん、<a href="http://valgrind.org/info/"><code>valgrind</code></a>でメモリエラーを確認します。</p>
<pre><code class="language-shell">$ rustc raii.rs &amp;&amp; valgrind ./raii
==26873== Memcheck, a memory error detector
==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==26873== Command: ./raii
==26873==
==26873==
==26873== HEAP SUMMARY:
==26873==     in use at exit: 0 bytes in 0 blocks
==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated
==26873==
==26873== All heap blocks were freed -- no leaks are possible
==26873==
==26873== For counts of detected and suppressed errors, rerun with: -v
==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</code></pre>
<p>ひとつもリークしていません!</p>
<h2><a class="header" href="#デストラクタ" id="デストラクタ">デストラクタ</a></h2>
<p>Rustのデストラクタは<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>トレイトによって実装されています。デストラクタは
リソースがスコープを抜けた時に呼び出されます。このトレイトは、すべての型に実装
する必要はなく、デストラクタに独自のロジックを実装する必要がある場合のみ実装
します。</p>
<p>どのように<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>トレイトが動くかを見てみるため、下の例を実行してください。
<code>main</code>関数内の変数がスコープを抜けた時、独自のデストラクタが呼び出されます。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct ToDrop;

impl Drop for ToDrop {
    fn drop(&amp;mut self) {
        println!(&quot;ToDrop is being dropped&quot;);
    }
}

fn main() {
    let x = ToDrop;
    println!(&quot;Made a ToDrop!&quot;);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-44" id="こちらも参照-44">こちらも参照:</a></h3>
<ul>
<li><a href="scope/../std/box.html">Box</a></li>
</ul>
<h1><a class="header" href="#所有権とムーブ" id="所有権とムーブ">所有権とムーブ</a></h1>
<p>変数は所有するリソースを開放する必要があるため、 <strong>リソースは一つの所有者
しか持ちません</strong>。リソースを2度以上開放しないためでもあります。すべての変数
がリソースを持つわけではないことに注意してください(例えば<a href="scope/../flow_control/match/destructuring/destructure_pointers.html">参照</a>)。</p>
<p>変数に値を代入(<code>let x = y</code>)したときや、関数に値を渡した(<code>foo(x)</code>)とき、
リソースの<em>所有権</em>が渡されます。これをRustでは、<em>ムーブ</em>と呼んでいます。</p>
<p>リソースをムーブしたら、元の所有者はもうそのリソースを使うことができません。
これによって、危険なポインタを作成するのを防ぎます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// ヒープに確保したメモリの所有権を必要とする関数
fn destroy_box(c: Box&lt;i32&gt;) {
    println!(&quot;Destroying a box that contains {}&quot;, c);

    // `c`は破棄され、メモリが開放される
}

fn main() {
    // _スタック_に整数を確保する
    let x = 5u32;

    // `x`を`y`に*コピー*する。所有権はムーブされない
    let y = x;

    // どちらの値も独立して使える
    println!(&quot;x is {}, and y is {}&quot;, x, y);

    // `a`は_ヒープ_に確保した整数のポインタ
    let a = Box::new(5i32);

    println!(&quot;a contains: {}&quot;, a);

    // `a`を`b`に*ムーブ*する
    let b = a;
    // `a`のポインタアドレスは`b`にコピーされる。
    // どちらも同じヒープのポインタをもつが、現在
    // `b`が所有している。
    
    // エラー! `a`はヒープメモリのデータを所有していないため、
    // データを使用できない。
    //println!(&quot;a contains: {}&quot;, a);
    // TODO ^ この行をアンコメントしてみてください

    // `b`が持っているメモリの所有権を取る関数
    destroy_box(b);

    // ここでヒープメモリは開放されたので、開放されたメモリのポインタを
    // 使うことになるが、これはコンパイラによって禁止されている。
    // エラー! 前のエラーと同じ理由
    //println!(&quot;b contains: {}&quot;, b);
    // TODO ^ この行をアンコメントしてみてください
}
</code></pre></pre>
<h1><a class="header" href="#可変性-1" id="可変性-1">可変性</a></h1>
<p>所有権がムーブしたときに、データの可変性も変更できる。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let immutable_box = Box::new(5u32);

    println!(&quot;immutable_box contains {}&quot;, immutable_box);

    // 可変性のエラー
    //*immutable_box = 4;

    // 所有権(と可変性)を変更してBoxを*ムーブ*する。
    let mut mutable_box = immutable_box;

    println!(&quot;mutable_box contains {}&quot;, mutable_box);

    // Boxの要素を変更する
    *mutable_box = 4;

    println!(&quot;mutable_box now contains {}&quot;, mutable_box);
}
</code></pre></pre>
<h1><a class="header" href="#借用" id="借用">借用</a></h1>
<p>ほとんどの場合、データの所有権を取らずにデータにアクセスしたいです。このために、
Rustは<em>借用</em>のメカニズムを使用しています。オブジェクトを値(<code>T</code>)で渡す代わりに、
参照(<code>&amp;T</code>)で渡すことができます。</p>
<p>コンパイラは参照が<em>常に</em>有効なオブジェクトのポインタであることを(ボローチェッカー
によって)保証します。つまり、オブジェクトの参照が存在する限り、そのオブジェクトは
破棄されません。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">//  Boxの所有権をとって、破棄する関数
fn eat_box_i32(boxed_i32: Box&lt;i32&gt;) {
    println!(&quot;Destroying box that contains {}&quot;, boxed_i32);
}

// i32を借用する関数
fn borrow_i32(borrowed_i32: &amp;i32) {
    println!(&quot;This int is: {}&quot;, borrowed_i32);
}

fn main() {
    // ヒープ上のi32とスタック上のi32を作る
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // Boxの要素を借用する。所有権が取られないため、
    // もう1度借用できる。
    borrow_i32(&amp;boxed_i32);
    borrow_i32(&amp;stacked_i32);

    {
        // Box上のデータの参照を作る
        let _ref_to_i32: &amp;i32 = &amp;boxed_i32;

        // エラー!
        // `boxed_i32`は後に借用されるため、破棄できません。
        eat_box_i32(boxed_i32);
        // FIXME ^ この行をコメントアウトしてください

        // 中の値が破棄された後に`_ref_to_i32`を使用しようとする
        borrow_i32(_ref_to_i32);
        // `_ref_to_i32`がスコープを出たため、もう借用されることはない
    }

    // 今は`boxed_i32`は`eat_box`に所有権を与えて破棄することができる。
    eat_box_i32(boxed_i32);
}
</code></pre></pre>
<h1><a class="header" href="#可変性-2" id="可変性-2">可変性</a></h1>
<p>可変なデータは<code>&amp;mut T</code>で可変的に借用することができます。これ
<em>可変参照</em>と呼ばれ、借用した人に読み書きを許可します。
<code>&amp;T</code>は不変なデータの参照をとり、借用した人はデータの読み取りは
できても、変更はできません。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&amp;'static str`は読み取り専用メモリに確保した文字列の参照
    author: &amp;'static str,
    title: &amp;'static str,
    year: u32,
}

// この関数はbookの参照をとる
fn borrow_book(book: &amp;Book) {
    println!(&quot;I immutably borrowed {} - {} edition&quot;, book.title, book.year);
}

// この関数はbookのか変参照をとり、`year`を2014に変更する
fn new_edition(book: &amp;mut Book) {
    book.year = 2014;
    println!(&quot;I mutably borrowed {} - {} edition&quot;, book.title, book.year);
}

fn main() {
    // 不変なBook、`immutabook`を作る
    let immutabook = Book {
        // `&amp;'static str`に格納される
        author: &quot;Douglas Hofstadter&quot;,
        title: &quot;Gödel, Escher, Bach&quot;,
        year: 1979,
    };

    // `immutabook`の可変なコピー、`mutabook`を作る
    let mut mutabook = immutabook;
    
    // 不変なオブジェクトを不変的に借用する
    borrow_book(&amp;immutabook);

    // 可変なオブジェクトを不変的に借用する
    borrow_book(&amp;mutabook);
    
    // 可変なオブジェクトを可変的に借用する
    new_edition(&amp;mut mutabook);
    
    // エラー! 不変なオブジェクトは可変参照できません
    new_edition(&amp;mut immutabook);
    // FIXME ^ この行をコメントアウトする
}
</code></pre></pre>
<h3><a class="header" href="#see-also" id="see-also">See also:</a></h3>
<p><a href="scope/borrow/../lifetime/static_lifetime.html"><code>static</code></a></p>
<h1><a class="header" href="#エイリアシング-1" id="エイリアシング-1">エイリアシング</a></h1>
<p>データは何度でも不変借用できますが、不変借用されている間はもとのデータは可変借用
できません。言い換えれば、同時に<em>一つ</em>の可変参照ができ、もとのデータは可変参照が
最後に使われた<em>後</em>でのみ借用できるということです。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Point { x: i32, y: i32, z: i32 }

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    let borrowed_point = &amp;point;
    let another_borrow = &amp;point;

    // データには参照または所有者のみアクセスできます。
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                borrowed_point.x, another_borrow.y, point.z);

    // エラー! 現在不変参照されているため、`point`を可変参照
    // することはできません。
    // let mutable_borrow = &amp;mut point;
    // TODO ^ この行をアンコメントしてみてください

    // 借用された値はもう一度使用できます。
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                borrowed_point.x, another_borrow.y, point.z);

    // もう不変参照は使われないため、残りのコードでは
    // 可変参照として再び借用できます。
    let mutable_borrow = &amp;mut point;

    // 可変参照でデータを変更する
    mutable_borrow.x = 5;
    mutable_borrow.y = 2;
    mutable_borrow.z = 1;

    // エラー! `point`は現在可変借用されているため、不変借用はできません。
    // let y = &amp;point.y;
    // TODO ^ この行をアンコメントしてみてください

    // エラー! `println!`は不変参照を必要とするため、呼び出せません。
    // println!(&quot;Point Z coordinate is {}&quot;, point.z);
    // TODO ^ この行をアンコメントしてみてください

    // Ok! 可変参照は不変参照として`println!`に渡せます
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);

    // 可変参照はもう使われないので、残りのコードでは再度借用できます。
    let new_borrowed_point = &amp;point;
    println!(&quot;Point now has coordinates: ({}, {}, {})&quot;,
             new_borrowed_point.x, new_borrowed_point.y, new_borrowed_point.z);
}
</code></pre></pre>
<h1><a class="header" href="#refパターン" id="refパターン">refパターン</a></h1>
<p>パターンマッチングや<code>let</code>束縛による分割代入をするとき、構造体やタプルのフィールド
の参照をとるのに<code>ref</code>キーワードが使用できます。下の例では、有用な使い方をいくつか
載せています。</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // `ref`を使って左辺で借用を表している。
    // 右辺で`&amp;`を使って借用するのと等価
    let ref ref_c1 = c;
    let ref_c2 = &amp;c;

    println!(&quot;ref_c1 equals ref_c2: {}&quot;, *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // `ref`は構造体の分割代入にも使える。
    let _copy_of_x = {
        // `ref_to_x`は`point`のフィールド`x`の参照
        let Point { x: ref ref_to_x, y: _ } = point;

        // `point`の`x`フィールドのコピーを返す
        *ref_to_x
    };

    // `point`の可変コピー
    let mut mutable_point = point;

    {
        // `ref`と`mut`を一緒に使うと可変参照が取れる。
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // `mutable_point`の`y`フィールドを可変参照から変更する。
        *mut_ref_to_y = 1;
    }

    println!(&quot;point is ({}, {})&quot;, point.x, point.y);
    println!(&quot;mutable_point is ({}, {})&quot;, mutable_point.x, mutable_point.y);

    // ポインタを含む可変なタプル
    let mut mutable_tuple = (Box::new(5u32), 3u32);
    
    {
        // `mutable_tuple`を分割代入し、`last`の値を変更する。
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }
    
    println!(&quot;tuple is {:?}&quot;, mutable_tuple);
}
</code></pre></pre>
<h1><a class="header" href="#ライフタイム" id="ライフタイム">ライフタイム</a></h1>
<p><em>ライフタイム</em>はコンパイラ(具体的には<em>ボローチェッカー</em>)が、すべての借用に
問題がないことを確認するために使う仕組みです。具体的には、変数のライフタイムは
作られたときに始まり、破棄されたときに終わります。ライフタイムとスコープはしばしば
同じ扱いをされますが、同じではありません。</p>
<p>例えば、変数を<code>&amp;</code>で借用した場合を考えます。この借用はライフタイムを持ち、
宣言されたときに始まり、貸し手が破棄されるまで続きます。しかし、借用のスコープ
は参照が使われるときに決まります。</p>
<p>以下の例や残りの節で、ライフタイムはスコープとどのように関係し、
どのように異なるのかを見ていきます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// 以下では、各変数に対するライフタイムを線で表します
// `i`は`borrow1`と`borrow2`のスコープを完全に含むため、
// 一番長いです。`borrow1`と`borrow2`のライフタイムは
// 重なりません。
fn main() {
    let i = 3; // `i`のライフタイムが始まる。─────────────────────┐
    //                                                            │
    { //                                                          │
        let borrow1 = &amp;i; // `borrow1`のライフタイムが始まる。───┐│
        //                                                       ││
        println!(&quot;borrow1: {}&quot;, borrow1); //                     ││
    } // `borrow1が終わる。──────────────────────────────────────┘│
    //                                                            │
    //                                                            │
    { //                                                          │
        let borrow2 = &amp;i; // `borrow2`のライフタイムが始まる。───┐│
        //                                                       ││
        println!(&quot;borrow2: {}&quot;, borrow2); //                     ││
    } // `borrow2`が終わる。─────────────────────────────────────┘│
    //                                                            │
}   // ライフタイムが終わる。─────────────────────────────────────┘
</code></pre></pre>
<p>ライフタイムのラベルにはいかなる名前、型も代入できないことに注意してください。
この制限によって、ライフタイムはうまく使えるようになります。</p>
<h1><a class="header" href="#明示的アノテーション" id="明示的アノテーション">明示的アノテーション</a></h1>
<p>ボローチェッカーは参照がどれだけの間有効か示すのに、ライフタイムの明示的
アノテーションを使用します。ライフタイムが省略<sup class="footnote-reference"><a href="#1">1</a></sup>されない場合、Rustでは
参照のライフタイムがどのようなものかを明示的に示すことが必要です。明示的
アノテーションは、以下のようにアポストロフィの後に文字を置くことで表せます。</p>
<pre><code class="language-rust ignore">foo&lt;'a&gt;
// `foo`はライフタイムパラメータ`'a`を持っています。
</code></pre>
<p><a href="scope/lifetime/../../fn/closures/anonymity.html">closures</a>のように、ライフタイムを使うにはジェネリクスが必要です。
更に、<code>foo</code>のライフタイムは<code>'a</code>を超えることはないということを表しています。
型を明示した場合は<code>'a</code>は<code>&amp;'a T</code>となります。</p>
<p>複数のライフタイムを持つ時、構文は以下のようになります。</p>
<pre><code class="language-rust ignore">foo&lt;'a, 'b&gt;
// `foo`はライフタイムパラメータ`'a`と`'b`を持っています。
</code></pre>
<p>この時、<code>foo</code>のライフタイムは<code>'a</code>も<code>'b</code>も超えることはないということを表しています。</p>
<p>以下の例で明示的アノテーションの使い方を見てください。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// `print_refs`は少なくとも`print_refs`のライフタイムより長い2つ
// の異なったライフタイムを持つ2つの`i32`の参照をとります。
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;x is {} and y is {}&quot;, x, y);
}

// 引数は取らないが、ライフタイムパラメータ`'a`を持つ関数。
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // エラー: `_x`のライフタイムが短いです。
    //let y: &amp;'a i32 = &amp;_x;
    // `'a`を関数内で明示的アノテーションとして使うことを試みましたが、`&amp;_x`の
    // ライフタイムは`y`より短くいため、できません。短いライフタイムを長い
    // ライフタイムを持つものに強制させることはできない。
}

fn main() {
    // 下で使う変数を作る。
    let (four, nine) = (4, 9);
    
    // 両方の変数の借用(`&amp;`)が関数に渡される。
    print_refs(&amp;four, &amp;nine);
    // 借用された入力は借用したものより長生きしなくてはならない。
    // 言い換えれば、`four`と`nine`は`print_refs`より長いライフタイムを
    // 持つ必要がある。
    
    failed_borrow();
    // `failed_borrow`関数のライフタイムよりも長くなるような`'a`の参照は
    // 存在しませんが、このような場合、`'a`は`'static`になるため、長いです。
}
</code></pre></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="scope/lifetime/elision.html">省略</a> ライフタイムが暗示的に注釈されることを意味します。</p>
</div>
<h3><a class="header" href="#こちらも参照-45" id="こちらも参照-45">こちらも参照:</a></h3>
<ul>
<li><a href="scope/lifetime/../../generics.html">ジェネリック</a></li>
<li><a href="scope/lifetime/../../fn/closures.html">クロージャ</a></li>
</ul>
<h1><a class="header" href="#関数-2" id="関数-2">関数</a></h1>
<p><a href="scope/lifetime/elision.html">省略</a>しなかった場合、関数のライフタイムにはいくつかの制限があります。</p>
<ul>
<li>すべての参照は明示的なライフタイムを持つ必要がある。</li>
<li>返り値となる参照は、入力と同じか、<code>'static</code>ライフタイムを持つ必要がある。</li>
</ul>
<p>更に、返り値となる参照は、入力がなけく、無効なデータへの参照だった場合エラーになります。
以下の例ではライフタイムを使ったいくつかの有効な関数を示しています。</p>
<pre><pre class="playpen"><code class="language-rust editable">// 少なくともこの関数より長いライフタイム`'a`を持つ
// 一つの参照を入力として受け取る関数
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`print_one`: x is {}&quot;, x);
}

// ライフタイムが合っても可変参照は使えます。
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// 異なるライフタイムを持つ複数の要素。ここでは、同じライフタイム`'a`
// にしても良いかもしれませんが、もっと複雑なケースでは異なるライフタイム
// が必要です。
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;`print_multi`: x is {}, y is {}&quot;, x, y);
}

// 渡された変数はそのまま返すことができます。
// しかし、正しいライフタイムが返される必要があります。
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

//fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String { &amp;String::from(&quot;foo&quot;) }
// 上は無効です。`'a`は関数より長いライフタイムを持つ必要がありますが、
// ここで、`&amp;String::from(&quot;foo&quot;)`は`String`を作り、その参照を返します。
// スコープを抜けたときにデータがdropされるため、無効なデータへの参照を
// 返すことになります。

fn main() {
    let x = 7;
    let y = 9;
    
    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);
    
    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-46" id="こちらも参照-46">こちらも参照:</a></h3>
<ul>
<li><a href="scope/lifetime/fn.html">functions</a></li>
</ul>
<h1><a class="header" href="#メソッド-1" id="メソッド-1">メソッド</a></h1>
<p>メソッドは関数と同じようにアノテーションできます。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Owner(i32);

impl Owner {
    // 普通の関数と同じようにライフタイムを明示する
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!(&quot;`print`: {}&quot;, self.0);
    }
}

fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-47" id="こちらも参照-47">こちらも参照:</a></h3>
<ul>
<li><a href="scope/lifetime/../../fn/methods.html">メソッド</a></li>
</ul>
<h1><a class="header" href="#構造体-2" id="構造体-2">構造体</a></h1>
<p>構造体も関数と同じようにアノテーションできます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// `Borrowed`は`i32`の参照を保存します。`i32`の参照は`Borrowed`より
// 長生きする必要があります。
#[derive(Debug)]
struct Borrowed&lt;'a&gt;(&amp;'a i32);

// 同じように、両方共構造体より長生きする必要があります。
#[derive(Debug)]
struct NamedBorrowed&lt;'a&gt; {
    x: &amp;'a i32,
    y: &amp;'a i32,
}

// `i32`またはその参照を格納するenum。
#[derive(Debug)]
enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number    = Either::Num(y);

    println!(&quot;x is borrowed in {:?}&quot;, single);
    println!(&quot;x and y are borrowed in {:?}&quot;, double);
    println!(&quot;x is borrowed in {:?}&quot;, reference);
    println!(&quot;y is *not* borrowed in {:?}&quot;, number);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-48" id="こちらも参照-48">こちらも参照:</a></h3>
<ul>
<li><a href="scope/lifetime/../../custom_types/structs.html"><code>struct</code></a></li>
</ul>
<h1><a class="header" href="#トレイト-1" id="トレイト-1">トレイト</a></h1>
<p>トレイトでのライフタイムも基本的に関数と同じです。
<code>impl</code>も明示的アノテーションを持てることに注意してください。</p>
<pre><pre class="playpen"><code class="language-rust editable">// ライフタイムのアノテーションを持つ構造体
#[derive(Debug)]
 struct Borrowed&lt;'a&gt; {
     x: &amp;'a i32,
 }

// implブロックに対してライフタイムを明示する。
impl&lt;'a&gt; Default for Borrowed&lt;'a&gt; {
    fn default() -&gt; Self {
        Self {
            x: &amp;10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();
    println!(&quot;b is {:?}&quot;, b);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-49" id="こちらも参照-49">こちらも参照:</a></h3>
<ul>
<li><a href="scope/lifetime/../../trait.html"><code>trait</code></a></li>
</ul>
<h1><a class="header" href="#ライフタイムの境界" id="ライフタイムの境界">ライフタイムの境界</a></h1>
<p>ジェネリックに境界が設定できたように、ライフタイム(これもジェネリックです)
にも境界が使えます。<code>:</code>はここでは違った意味を持ちますが、<code>+</code>は同じ意味です。
以下の注意を読んでください。</p>
<ol>
<li><code>T: 'a</code>: <code>T</code>の<em>すべて</em>の参照が<code>'a</code>より長生きする必要がある。</li>
<li><code>T: Trait + 'a</code>: 型<code>T</code>は<code>Trait</code>トレイトを実装している必要があり、<code>T</code>の
<em>すべて</em>の参照が<code>'a</code>より長生きする必要がある。</li>
</ol>
<p>下の例では<code>where</code>節を使って上のことを表現しています。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::Debug; // 境界として設定するトレイト

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref`はジェネリック型`T`への参照を持ち、それは未知のライフタイム`'a`
// を持ちます。`T`は`T`のすべての*参照*が`'a`より長生きする必要があり、
// `Ref`のライフタイムは`'a`を超えられません。

// `Debug`トレイトを持つジェネリック型`T`をプリントする関数
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!(&quot;`print`: t is {:?}&quot;, t);
}

// `Debug`を実装し、`T`すべての参照が`'a`より長生きするような
// ジェネリック型`T`の参照をとります。さらに、`'a`は関数より
// 長生きする必要があります。
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!(&quot;`print_ref`: t is {:?}&quot;, t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-50" id="こちらも参照-50">こちらも参照:</a></h3>
<ul>
<li><a href="scope/lifetime/../../generics.html">ジェネリック</a></li>
<li><a href="scope/lifetime/../../generics/bounds.html">ジェネリックの境界</a></li>
<li><a href="scope/lifetime/../../generics/multi_bounds.html">ジェネリックでの複数の境界</a></li>
</ul>
<h1><a class="header" href="#ライフタイムの圧縮" id="ライフタイムの圧縮">ライフタイムの圧縮</a></h1>
<p>自分より短いライフタイムを持つものに自分を圧縮し、そのままでは
動かないスコープの中でも使えるようにすることができます。これには、
コンパイラが推論して圧縮する場合と、ライフタイムの違いを見て圧縮する
場合があります。</p>
<pre><pre class="playpen"><code class="language-rust editable">// ここで、Rustはできるだけ短いライフタイムを推論し、
// 2つの参照をそれに圧縮します。
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}

// `&lt;'a: 'b, 'b&gt;`は、`'a`は少なくとも`'b`より長いことを意味します。
// ここでは、`&amp;'a i32`を`&amp;'b i32`に圧縮して返す。
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'b i32 {
    first
}

fn main() {
    let first = 2; // 長いライフタイム
    
    {
        let second = 3; // 短いライフタイム
        
        println!(&quot;The product is {}&quot;, multiply(&amp;first, &amp;second));
        println!(&quot;{} is the first&quot;, choose_first(&amp;first, &amp;second));
    };
}
</code></pre></pre>
<h1><a class="header" href="#静的ライフタイム" id="静的ライフタイム">静的ライフタイム</a></h1>
<p>Rustはいくつかの定義済みのライフタイムを持ちます。その中の一つが
<code>'static</code>です。このような2つの状況に出会うかもしれません。</p>
<pre><pre class="playpen"><code class="language-rust editable">// 'staticライフタイムで参照する
let s: &amp;'static str = &quot;hello world&quot;;

// トレイト境界としての'static
fn generic&lt;T&gt;(x: T) where T: 'static {}
</code></pre></pre>
<p>両者は関係していますが、微妙に異なります。Rustを学ぶ際に混同してしまうもの
の一つです。それぞれについて例を見ていきましょう。</p>
<h2><a class="header" href="#参照のライフタイム" id="参照のライフタイム">参照のライフタイム</a></h2>
<p>参照のライフタイムとしての<code>'static</code>は、プログラムが走っている間中有効なデータ
への参照を表します。これを短いライフタイムに圧縮することもできます。</p>
<p><code>'static</code>ライフタイムの変数を作る方法は2つありますが、両方とも
バイナリの読み取り専用メモリに保存されます。</p>
<ul>
<li><code>static</code>宣言で定数を作る。</li>
<li><code>&amp;'static str</code>型の文字列リテラルを作る。</li>
</ul>
<p>以下の例はそれぞれの方法を示しています。</p>
<pre><pre class="playpen"><code class="language-rust editable">// `'static`ライフタイムの定数を作る。
static NUM: i32 = 18;

// `NUM`の参照を`'static`ライフタイムを入力のライフタイムに圧縮して
// 返す。
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        // `string`リテラルを作ってプリントする。
        let static_string = &quot;I'm in read-only memory&quot;;
        println!(&quot;static_string: {}&quot;, static_string);

        // `static_string`がスコープを出た時、参照は使えなくなりますが、
        // データはバイナリに残ります。
    }

    {
        // `coerce_static`に使う整数を作る。
        let lifetime_num = 9;

        // `NUM`を`lifetime_num`のライフタイムに圧縮する
        let coerced_static = coerce_static(&amp;lifetime_num);

        println!(&quot;coerced_static: {}&quot;, coerced_static);
    }

    println!(&quot;NUM: {} stays accessible!&quot;, NUM);  // NUM: {}はまだアクセスできます。
}
</code></pre></pre>
<h2><a class="header" href="#トレイトの境界" id="トレイトの境界">トレイトの境界</a></h2>
<p>トレイトの境界として使った時、静的でない参照を含むことができないことを
意味します。つまり、受け取り手はその型の変数を好きなだけ保持することができ、
dropするまで無効にならないということです。</p>
<p>所有しているすべてのデータは<code>'staic</code>ライフタイム境界を持ちますが、その参照は
持ちません。</p>
<pre><pre class="playpen"><code class="language-rust editable compile_fail">use std::fmt::Debug;

fn print_it( input: impl Debug + 'static )
{
    println!( &quot;'static value passed in is: {:?}&quot;, input );
}

fn use_it()
{
    // iは所有していて、参照を持たないので'staticです。
    let i = 5;
    print_it(i);

    // &amp;iはuse_it()で定義されたスコープでしか使えないので、
    // 'staticではありません。
    print_it(&amp;i);
}
</code></pre></pre>
<p>コンパイラはこのように出力します。</p>
<pre><code class="language-ignore">error[E0597]: `i` does not live long enough
  --&gt; src/lib.rs:15:15
   |
15 |     print_it(&amp;i);
   |     ---------^^--
   |     |         |
   |     |         borrowed value does not live long enough
   |     argument requires that `i` is borrowed for `'static`
16 | }
   | - `i` dropped here while still borrowed
</code></pre>
<h3><a class="header" href="#こちらも参照-51" id="こちらも参照-51">こちらも参照:</a></h3>
<ul>
<li><a href="scope/lifetime/../../custom_types/constants.html"><code>'static</code>定数</a></li>
</ul>
<h1><a class="header" href="#省略" id="省略">省略</a></h1>
<p>圧倒的によく使われるライフタイムパターンについては、可読性のために省略
することができます。省略は、単にそれが一般的であるため、存在しています。</p>
<p>次のコードではいくつかの省略の例を紹介します。もっと厳密な記述については、
the bookの<a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">lifetime elision</a>を参照してください。</p>
<pre><pre class="playpen"><code class="language-rust editable">// `elided_input`と`annotated_input`は同じ意味で、`elided_input`の
// ライフタイムはコンパイラによって推論されています。
fn elided_input(x: &amp;i32) {
    println!(&quot;`elided_input`: {}&quot;, x);
}

fn annotated_input&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`annotated_input`: {}&quot;, x);
}

// 同様に、`elided_pass`と`annotated_pass`は同じで、
// `elided_pass`では暗示的に記述が加えられているだけです。
fn elided_pass(x: &amp;i32) -&gt; &amp;i32 { x }

fn annotated_pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 3;

    elided_input(&amp;x);
    annotated_input(&amp;x);

    println!(&quot;`elided_pass`: {}&quot;, elided_pass(&amp;x));
    println!(&quot;`annotated_pass`: {}&quot;, annotated_pass(&amp;x));
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-52" id="こちらも参照-52">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">省略</a></li>
</ul>
<h1><a class="header" href="#トレイト-2" id="トレイト-2">トレイト</a></h1>
<p>トレイトは、未知の型<code>Self</code>に対して実装されたメソッドの集合です。
ここでは、同じトレイトで実装されたメソッドにアクセスすることができます。</p>
<p>トレイトはいかなるデータ型にも実装できます。下の例では、メソッド群<code>Animal</code>
を定義し、<code>Animal</code>トレイトをデータ型<code>Sheep</code>に対して実装することで、<code>Animal</code>
のメソッドを<code>Sheep</code>から使えるようにしています。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Sheep { naked: bool, name: &amp;'static str }

trait Animal {
    //  コンストラクタとなる静的メソッドを定義する。`Self`は実装する型を表す。
    fn new(name: &amp;'static str) -&gt; Self;

    // インスタンスメソッドの定義。ここでは文字列を返す。
    fn name(&amp;self) -&gt; &amp;'static str;
    fn noise(&amp;self) -&gt; &amp;'static str;

    // トレイトはデフォルト実装を提供することができる。
    fn talk(&amp;self) {
        println!(&quot;{} says {}&quot;, self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // 実装者のメソッドは実装者のトレイトで定義したメソッドを使うことができる。
            println!(&quot;{} is already naked...&quot;, self.name());
        } else {
            println!(&quot;{} gets a haircut!&quot;, self.name);

            self.naked = true;
        }
    }
}

// `Animal`トレイトを`Sheep`に実装する。
impl Animal for Sheep {
    // `Self`は実装する型(`Sheep`)
    fn new(name: &amp;'static str) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; &amp;'static str {
        self.name
    }

    fn noise(&amp;self) -&gt; &amp;'static str {
        if self.is_naked() {
            &quot;baaaaah?&quot;
        } else {
            &quot;baaaaah!&quot;
        }
    }
    
    // デフォルトメソッドは上書きできる。
    fn talk(&amp;self) {
        // 例えば、熟考を加えることができる。
        println!(&quot;{} pauses briefly... {}&quot;, self.name, self.noise());  // {}は一息おいた... {}
    }
}

fn main() {
    // この場合、型注釈は必要です。
    let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;);
    // TODO ^ 型注釈を消してみてください。

    dolly.talk();
    dolly.shear();
    dolly.talk();
}
</code></pre></pre>
<h1><a class="header" href="#継承" id="継承">継承</a></h1>
<p>コンパイラは、<code>#[derive]</code><a href="trait/../attribute.html">属性</a>によって、いくつかのトレイトの
標準実装を提供しています。これらのトレイトは、もっと複雑な振る舞いが必要な
場合、手動で実装することもできます。</p>
<p>以下が継承できるトレイトの一覧です。</p>
<ul>
<li>比較トレイト:
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>、<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>、<a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>、<a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>。</li>
<li><code>&amp;T</code>をコピーして<code>T</code>を作成する<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a></li>
<li>'ムーブを行わず、コピーするための<a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>Copy</code></a></li>
<li><code>&amp;T</code>からハッシュを算出する<a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a></li>
<li>データ型のからのインスタンスを作る<a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a></li>
<li><code>{:?}</code>フォーマットで値を出力する<a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a></li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">// `Centimeters`は比較できるタプル構造体です。
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`は出力できるタプル構造体です。
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// `Seconds`は何も属性がないタプル構造体です。
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    // エラー: `Seconds`は`Debug`トレイトを実装していないためプリントできません。
    //println!(&quot;One second looks like: {:?}&quot;, _one_second);
    // TODO ^ この行をアンコメントしてみてください

    // エラー: `Seconds`は`PartialEq`トレイトを実装していないため比較できません。
    //let _this_is_true = (_one_second == _one_second);
    // TODO ^ この行をアンコメントしてみてください

    let foot = Inches(12);

    println!(&quot;One foot equals {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;smaller&quot;
        } else {
            &quot;bigger&quot;
        };

    println!(&quot;One foot is {} than one meter.&quot;, cmp);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-53" id="こちらも参照-53">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/reference/attributes.html#derive"><code>derive</code></a></li>
</ul>
<h1><a class="header" href="#dynでトレイトを返す" id="dynでトレイトを返す"><code>dyn</code>でトレイトを返す</a></h1>
<p>Rustコンパイラは返り値にどのくらいスペースが必要か事前に把握する必要があります。これは、すべての関数が具象型を返す必要があることを意味します。他の言語と違って、
異なる実装は異なるメモリ容量を持つため、<code>Animal</code>のようなトレイトを持っていたとしても、<code>Animal</code>を返す関数は書けません。</p>
<p>しかし、これには簡単な回避策があります。トレイとオブジェクトを直接返す代わりに、<code>Animal</code>を含む<code>Box</code>型を返せばよいのです。<code>box</code>はヒープメモリの参照に
過ぎませんが、参照は固定されたサイズを持っている上、コンパイラはヒープに格納された<code>Animal</code>の参照を返すことが保証されているため、関数からトレイトを返すことが
できます!</p>
<p>Rustはヒープへのメモリ確保ができるだけ明示的になるようにしてきました。そのため、ヒープに確保されたトレイトの参照を返すときも、
返す型を<code>dyn</code>キーワードで明示しなければいけません (例えば<code>Box&lt;dyn Animal&gt;</code>)</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Sheep {}
struct Cow {}

trait Animal {
    // インスタンスメソッド
    fn noise(&amp;self) -&gt; &amp;'static str;
}

// `Sheep`に`Animal`トレイトを実装する。
impl Animal for Sheep {
    fn noise(&amp;self) -&gt; &amp;'static str {
        &quot;baaaaah!&quot;
    }
}

// `Cow`に`Animal`トレイトを実装する。
impl Animal for Cow {
    fn noise(&amp;self) -&gt; &amp;'static str {
        &quot;moooooo!&quot;
    }
}

// Animalを実装したいくつかの構造体を返しますが、コンパイル時にはその型がわかりません。
fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {
    if random_number &lt; 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!(&quot;You've randomly chosen an animal, and it says {}&quot;, animal.noise());
}

</code></pre></pre>
<h1><a class="header" href="#演算子オーバーロード" id="演算子オーバーロード">演算子オーバーロード</a></h1>
<p>Rustでは、ほとんどの演算子がトレイトによってオーバーロードできます。つまり、いくつかの演算子は
引数によって違う操作を行うことができます。これは、演算子がメソッド呼び出しの糖衣構文だからこそ
実現できます。例えば、<code>a + b</code>の<code>+</code>演算子は<code>add</code>メソッドを<code>a.add(b)</code>のように呼び出します。
この<code>add</code>メソッドは<code>Add</code>トレイトによって定義されていないため、<code>+</code>演算子は<code>Add</code>トレイトを
実装すれば使えるようになります。</p>
<p><code>Add</code>のような、演算子オーバーロードに使うトレイトの一覧は<a href="https://doc.rust-lang.org/core/ops/"><code>core::ops</code></a>にあります。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// `std::ops::Add`トレイトは`+`演算子の動作を定義するのに使います。
// ここでは、右辺値が`Bar`のときの足し算を定義する`Add&lt;Bar&gt;`を実装します。
// このブロックはFoo + Bar = FooBarを実装しています。
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        println!(&quot;&gt; Foo.add(Bar) was called&quot;);

        FooBar
    }
}

// 型を逆にすることで、交換法則に従わない実装を作ることができます。
// ここでは、右辺値が`Foo`のときの足し算を定義する`Add&lt;Foo&gt;`を実装します。
// このブロックはBar + Foo = BarFooを定義しています。
impl ops::Add&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -&gt; BarFoo {
        println!(&quot;&gt; Bar.add(Foo) was called&quot;);

        BarFoo
    }
}

fn main() {
    println!(&quot;Foo + Bar = {:?}&quot;, Foo + Bar);
    println!(&quot;Bar + Foo = {:?}&quot;, Bar + Foo);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-54" id="こちらも参照-54">こちらも参照</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/core/ops/trait.Add.html">Add</a></li>
<li><a href="https://doc.rust-lang.org/book/appendix-02-operators.html">構文インデックス</a></li>
</ul>
<h1><a class="header" href="#drop" id="drop">Drop</a></h1>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>トレイトは唯一つのメソッド<code>drop</code>を持ち、オブジェクトがスコープを抜けたときに
自動的に呼び出されます。<code>Drop</code>トレイトは主に実装者のインスタンスを開放するのに使われます。</p>
<p><code>Box</code>、<code>Vec</code>、<code>String</code>、<code>File</code>、<code>Process</code> などはリソースを開放するために
<code>Drop</code>トレイトを実装している型の例です。<code>Drop</code>はカスタム型に手動で実装することもできます。</p>
<p>以下の例では、<code>drop</code>が呼び出されたときにコンソールに出力します。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Droppable {
    name: &amp;'static str,
}

// `drop`が呼び出されたときにコンソールに出力する小さな実装
impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;&gt; Dropping {}&quot;, self.name);
    }
}

fn main() {
    let _a = Droppable { name: &quot;a&quot; };

    // ブロックA
    {
        let _b = Droppable { name: &quot;b&quot; };

        // ブロックB
        {
            let _c = Droppable { name: &quot;c&quot; };
            let _d = Droppable { name: &quot;d&quot; };

            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Just exited block B&quot;);

        println!(&quot;Exiting block A&quot;);
    }
    println!(&quot;Just exited block A&quot;);

    // `drop`関数を使って手動で呼び出すこともできます。
    drop(_a);
    // TODO ^ この行をコメントアウトしてください。

    println!(&quot;end of the main function&quot;);

    // `_a`はもう手動で`drop`されたので、ここでは`drop`されません。
}
</code></pre></pre>
<h1><a class="header" href="#イテレータ" id="イテレータ">イテレータ</a></h1>
<p><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a>トレイトは配列のようなコレクションにイテレータを実装するトレイトです。</p>
<p>このトレイトは次の要素を表す<code>next</code>メソッドのみ実装すればよく、これは<code>impl</code>ブロックで
実装するか、(配列やrangeのように)もう実装されていることもあります。</p>
<p>一般的なシチュエーションでの利便性のため、<code>for</code>は自動的にコレクションに対して
<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>.into_iter()</code></a>メソッドを使い、イテレータを作ります。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Fibonacci {
    curr: u32,
    next: u32,
}

// `Fibonacci`に`Iterator`を実装する。
// `Iterator`トレイトは、次の要素を返す`next`メソッドのみ実装されていれば良い。
impl Iterator for Fibonacci {
    type Item = u32;
    
    // ここで、`.curr`と`.next`を使って数列を作り、
    // `Option&lt;T&gt;`型を返します。
    //     * `Iterator`が終われば、`None`を返します。
    //     * そうでなければ、次の値を`Some`でくるみ、返却します。
    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {
        let new_next = self.curr + self.next;

        self.curr = self.next;
        self.next = new_next;

        // フィボナッチ数列には終わりは無いため、`Iterator`は`None`を
        // 返さず、いつも`Some`を返します。
        Some(self.curr)
    }
}

// フィボナッチ数列生成器を返す。
fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 0, next: 1 }
}

fn main() {
    // `0..3`は0、1、2からなるイテレータを生成する
    let mut sequence = 0..3;

    println!(&quot;Four consecutive `next` calls on 0..3&quot;);  // 0..3から4回連続で`next`を呼ぶ。
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());

    // `for`はイテレータを`None`が出るまで続ける。
    // それぞれの`Some`は変数(ここでは`i`)に分割代入される。
    println!(&quot;Iterate through 0..3 using `for`&quot;);  // `for`を使って0..3に対して繰り返し処理をする。
    for i in 0..3 {
        println!(&quot;&gt; {}&quot;, i);
    }

    // `take(n)`メソッドは最初`n`回分のイテレータを返す
    println!(&quot;The first four terms of the Fibonacci sequence are: &quot;);  // フィボナッチ数列の最初の4つは:
    for i in fibonacci().take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    // `skip(n)`メソッドは最初の`n`回をなくしたイテレータを返す。
    println!(&quot;The next four terms of the Fibonacci sequence are: &quot;);  // フィボナッチ数列の次の4つは:
    for i in fibonacci().skip(4).take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    let array = [1u32, 3, 3, 7];

    // `iter`メソッドで配列、スライスからイテレータを生成する。
    println!(&quot;Iterate the following array {:?}&quot;, &amp;array);  // 以下の配列{:?}をイテレートする
    for i in array.iter() {
        println!(&quot;&gt; {}&quot;, i);
    }
}
</code></pre></pre>
<h1><a class="header" href="#impl-trait" id="impl-trait"><code>impl Trait</code></a></h1>
<p>もし関数が<code>MyTrait</code>を実装した型を返す時、返り値を<code>-&gt; impl MyTrait</code>と書くことができます。
これによって型指定師をシンプルに書くことができます!</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::iter;
use std::vec::IntoIter;

// この関数は2つの`Vec&lt;i32&gt;`を連結し、イテレータを返します。
// 返り値が複雑になっています。
fn combine_vecs_explicit_return_type(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;i32&gt;, IntoIter&lt;i32&gt;&gt;&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

// 上と同じですが、返り値に`impl Trait`を使っています。
// とてもシンプルになっています。
fn combine_vecs(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; impl Iterator&lt;Item=i32&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5];
    let mut v3 = combine_vecs(v1, v2);
    assert_eq!(Some(1), v3.next());
    assert_eq!(Some(2), v3.next());
    assert_eq!(Some(3), v3.next());
    assert_eq!(Some(4), v3.next());
    assert_eq!(Some(5), v3.next());
    println!(&quot;all done&quot;);
}
</code></pre></pre>
<p>さらに、Rustのいくつかの型は直接記述できません。例えば、クロージャは、無名な
具象型を持っていて、<code>impl Trait</code>構文を使わなければ、ヒープにクロージャを格納して
返す必要がありました。しかし、今は静的にこう書けます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// 入力に`y`を加えて返すクロージャをかえす関数
fn make_adder_function(y: i32) -&gt; impl Fn(i32) -&gt; i32 {
    let closure = move |x: i32| { x + y };
    closure
}

fn main() {
    let plus_one = make_adder_function(1);
    assert_eq!(plus_one(2), 3);
}
</code></pre></pre>
<p>また、<code>impl Trait</code>は<code>map</code>、<code>filter</code>などのクロージャを使ったイテレータを返すのにも
使えます! これによって、<code>map</code>や<code>filter</code>を簡単に使えるようになります。以前はクロージャ
の型は名前を持たないため、クロージャを使ったイテレータは、明示的に返り値の型が書けなかった
ものが、<code>impl Trait</code>を使って簡単に書けるようになったからです。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn double_positives&lt;'a&gt;(numbers: &amp;'a Vec&lt;i32&gt;) -&gt; impl Iterator&lt;Item = i32&gt; + 'a {
    numbers
        .iter()
        .filter(|x| x &gt; &amp;&amp;0)
        .map(|x| x * 2)
}
</code></pre></pre>
<h1><a class="header" href="#複製" id="複製">複製</a></h1>
<p>リソースについて対処する時、デフォルトで代入元や関数呼び出しによって
値が受け渡されます。しかし、ときどきレソースのコピーが作りたい場合が
あります。</p>
<p><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>トレイトによって、これを正確に行なえます。一般的なもので
いうと、<code>.clone()</code>めそっどは<code>Clone</code>トレイトによって定義されています。</p>
<pre><pre class="playpen"><code class="language-rust editable">// リソースのない構造体
#[derive(Debug, Clone, Copy)]
struct Unit;

// `Clone`トレイトを持つタプル構造体
#[derive(Clone, Debug)]
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

fn main() {
    // `Unit`をインスタンス化する
    let unit = Unit;
    // `Unit`をコピーする。ムーブするリソースが何もない。
    let copied_unit = unit;

    // `Unit`は独立して使える。
    println!(&quot;original: {:?}&quot;, unit);
    println!(&quot;copy: {:?}&quot;, copied_unit);

    // `Pair`をインスタンス化する。
    let pair = Pair(Box::new(1), Box::new(2));
    println!(&quot;original: {:?}&quot;, pair);

    // `pair`を`moved_pair`にコピーした時、リソースがムーブする。
    let moved_pair = pair;
    println!(&quot;copy: {:?}&quot;, moved_pair);

    // エラー! `pair`はリソースを持っていません。
    //println!(&quot;original: {:?}&quot;, pair);
    // TODO ^ この行をアンコメントしてみてください

    // `moved_pair`から`cloned_pair`に複製する(リソースも)
    let cloned_pair = moved_pair.clone();
    // std::mem::dropでもとのリソースをdropする。
    drop(moved_pair);

    // エラー! `moved_pair`はdropされています。
    //println!(&quot;copy: {:?}&quot;, moved_pair);
    // TODO ^ この行をアンコメントしてみてください

    // .clone()の結果はまだ使えます!
    println!(&quot;clone: {:?}&quot;, cloned_pair);
}
</code></pre></pre>
<h1><a class="header" href="#親トレイト" id="親トレイト">親トレイト</a></h1>
<p>Rustは「継承(inheritance、deriveとは別)」を持っていませんが、トレイトを他のトレイトの
親として設定することができます。例えば</p>
<pre><pre class="playpen"><code class="language-rust editable">trait Person {
    fn name(&amp;self) -&gt; String;
}

// StudentはPersonを親とする。
// Studentを実装するにはimpl Personが必要。
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// CompSciStudent (コンピュータ科学の学生)はProgrammerとStudent両方を親とする。
// CompSciStudentの実装には両方の実装が必要。
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        &quot;My name is {} and I attend {}. My Git username is {}&quot;,
        student.name(),
        student.university(),
        student.git_username()
    )
}

fn main() {}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-55" id="こちらも参照-55">こちらも参照:</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait">The Rust Programming Languageのsupertrait節の章</a></p>
<h1><a class="header" href="#重複するトレイトの明確化" id="重複するトレイトの明確化">重複するトレイトの明確化</a></h1>
<p>一つの型には多くのトレイトが実装できます。2つのトレイトが同じ名前を持つ場合はどうでしょう? 例えば、多くのトレイトが<code>get()</code>メソッドを持っているかもしれません。
そして、それらは違う型を返すかもしれません!</p>
<p>それぞれのトレイトが独自の<code>impl</code>ブロックを使って宣言するため、
どのトレイトの<code>get</code>メソッドなのか明確にわかります。</p>
<p>それを_呼び出す_ ときはどうでしょうか? それらを明確化するために、
完全修飾構文(Fully Qualified Syntax)を使います。</p>
<pre><pre class="playpen"><code class="language-rust editable">trait UsernameWidget {
    // そのウィジェットで指定されたユーザー名を返す
    fn get(&amp;self) -&gt; String;
}

trait AgeWidget {
    // そのウィジェットで指定された年齢を返す
    fn get(&amp;self) -&gt; u8;
}

// UsernameWidgetとAgeWidgetを両方実装したフォーム
struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&amp;self) -&gt; String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&amp;self) -&gt; u8 {
        self.age
    }
}

fn main() {
    let form = Form{
        username: &quot;rustacean&quot;.to_owned(),
        age: 28,
    };

    // これをアンコメントすると、「複数の`get`が見つかりました」というエラー
    // を返します。なぜなら、`get`という名前のメソッドが複数あるためです。
    // println!(&quot;{}&quot;, form.get());

    let username = &lt;Form as UsernameWidget&gt;::get(&amp;form);
    assert_eq!(&quot;rustacean&quot;.to_owned(), username);
    let age = &lt;Form as AgeWidget&gt;::get(&amp;form);
    assert_eq!(28, age);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-56" id="こちらも参照-56">こちらも参照:</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">The Rust Programming Languageの完全修飾構文の節</a></p>
<h1><a class="header" href="#macro_rules" id="macro_rules">macro_rules!</a></h1>
<p>Rustはメタプログラミングのための強力なマクロシステムを備えています。前の章で
見たように、マクロは関数のように働き、その名前は<code>!</code>で終わります。しかし、関数
と違って、マクロはコンパイルされる前に、ソースコードに展開されます。また、Cの
ような言語のマクロとは違い、Rustのマクロは抽象構文木に展開されるため、前処理
より強力です。そのため、予期しない優先順位によるバグが起こることはありません。</p>
<p>マクロは<code>macro_rules!</code>マクロで作ることができます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// シンプルなマクロ`say_hello`
macro_rules! say_hello {
    // `()`はマクロが引数を取らないことを表します。
    () =&gt; {
        // マクロはこのブロックの要素に展開されます。
        println!(&quot;Hello!&quot;);
    };
}

fn main() {
    // This call will expand into `println!(&quot;Hello&quot;);`
    say_hello!()
}
</code></pre></pre>
<p>マクロはなぜ有用なのでしょうか?</p>
<ol>
<li>
<p>同じことを繰り返さない(Don't repeat yourself, DRY)。似たような処理を複数の場所に
使いたいが、違う型であるためにまとめるのが難しいときがあります。マクロを使えば、
コードの繰り返しを避けられることがあります。(詳しくは後で)</p>
</li>
<li>
<p>ドメイン固有言語。マクロで特有の目的のための特殊な構文が定義できます。(詳しくは
後で)</p>
</li>
<li>
<p>可変長引数。時々可変長の引数を取るインターフェースを書きたいときがあります。例えば
<code>println!</code>はフォーマット文字列に従って様々な数の引数をとります。(詳しくは後で)</p>
</li>
</ol>
<h1><a class="header" href="#構文" id="構文">構文</a></h1>
<p>以下のサブセクションで、Rustでのマクロの書き方を紹介します。
基本的に3つの概念があります。</p>
<ul>
<li><a href="macros/designators.html">マクロ指定子</a></li>
<li><a href="macros/overload.html">オーバーロード</a></li>
<li><a href="macros/repeat.html">繰り返し</a></li>
</ul>
<h1><a class="header" href="#マクロ指定子" id="マクロ指定子">マクロ指定子</a></h1>
<p>マクロの引数は<code>$</code>で始まり、そのタイプは<em>指定子</em>で注釈します。</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! create_function {
    // このマクロは`ident`指定子の引数をとり、
    // `$func_name`という名前の関数を作ります。
    // The `ident` designator is used for variable/function names.
    ($func_name:ident) =&gt; {
        fn $func_name() {
            // `stringify!`マクロは`ident`を文字列に変換します。
            println!(&quot;You called {:?}()&quot;,
                     stringify!($func_name));
        }
    };
}

// 上のマクロを使って、`foo`と`bar`という関数を定義します。
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // このマクロは式`$expression`をとり、それを文字列にしたものと
    // その結果を返します。`expr`指定子は式に対して指定します。
    ($expression:expr) =&gt; {
        // `stringify!`は式を*そのまま*文字列に変換します。
        println!(&quot;{:?} = {:?}&quot;,
                 stringify!($expression),
                 $expression);
    };
}

fn main() {
    foo();
    bar();

    print_result!(1u32 + 1);

    // ブロックも式です!
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });
}
</code></pre></pre>
<p>これらが利用可能な指定子の一例です。</p>
<ul>
<li><code>block</code></li>
<li><code>expr</code>は式に使います。</li>
<li><code>ident</code>は変数/関数名に使います。</li>
<li><code>item</code></li>
<li><code>literal</code>はリテラルに使います</li>
<li><code>pat</code> (<em>パターン</em>)</li>
<li><code>path</code></li>
<li><code>stmt</code> (<em>式</em>)</li>
<li><code>tt</code> (<em>トークン木</em>)</li>
<li><code>ty</code> (<em>型</em>)</li>
<li><code>vis</code> (<em>可視性指定子</em>(<code>pub</code>など))</li>
</ul>
<p>完全な一覧は<a href="https://doc.rust-lang.org/reference/macros-by-example.html">Rustリファレンス</a>を参照してください。</p>
<h1><a class="header" href="#オーバーロード" id="オーバーロード">オーバーロード</a></h1>
<p>マクロは違う引数を取るようにオーバーロードできます。
ついては、<code>macro_rules!</code>はmatchブロックのように使用できます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// `test!` will compare `$left` and `$right`
// in different ways depending on how you invoke it:
macro_rules! test {
    // 引数をコンマで区切る必要はありません。
    // テンプレートが使えます!
    ($left:expr; and $right:expr) =&gt; {
        println!(&quot;{:?} and {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    };
    // ^ それぞれのアームはセミコロンで終わる必要があります。
    ($left:expr; or $right:expr) =&gt; {
        println!(&quot;{:?} or {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    };
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}
</code></pre></pre>
<h1><a class="header" href="#繰り返し" id="繰り返し">繰り返し</a></h1>
<p>マクロは引数リストに<code>+</code>を指定することで1回以上の、<code>*</code>を指定することで
0回以上の繰り返しを表現できます。</p>
<p>以下の例で、指定子を<code>$(...),+</code>で囲むことで、コンマで分けられた
一つ以上の式を表現できます。また、最後のセミコロンは省略できます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// `find_min!`は引数の内最小のものを返します。
macro_rules! find_min {
    // 基本ケース:
    ($x:expr) =&gt; ($x);
    // `$x`と1つ以上の`$y,`からなる。
    ($x:expr, $($y:expr),+) =&gt; (
        // `find_min!`を末尾の`$y`に対して実行する
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!(&quot;{}&quot;, find_min!(1u32));
    println!(&quot;{}&quot;, find_min!(1u32 + 2, 2u32));
    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));
}
</code></pre></pre>
<h1><a class="header" href="#同じことを繰り返さないdry" id="同じことを繰り返さないdry">同じことを繰り返さない(DRY)</a></h1>
<p>マクロに関数やテストの共通部分を記述することで、DRYコードが実現できます。
これは<code>+=</code>、<code>*=</code>、<code>-=</code>演算子を<code>Vec&lt;T&gt;</code>に実装する例です。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // `tt`(token tree)指定子は
    // 演算子やトークンに使われます。
    ($a:expr, $b:expr, $func:ident, $op:tt) =&gt; {
        assert!($a.len() == $b.len(),
                &quot;{:?}: dimension mismatch: {:?} {:?} {:?}&quot;,
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    };
}

macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; {
        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    };
}

// `add_assign`、`mul_assign`、`sub_assign`関数を実装する。
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ($func:ident, $x:expr, $y:expr, $z:expr) =&gt; {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                    super::$func(&amp;mut x, &amp;y);

                    assert_eq!(x, z);
                }
            }
        };
    }

    // `add_assign`、`mul_assign`、`sub_assign`をテストする。
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}
</code></pre></pre>
<pre><code class="language-shell">$ rustc --test dry.rs &amp;&amp; ./dry
running 3 tests
test test::mul_assign ... ok
test test::add_assign ... ok
test test::sub_assign ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<h1><a class="header" href="#ドメイン固有言語dsl" id="ドメイン固有言語dsl">ドメイン固有言語(DSL)</a></h1>
<p>DSLはRustのマクロによって組み込まれた小さな「言語」です。これは、マクロシステムは普通のRust構文
へ展開しますが、これが小さな言語のように見えることによって成り立っています。これによって、特定の
用途において簡潔で直感的な構文を定義できます(適度に)。</p>
<p>ここで、小さな電卓APIを作ろうと思います。これは式を実行して、
その結果をコンソールに出力するものです。</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! calculate {
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // 強制的に型を整数にする。
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};
}

fn main() {
    calculate! {
        eval 1 + 2 // `eval`はRustのキーワードではありません!
    }

    calculate! {
        eval (1 + 2) * (3 / 4)
    }
}
</code></pre></pre>
<p>出力:</p>
<pre><code class="language-txt">1 + 2 = 3
(1 + 2) * (3 / 4) = 0
</code></pre>
<p>これはとてもシンプルな例ですが、<a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a>や
<a href="https://crates.io/crates/clap"><code>clap</code></a>のようなもっと複雑な例もあります。</p>
<p>さらに、マクロ内に2重の波括弧があることに注意してください。外側のものは
<code>()</code>や<code>[]</code>のような、<code>macro_rules!</code>の構文です。</p>
<h1><a class="header" href="#可変長引数" id="可変長引数">可変長引数</a></h1>
<p>可変長引数は様々な数の引数をとります。例えば、<code>println!</code>は、フォーマット文字列
に従って、いろいろな数の引数をとります。</p>
<p>前の章の<code>calculate!</code>マクロを拡張してみましょう。</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! calculate {
    // `eval`がひとつだけの場合
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Force types to be integers
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};

    // `eval`が複数ある場合、再帰を使う。
    (eval $e:expr, $(eval $es:expr),+) =&gt; {{
        calculate! { eval $e }
        calculate! { $(eval $es),+ }
    }};
}

fn main() {
    calculate! { // 可変長の`calculate!`です!
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }
}
</code></pre></pre>
<p>出力:</p>
<pre><code class="language-txt">1 + 2 = 3
3 + 4 = 7
(2 * 3) + 1 = 7
</code></pre>
<h1><a class="header" href="#エラー処理" id="エラー処理">エラー処理</a></h1>
<p>エラー処理は操作の失敗を処理するのに使われます。例えば、ファイルを読み込む
のに失敗したとき、<em>間違った</em>入力で操作を続けるのは問題があります。明示的に
このようなエラーを管理することで、残りのプログラムで落とし穴にはまるのを防ぐ
ことができます。</p>
<p>次の節から紹介するように、Rustでは様々な方法でこれを対処することができ、その微妙な
違いを異なる場面で使い分けることができます。以下に大雑把な説明を載せます。</p>
<p>明示的な<code>panic</code>は、主にテストや修復不可能なエラーを処理するのに使います。これは
プロトタイピングにも使えます。例えば、まだ実装していない関数の使用を処理するときは、
<code>unimplemented</code>を使うのが説明的で良いでしょう。テストでは、<code>panic</code>は明示的に失敗する
のに便利です。</p>
<p><code>Option</code>型は、値がない場合もあり、それはエラーではないという時に使えます。例えば、
<code>/</code>や<code>C:</code>は親ディレクトリを持ちません。<code>Option</code>を使うとき、値があることが確かに保証
されている場合や、プロトタイピングの用途では<code>unwrap</code>が有用ですが、なにかの失敗があった
時にエラーメッセージを表示する<code>expect</code>も有用です。</p>
<p>処理が失敗する可能性があり、それを呼び出し元が処理する必要がある時、<code>Result</code>を使います。
これについても<code>unwrap</code>や<code>expect</code>が使用できます。(テストやプロトタイプ以外では使用しない
でください。)</p>
<p>もっと厳密な議論については、<a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">The book</a>のエラー処理の章を参照してください。</p>
<h1><a class="header" href="#panic" id="panic"><code>panic</code></a></h1>
<p>最もシンプルなエラー処理は<code>panic</code>です。これはエラーメッセージを表示し、
スタックを巻き戻し、通常はプログラムを終了します。
ここでは、エラーしたときに<code>panic</code>を直接呼び出しています。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn give_princess(gift: &amp;str) {
    // プリンセスはヘビが嫌いです。なので、彼女が拒否したときに
    // 止めてあげる必要があります!
    if gift == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, gift);
}

fn main() {
    give_princess(&quot;teddy bear&quot;);
    give_princess(&quot;snake&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#optionとunwrap" id="optionとunwrap"><code>Option</code>と<code>unwrap</code></a></h1>
<p>前の例で、どのようにしてプログラムが失敗したときにストップするかを見て
きました。ここではプリンセスが不適切な贈り物(ヘビ)を受け取ったときに
<code>panic</code>を起こしました。しかし、プリンセスが贈り物をもらえなかったときは
どうでしょうか? このケースも良くないため、処理しなければいけません。</p>
<p>Rustでは使えない、空データを指すポインタの代わりに、なにも贈らないことを
空文字列(<code>&quot;&quot;</code>)を用いて表すこともできます。</p>
<p>しかし、<code>std</code>ライブラリの<code>Option&lt;T&gt;</code>という<code>enum</code>を使えば、何も無いことを
表すことができます。</p>
<ul>
<li><code>Some(T)</code>: <code>T</code>型の値がある場合</li>
<li><code>None</code>: なにも値がない場合</li>
</ul>
<p>これは、<code>match</code>で明示的に処理することも、<code>unwrap</code>で暗示的に処理することが
できます。暗示的な処理では、その中の値を返し、なければ<code>panic</code>を起こします。</p>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect">expect</a>を使えば、<code>panic</code>の表示をカスタマイズできますが、<code>unwrap</code>は
意味のあまりない出力しか返しません。以下の例では、明示的に処理し、<code>panic</code>
よりカスタマイズされた結果を返しています。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// 平民は、贈り物をすべて確認して、うまく処理します。
// すべての贈り物は`match`で明示的に処理されています。
fn give_commoner(gift: Option&lt;&amp;str&gt;) {
    // Specify a course of action for each case.
    match gift {
        Some(&quot;snake&quot;) =&gt; println!(&quot;Yuck! I'm putting this snake back in the forest.&quot;),  // オエーッ! このヘビを森に返してくるわ。
        Some(inner)   =&gt; println!(&quot;{}? How nice.&quot;, inner),  // {}? いいじゃないの。
        None          =&gt; println!(&quot;No gift? Oh well.&quot;),  // 何もない? 仕方ないわ。
    }
}

// 私達のプリンセスは世の中を知らないため、ヘビを見ると`panic`してしまいます。
// すべての贈り物は`unwrap`で暗示的に処理されます。
fn give_princess(gift: Option&lt;&amp;str&gt;) {
    // `unwrap`は`None`を受け取ると`panic`します。
    let inside = gift.unwrap();
    if inside == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, inside);
}

fn main() {
    let food  = Some(&quot;cabbage&quot;);
    let snake = Some(&quot;snake&quot;);
    let void  = None;

    give_commoner(food);
    give_commoner(snake);
    give_commoner(void);

    let bird = Some(&quot;robin&quot;);
    let nothing = None;

    give_princess(bird);
    give_princess(nothing);
}
</code></pre></pre>
<h1><a class="header" href="#でoptionを解析する" id="でoptionを解析する"><code>?</code>でOptionを解析する</a></h1>
<p><code>match</code>文で<code>Option</code>を解析できますが、しばしば<code>?</code>演算子を使った方が簡単です。
もし<code>x</code>が<code>Option</code>だとしたら、<code>x?</code>と書けば、<code>x</code>が<code>Some</code>ならその値を、そうで
なければ現在の関数をNoneを返して終了します。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn next_birthday(current_age: Option&lt;u8&gt;) -&gt; Option&lt;String&gt; {
	// `current_age`が`None`なら`None`を返す。
	// `current_age`が`Some`なら、`u8`は`next_age`に代入される
    let next_age: u8 = current_age?;
    Some(format!(&quot;Next year I will be {}&quot;, next_age))
}
</code></pre></pre>
<p>コードの可読性をあげるため、<code>?</code>はたくさん連結できます。</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Person {
    job: Option&lt;Job&gt;,
}

#[derive(Clone, Copy)]
struct Job {
    phone_number: Option&lt;PhoneNumber&gt;,
}

#[derive(Clone, Copy)]
struct PhoneNumber {
    area_code: Option&lt;u8&gt;,
    number: u32,
}

impl Person {

    // その人の仕事用の電話番号のエリアコードを取得します。
    fn work_phone_area_code(&amp;self) -&gt; Option&lt;u8&gt; {
        // `?`演算子がなければ、`match`文をたくさんネストする必要がありました。
        // 簡単に連結を増やすこともできます。試してみてください。
        self.job?.phone_number?.area_code
    }
}

fn main() {
    let p = Person {
        job: Some(Job {
            phone_number: Some(PhoneNumber {
                area_code: Some(61),
                number: 439222222,
            }),
        }),
    };

    assert_eq!(p.work_phone_area_code(), Some(61));
}
</code></pre></pre>
<h1><a class="header" href="#コンビネータ-map" id="コンビネータ-map">コンビネータ: <code>map</code></a></h1>
<p><code>match</code>は<code>Option</code>を処理するのに使えます。しかし、特に引数の値が有効である必要がある
場合、これが億劫だと思うかもしれません。このような場合、<a href="https://doc.rust-lang.org/book/glossary.html#combinators">コンビネータ</a>
でモジュール的に制御フローを管理することができます。</p>
<p><code>Option</code>は、<code>Some -&gt; Some</code>や<code>None -&gt; None</code>のような単純な処理を扱うために<code>map()</code>という
ビルトインメソッドを持っていて、これを柔軟に連結することができます。</p>
<p>以下の例では、<code>process()</code>は以前の関数のすべてをコンパクトに置き換えることができます。</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { Apple, Carrot, Potato }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// 食べ物の皮を剥く。もし何もなければ、`None`を返す。
// その他の場合は、剥いた食べ物を返す。
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// 食べ物を切る。もし何もなければ、`None`を返す。
// その他の場合は、切った食べ物を返す。
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// 食べ物を料理する。ここでは`match`の代わりに`map()`で処理する。
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// 食べ物を連続で剥き、切り、料理する。
// `map()`を連結してシンプルなコードを実現している。
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

// 食べる前に食べ物があるか確認する必要があります!
fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!(&quot;Mmm. I love {:?}&quot;, food),
        None       =&gt; println!(&quot;Oh no! It wasn't edible.&quot;),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));
    // `process()`でシンプルに調理してみましょう
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-57" id="こちらも参照-57">こちらも参照:</a></h3>
<ul>
<li><a href="error/option_unwrap/../../fn/closures.html">クロージャ</a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>Option::map()</code></a></li>
</ul>
<h1><a class="header" href="#コンビネータ-and_then" id="コンビネータ-and_then">コンビネータ: <code>and_then</code></a></h1>
<p><code>map()</code>は<code>match</code>文を連結してシンプルにするものでした。しかし、
<code>Option&lt;T&gt;</code>を返す関数で<code>map()</code>を使えば、ネストされた<code>Option&lt;Option&lt;t&gt;&gt;</code>
が必要になります。この場合、複数の呼び出しを連続で使うと混乱を招きます。
ここで、他の言語では<code>flatmap</code>として知られている、別のコンビネータ
<code>and_then()</code>の登場です。</p>
<p><code>and_then()</code>は引数として渡された関数にラップされた値を返しますが、それが<code>None</code>なら、
<code>None</code>を返します。</p>
<p>In the following example, <code>cookable_v2()</code> results in an <code>Option&lt;Food&gt;</code>. 
Using <code>map()</code> instead of <code>and_then()</code> would have given an 
<code>Option&lt;Option&lt;Food&gt;&gt;</code>, which is an invalid type for <code>eat()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

// 寿司の材料を持っていません。
fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

// コルドン・ブルー(訳注: カツレツのようなもの)のレシピを持っていません。
fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}

// 料理を作るには、材料とレシピの両方が必要です。
// `match`でロジックの流れを表す。
fn cookable_v1(food: Food) -&gt; Option&lt;Food&gt; {
    match have_recipe(food) {
        None       =&gt; None,
        Some(food) =&gt; match have_ingredients(food) {
            None       =&gt; None,
            Some(food) =&gt; Some(food),
        },
    }
}

// `and_then()`でコンパクトに書き直すことができます。
fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_recipe(food).and_then(have_ingredients)
}

fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) =&gt; println!(&quot;Yay! On {:?} we get to eat {:?}.&quot;, day, food),
        None       =&gt; println!(&quot;Oh no. We don't get to eat on {:?}?&quot;, day),
    }
}

fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-58" id="こちらも参照-58">こちらも参照:</a></h3>
<ul>
<li><a href="error/option_unwrap/../../fn/closures.html">クロージャ</a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then"><code>Option::and_then()</code></a></li>
</ul>
<h1><a class="header" href="#result" id="result"><code>Result</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>は値の<em>不在</em>を<em>エラー</em>に置き換えた<a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>型
の上位互換です。</p>
<p>つまり、<code>Result&lt;T, E&gt;</code>は2つの結果を持つことができます。</p>
<ul>
<li><code>Ok(T)</code>: <code>T</code>が存在する場合</li>
<li><code>Err(E)</code>: <code>E</code>というエラーが見つかった場合</li>
</ul>
<p>利便性のため、期待する値を<code>Ok</code>、予期せぬ値を<code>Err</code>に入れます。</p>
<p><code>Option</code>と同じように、<code>Result</code>は多くのメソッドを持っています。例えば、
<code>unwrap()</code>は<code>T</code>型の値を返すか、<code>panic</code>します。また、条件処理のために、
<code>Option</code>と同じようなコンビネータが<code>Result</code>にもあります。</p>
<p>Rustを使っていると、おそらく、<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a>のように<code>Result</code>型を返す
ようなメソッドに出会うでしょう。文字列をいつも他の型に変換できるとは限らない
ため、<code>parse()</code>は失敗を処理するために<code>Result</code>を使っています。</p>
<p>成功した場合と失敗した場合の文字列の<code>parse()</code>の振る舞いを見てみましょう。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; i32 {
    // `unwrap()`を使って数値を取り出してみましょう。
    let first_number = first_number_str.parse::&lt;i32&gt;().unwrap();
    let second_number = second_number_str.parse::&lt;i32&gt;().unwrap();
    first_number * second_number
}

fn main() {
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, twenty);

    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, tt);
}
</code></pre></pre>
<p><code>parse()</code>が失敗した場合は、<code>unwrap()</code>で<code>panic</code>を起こしてプログラムを終了しました。
さらに、<code>panic</code>は不快なエラーメッセージを返しました。</p>
<p>エラーメッセージの質を改善するため、返り値の型をさらに特定し、明示的に
エラーを処理する必要があります。</p>
<h2><a class="header" href="#mainでresultを使う" id="mainでresultを使う"><code>main</code>で<code>Result</code>を使う</a></h2>
<p>明示的に指定することで、<code>Result</code>型を<code>main</code>関数で使うこともできます。
典型的な<code>main</code>関数はこのような形です。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>しかし、<code>main</code>は返り値として<code>Result</code>を使うこともできます。<code>main</code>関数内でエラーが
起これば、エラーコードを返し、デバッグプリントでエラーを報告します。(<a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>
トレイトを使います。) 以下の例では、次の例では、そのようなシナリオを紹介し、
<a href="error/result/early_returns.html">後の節</a>で扱う内容にも触れます。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn main() -&gt; Result&lt;(), ParseIntError&gt; {
    let number_str = &quot;10&quot;;
    let number = match number_str.parse::&lt;i32&gt;() {
        Ok(number)  =&gt; number,
        Err(e) =&gt; return Err(e),
    };
    println!(&quot;{}&quot;, number);
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#resultのmap" id="resultのmap"><code>Result</code>の<code>map</code></a></h1>
<p>前の例の<code>multiply</code>でのパニックは実用コードのために作られていません。
普通、呼び出し元にエラーを返し、エラー処理を呼び出し元に任せます。</p>
<p>まず、どのようなタイプのエラーがあるのか知る必要があります。<code>Err</code>の型を決めるため、
<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a>トレイトを<a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>に実装することで提供されている<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code>
</a>関数を見てみます。すると、<code>Err</code>の型は<a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>だと
定義されていることがわかります。</p>
<p>以下の例では、愚直に<code>match</code>文を使っていますが、これは面倒です。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// 返り値の型を書き直し、`unwrap()`を使わずパターンマッチしています。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; {
            match second_number_str.parse::&lt;i32&gt;() {
                Ok(second_number)  =&gt; {
                    Ok(first_number * second_number)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // これはまだ使えます。
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // これは有用なエラーメッセージを返すようになりました。
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<p>幸運なことに、<code>Option</code>の<code>map</code>や<code>and_then</code>などのコンビネータは<code>Result</code>にも
実装されています。<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>に完全な一覧があります。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// `Option`のように、`map()`コンビネータが使えます。
// この関数は上と同じ動作をします。
// 値が有効な場合nを渡し、その他の場合はエラーを渡す。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // これはまだ使えます。
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // これは有用なエラーメッセージを返すようになりました。
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<h1><a class="header" href="#resultのエイリアス" id="resultのエイリアス"><code>Result</code>のエイリアス</a></h1>
<p>特定の<code>Result</code>型を何回も使い回すときはどうでしょう?
前に言ったようにRustでは<a href="error/result/../../types/alias.html">型エイリアス</a>が使えるため、
特定の<code>Result</code>型を再定義することができます。</p>
<p>モジュールレベルで型エイリアスを作ると非常に便利です。特定のモジュールでは
同じ<code>Err</code>型を使うことが多いからです。これによって<em>すべて</em>の関連した<code>Result</code>
に一つの型エイリアスを使うことができます。<code>std</code>ライブラリもこのような型<a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code>
</a>を定義しています!</p>
<p>これは構文を紹介するための簡単な例です。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// `ParseIntError`を持つ`Result`型のジェネリックなエイリアス
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// 特定のエラー型を持つ`Result`型を使ってみましょう。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

// ここでコード量を節約できます。
fn print(result: AliasedResult&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-59" id="こちらも参照-59">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a></li>
</ul>
<h1><a class="header" href="#早期のリターン" id="早期のリターン">早期のリターン</a></h1>
<p>前の例で、コンビネータを使って明示的にエラーを処理していました。
もう一つの方法は、<code>match</code>文と<em>早期のリターン</em>を組み合わせて使うことです。</p>
<p>つまり、単純に一つエラーが起こればそこでエラーを返すということです。
しばしば、この方が読みやすく、書きやすいコードになります。早期のリターン
を使って前の例を書き直しました。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; first_number,
        Err(e) =&gt; return Err(e),
    };

    let second_number = match second_number_str.parse::&lt;i32&gt;() {
        Ok(second_number)  =&gt; second_number,
        Err(e) =&gt; return Err(e),
    };

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<p>ここまでで、コンビネータや早期のリターンを使って、明示的にエラーを処理する方法を
見てきました。しかし、パニックを避け、明示的にすべてのエラーを処理するのは面倒です。</p>
<p>次の節では、<code>unwrap</code>のようにシンプルに、しかし<code>panic</code>をせずにエラーを処理する<code>?</code>
を導入します。</p>
<h1><a class="header" href="#の導入" id="の導入"><code>?</code>の導入</a></h1>
<p>時々、<code>panic</code>なしに、<code>unwrap</code>のような単純さが欲しくなることがあります。
今まで、変数を取得するためだけに、ますます深くネストすることが必要でした。
これをなくすのが<code>?</code>の目的です。</p>
<p><code>Err</code>を見つけると、このような挙動を取ることができます。</p>
<ol>
<li><code>panic!</code>。これはできるだけ避けるべきです。</li>
<li><code>return</code>。<code>Err</code>は処理できないことを意味するため、<code>return</code>する。</li>
</ol>
<p><code>?</code>は<em>ほとんど</em><sup class="footnote-reference"><a href="#†">1</a></sup> <code>unwrap</code>の<code>panic</code>を<code>return</code>に変えたもとと等価です。
先程の例がどれだけシンプルになるか見てみましょう。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = first_number_str.parse::&lt;i32&gt;()?;
    let second_number = second_number_str.parse::&lt;i32&gt;()?;

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h2><a class="header" href="#tryマクロ" id="tryマクロ"><code>try!</code>マクロ</a></h2>
<p><code>?</code>がなかった頃、同じ機能を<code>try!</code>マクロが持っていました。現在は<code>?</code>演算子が推奨されていますが、
古いコードを見ていると、<code>try!</code>に遭遇するかもしれません。前の例と同じ<code>multiply</code>関数を<code>try!</code>で
実装してみます。</p>
<pre><pre class="playpen"><code class="language-rust editable">// この例を警告なしに実行するにはCargo.tomlの`[package]`節にある`edition`フィールドを
// &quot;2015&quot;に変更する必要があります。

use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = try!(first_number_str.parse::&lt;i32&gt;());
    let second_number = try!(second_number_str.parse::&lt;i32&gt;());

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<div class="footnote-definition" id="†"><sup class="footnote-definition-label">1</sup>
<p>詳しくは<a href="error/result/../multiple_error_types/reenter_question_mark.html">他の?の使い方</a>を参照してください。</p>
</div>
<h1><a class="header" href="#複数のエラー型" id="複数のエラー型">複数のエラー型</a></h1>
<p><code>Result</code>が他の<code>Result</code>と、<code>Option</code>が他の<code>Option</code>と連携が取れるため、
前の例は非常に便利でした。</p>
<p>さて、時々<code>Option</code>と<code>Result</code>、<code>Result&lt;T, Error1&gt;</code>と<code>Result&lt;T, Error2&gt;</code>の間で
連携を取る必要があるときがあります。この場合、異なるエラー型を簡単で構成可能
に管理する必要があります。</p>
<p>以下のコードでは、<code>Vec::first</code>は<code>Option</code>を、<code>parse::&lt;i32&gt;</code>は<code>Result&lt;i32, ParseIntError&gt;</code>
を返すため、2つの<code>unwrap</code>がそれぞれ異なるエラーを処理しています。</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // Generate error 1
    2 * first.parse::&lt;i32&gt;().unwrap() // Generate error 2
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {}&quot;, double_first(empty));
    // エラー1: 入力ベクターが空です。

    println!(&quot;The first doubled is {}&quot;, double_first(strings));
    // エラー2: 入力を数値に変換できません。
}
</code></pre></pre>
<p>次の節から、このような問題を処理するいくつかの方法を見ていきます。</p>
<h1><a class="header" href="#resultをoptionから引き出す" id="resultをoptionから引き出す"><code>Result</code>を<code>Option</code>から引き出す</a></h1>
<p>この問題の最も簡単な解決策は、どちらかがもう片方を埋め込むことです。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Option&lt;Result&lt;i32, ParseIntError&gt;&gt; {
    vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    })
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    // エラー1: 入力ベクターが空です

    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
    // エラー2: 入力を数値に変換できません
}
</code></pre></pre>
<p>エラーが起きた時に途中で処理を止めたい場合(<a href="error/multiple_error_types/../result/enter_question_mark.html"><code>?</code></a>などを使って)
<code>Option</code>はそのまま<code>None</code>を返します。 コンビネータが<code>Result</code>と<code>Option</code>を入れ替えるのに
役立ちます。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;Option&lt;i32&gt;, ParseIntError&gt; {
    let opt = vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    });

    opt.map_or(Ok(None), |r| r.map(Some))
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));
    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
}
</code></pre></pre>
<h1><a class="header" href="#エラー型を定義する" id="エラー型を定義する">エラー型を定義する</a></h1>
<p>すべてのエラー型を一つの型で包んだ方がシンプルな場合もあります。
今回は、これを独自のエラーでやってみることにします。</p>
<p>Rustでは独自のエラー型を作成することができます。 一般的に、「良い」エラー型は:</p>
<ul>
<li>異なるエラーを同じ型で表す</li>
<li>わかりやすいエラーメッセージを提供する</li>
<li>他の型と比較しやすい
<ul>
<li>良い例: <code>Err(EmptyVec)</code></li>
<li>悪い例: <code>Err(&quot;Please use a vector with at least one element&quot;.to_owned())</code></li>
</ul>
</li>
<li>エラーについての情報を保持する
<ul>
<li>良い例: <code>Err(BadChar(c, position))</code></li>
<li>悪い例: <code>Err(&quot;+ cannot be used here&quot;.to_owned())</code></li>
</ul>
</li>
<li>他のエラーと連携が取れる</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

// 独自のエラー型を定義する。これはエラー処理の方法によってカスタマイズできる。
// ここで独自のエラーを起こしたり、下層のエラー実装を持ち越したり、その間で
// なにか処理をしたりすることができる。
#[derive(Debug, Clone)]
struct DoubleError;

// エラーの生成とどのようにそれが出力されるかということとは関係ありません。
// なので、出力のスタイルに複雑で乱雑なロジックを書く必要はありません。
//
// ここにはエラーに関するどんなデータも含まれていないことに注意してください。これは、
// どの処理が失敗したのかを知ることはできないということを意味します。
impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        // エラーを独自の新しい型に変換します。
        .ok_or(DoubleError)
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                // ここも新しい型に変換します。
                .map_err(|_| DoubleError)
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<h1><a class="header" href="#エラーをboxに入れる" id="エラーをboxに入れる">エラーを<code>Box</code>に入れる</a></h1>
<p>シンプルなコードを書くために、<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>にエラーデータの参照を入れることもできます。
欠点は、実行時にしかエラー型がわからず、<a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">静的に決定</a>できないことです。</p>
<p>標準ライブラリは、<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>で、トレイトオブジェクト<code>Box&lt;Error&gt;</code>を<code>Error</code>トレイト
を実装したすべての型に変換する実装を提供しています。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::fmt;

// エイリアスを`Box&lt;error::Error&gt;`に変更する
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        .ok_or_else(|| EmptyVec.into()) // Converts to Box
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                .map_err(|e| e.into()) // Converts to Box
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<h3><a class="header" href="#こちらも参照-60" id="こちらも参照-60">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">動的ディスパッチ</a></li>
<li><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code>トレイト</a></li>
</ul>
<h1><a class="header" href="#の他の使い方" id="の他の使い方"><code>?</code>の他の使い方</a></h1>
<p>前の例では、<code>parse</code>を即座に<code>map</code>に渡して、エラーを<code>Box</code>に格納していました。</p>
<pre><code class="language-rust ignore">.and_then(|s| s.parse::&lt;i32&gt;()
    .map_err(|e| e.into())
</code></pre>
<p>これは一般的な操作なので、利便性のため省略することができます。
悲しいかな、<code>and_then</code>は柔軟性が低いため、できません。しかし、
<code>?</code>を使えばできます。</p>
<p><code>?</code>は<code>unwrap</code>や<code>return Err(err)</code>と同じだと説明しました。これは大体合って
いますが、実際には<code>unwrap</code>や<code>return Err(From::from(err))</code>です。
<code>From::from</code>は他の型に変更するツールであるため、これは<code>?</code>によって返り値の型
に変換できることを意味しています。</p>
<p>ここで、前の例を<code>?</code>を使って書き直してみましょう。結果的に、<code>map_err</code>は
<code>From::from</code>がエラー型に実装されていることから不要になります。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::fmt;

// エイリアスを`Box&lt;dyn error::Error&gt;`に変更します。
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {}

// 前と同じ構造ですが、すべての`Results`と`Options`を一つにつながず、
// `?`から値を変数に代入しています。
fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;
    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>これで非常にきれいになりました。もともとの<code>panic</code>と比べると、返り値の型が
<code>Result</code>担ったことを除いて、<code>unwrap</code>が<code>?</code>に変わっただけであることがわかります。
また、<code>Result</code>はトップレベルで分解する必要があります。</p>
<h3><a class="header" href="#こちらも参照-61" id="こちらも参照-61">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a></li>
<li><a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator"><code>?</code></a></li>
</ul>
<h1><a class="header" href="#エラーをラップする" id="エラーをラップする">エラーをラップする</a></h1>
<p>複数のエラーをボックス化するもう一つの方法は、独自の型でエラーを
ラップすることです。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // 変換エラーに関する実装を持ち越します。
    // さらなる情報を得るため、型にデータを追加します。
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;please use a vector with at least one element&quot;),
            // これはラッパーであるため、元の型の関数を呼び出します。
            DoubleError::Parse(ref e) =&gt; e.fmt(f),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // 下層の実装のエラー型を返します。トレイとオブジェクトは暗示的に
            // `&amp;error::Error`にキャストされます。下層の実装はすでに`Error`
            // トレイトを実装しているため、これは動作します。
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// `ParseIntError`から`DoubleError`への変換を実装する。
// `?`から呼び出されたときに`ParseIntError`を
// `DoubleError`に変換するのに使われる。
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>これは少し典型コードが多くなる上、すべてのアプリケーションに必要となるわけではありません。
個の典型コードを少なくするためのライブラリがいくつかあります。</p>
<h3><a class="header" href="#こちらも参照-62" id="こちらも参照-62">こちらも参照:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a></li>
<li><a href="error/multiple_error_types/../../custom_types/enum.html"><code>Enums</code></a></li>
</ul>
<h1><a class="header" href="#resultを繰り返す" id="resultを繰り返す"><code>Result</code>を繰り返す</a></h1>
<p><code>Iter::map</code>は失敗する可能性があります。例えば:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>これを処理する方法を見ていきましょう。</p>
<h2><a class="header" href="#filter_mapで失敗したものを無視する" id="filter_mapで失敗したものを無視する"><code>filter_map()</code>で失敗したものを無視する</a></h2>
<p><code>filter_map</code>は<code>None</code>である結果をフィルタにかける。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .filter_map(Result::ok)
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<h2><a class="header" href="#collectでコードを失敗にする" id="collectでコードを失敗にする"><code>collect()</code>でコードを失敗にする</a></h2>
<p><code>Result</code>は<code>FromIter</code>を実装しているため、<code>Result</code>型のベクター(<code>Vec&lt;Result&lt;T, E&gt;&gt;</code>)
をベクター型の<code>Result</code>(<code>Result&lt;Vec&lt;T&gt;, E&gt;</code>)に変換することができます。
そして、<code>Result::Err</code>が見つかれば処理を終了できます。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p><code>Option</code>でも同じことができます。</p>
<h2><a class="header" href="#すべての利用可能な値を集めてpartitionで失敗を振り分ける" id="すべての利用可能な値を集めてpartitionで失敗を振り分ける">すべての利用可能な値を集めて<code>partition()</code>で失敗を振り分ける。</a></h2>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<p>結果を見たら、これがまだ<code>Result</code>で包まれていることに気付くでしょう。
もう少し典型コードが必要です。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<h1><a class="header" href="#std-library-types" id="std-library-types">Std library types</a></h1>
<p>The <code>std</code> library provides many custom types which expands drastically on
the <code>primitives</code>. Some of these include:</p>
<ul>
<li>growable <code>String</code>s like: <code>&quot;hello world&quot;</code></li>
<li>growable vectors: <code>[1, 2, 3]</code></li>
<li>optional types: <code>Option&lt;i32&gt;</code></li>
<li>error handling types: <code>Result&lt;i32, i32&gt;</code></li>
<li>heap allocated pointers: <code>Box&lt;i32&gt;</code></li>
</ul>
<h3><a class="header" href="#see-also-1" id="see-also-1">See also:</a></h3>
<p><a href="primitives.html">primitives</a> and <a href="https://doc.rust-lang.org/std/">the std library</a></p>
<h1><a class="header" href="#box-stack-and-heap" id="box-stack-and-heap">Box, stack and heap</a></h1>
<p>All values in Rust are stack allocated by default. Values can be <em>boxed</em>
(allocated on the heap) by creating a <code>Box&lt;T&gt;</code>. A box is a smart pointer to a
heap allocated value of type <code>T</code>. When a box goes out of scope, its destructor
is called, the inner object is destroyed, and the memory on the heap is freed.</p>
<p>Boxed values can be dereferenced using the <code>*</code> operator; this removes one layer
of indirection. </p>
<pre><pre class="playpen"><code class="language-rust editable">use std::mem;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

// A Rectangle can be specified by where its top left and bottom right 
// corners are in space
#[allow(dead_code)]
struct Rectangle {
    top_left: Point,
    bottom_right: Point,
}

fn origin() -&gt; Point {
    Point { x: 0.0, y: 0.0 }
}

fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // Allocate this point on the heap, and return a pointer to it
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() {
    // (all the type annotations are superfluous)
    // Stack allocated variables
    let point: Point = origin();
    let rectangle: Rectangle = Rectangle {
        top_left: origin(),
        bottom_right: Point { x: 3.0, y: -4.0 }
    };

    // Heap allocated rectangle
    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
        top_left: origin(),
        bottom_right: Point { x: 3.0, y: -4.0 },
    });

    // The output of functions can be boxed
    let boxed_point: Box&lt;Point&gt; = Box::new(origin());

    // Double indirection
    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

    println!(&quot;Point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;point));
    println!(&quot;Rectangle occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;rectangle));

    // box size == pointer size
    println!(&quot;Boxed point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;boxed_point));
    println!(&quot;Boxed rectangle occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;boxed_rectangle));
    println!(&quot;Boxed box occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;box_in_a_box));

    // Copy the data contained in `boxed_point` into `unboxed_point`
    let unboxed_point: Point = *boxed_point;
    println!(&quot;Unboxed point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;unboxed_point));
}
</code></pre></pre>
<h1><a class="header" href="#vectors" id="vectors">Vectors</a></h1>
<p>Vectors are re-sizable arrays. Like slices, their size is not known at compile
time, but they can grow or shrink at any time. A vector is represented using
3 parameters: </p>
<ul>
<li>pointer to the data</li>
<li>length</li>
<li>capacity </li>
</ul>
<p>The capacity indicates how much memory is reserved for the vector. The vector 
can grow as long as the length is smaller than the capacity. When this threshold 
needs to be surpassed, the vector is reallocated with a larger capacity.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Iterators can be collected into vectors
    let collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!(&quot;Collected (0..10) into: {:?}&quot;, collected_iterator);

    // The `vec!` macro can be used to initialize a vector
    let mut xs = vec![1i32, 2, 3];
    println!(&quot;Initial vector: {:?}&quot;, xs);

    // Insert new element at the end of the vector
    println!(&quot;Push 4 into the vector&quot;);
    xs.push(4);
    println!(&quot;Vector: {:?}&quot;, xs);

    // Error! Immutable vectors can't grow
    collected_iterator.push(0);
    // FIXME ^ Comment out this line

    // The `len` method yields the number of elements currently stored in a vector
    println!(&quot;Vector length: {}&quot;, xs.len());

    // Indexing is done using the square brackets (indexing starts at 0)
    println!(&quot;Second element: {}&quot;, xs[1]);

    // `pop` removes the last element from the vector and returns it
    println!(&quot;Pop last element: {:?}&quot;, xs.pop());

    // Out of bounds indexing yields a panic
    println!(&quot;Fourth element: {}&quot;, xs[3]);
    // FIXME ^ Comment out this line

    // `Vector`s can be easily iterated over
    println!(&quot;Contents of xs:&quot;);
    for x in xs.iter() {
        println!(&quot;&gt; {}&quot;, x);
    }

    // A `Vector` can also be iterated over while the iteration
    // count is enumerated in a separate variable (`i`)
    for (i, x) in xs.iter().enumerate() {
        println!(&quot;In position {} we have value {}&quot;, i, x);
    }

    // Thanks to `iter_mut`, mutable `Vector`s can also be iterated
    // over in a way that allows modifying each value
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!(&quot;Updated vector: {:?}&quot;, xs);
}
</code></pre></pre>
<p>More <code>Vec</code> methods can be found under the
<a href="https://doc.rust-lang.org/std/vec/">std::vec</a> module</p>
<h1><a class="header" href="#strings" id="strings">Strings</a></h1>
<p>There are two types of strings in Rust: <code>String</code> and <code>&amp;str</code>.</p>
<p>A <code>String</code> is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>), but guaranteed to
always be a valid UTF-8 sequence. <code>String</code> is heap allocated, growable and not
null terminated.</p>
<p><code>&amp;str</code> is a slice (<code>&amp;[u8]</code>) that always points to a valid UTF-8 sequence, and
can be used to view into a <code>String</code>, just like <code>&amp;[T]</code> is a view into <code>Vec&lt;T&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // (all the type annotations are superfluous)
    // A reference to a string allocated in read only memory
    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
    println!(&quot;Pangram: {}&quot;, pangram);

    // Iterate over words in reverse, no new string is allocated
    println!(&quot;Words in reverse&quot;);
    for word in pangram.split_whitespace().rev() {
        println!(&quot;&gt; {}&quot;, word);
    }

    // Copy chars into a vector, sort and remove duplicates
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // Create an empty and growable `String`
    let mut string = String::new();
    for c in chars {
        // Insert a char at the end of string
        string.push(c);
        // Insert a string at the end of string
        string.push_str(&quot;, &quot;);
    }

    // The trimmed string is a slice to the original string, hence no new
    // allocation is performed
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!(&quot;Used characters: {}&quot;, trimmed_str);

    // Heap allocate a string
    let alice = String::from(&quot;I like dogs&quot;);
    // Allocate new memory and store the modified string there
    let bob: String = alice.replace(&quot;dog&quot;, &quot;cat&quot;);

    println!(&quot;Alice says: {}&quot;, alice);
    println!(&quot;Bob says: {}&quot;, bob);
}
</code></pre></pre>
<p>More <code>str</code>/<code>String</code> methods can be found under the
<a href="https://doc.rust-lang.org/std/str/">std::str</a> and
<a href="https://doc.rust-lang.org/std/string/">std::string</a>
modules</p>
<h2><a class="header" href="#literals-and-escapes" id="literals-and-escapes">Literals and escapes</a></h2>
<p>There are multiple ways to write string literals with special characters in them.
All result in a similar <code>&amp;str</code> so it's best to use the form that is the most
convenient to write. Similarly there are multiple ways to write byte string literals,
which all result in <code>&amp;[u8; N]</code>.</p>
<p>Generally special characters are escaped with a backslash character: <code>\</code>.
This way you can add any character to your string, even unprintable ones
and ones that you don't know how to type. If you want a literal backslash,
escape it with another one: <code>\\</code></p>
<p>String or character literal delimiters occuring within a literal must be escaped: <code>&quot;\&quot;&quot;</code>, <code>'\''</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // You can use escapes to write bytes by their hexadecimal values...
    let byte_escape = &quot;I'm writing \x52\x75\x73\x74!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // ...or Unicode code points.
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );


    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<p>Sometimes there are just too many characters that need to be escaped or it's just
much more convenient to write a string out as-is. This is where raw string literals come into play.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    println!(&quot;{}&quot;, raw_str);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // If you need &quot;# in your string, just use more #s in the delimiter.
    // There is no limit for the number of #s you can use.
    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, longer_delimiter);
}
</code></pre></pre>
<p>Want a string that's not UTF-8? (Remember, <code>str</code> and <code>String</code> must be valid UTF-8).
Or maybe you want an array of bytes that's mostly text? Byte strings to the rescue!</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::str;

fn main() {
    // Note that this is not actually a `&amp;str`
    let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;;

    // Byte arrays don't have the `Display` trait, so printing them is a bit limited
    println!(&quot;A byte string: {:?}&quot;, bytestring);

    // Byte strings can have byte escapes...
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...but no unicode escapes
    // let escaped = b&quot;\u{211D} is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // Raw byte strings work just like raw strings
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // Converting a byte array to `str` can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // Byte strings don't have to be UTF-8
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;; // &quot;ようこそ&quot; in SHIFT-JIS

    // But then they can't always be converted to `str`
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}
</code></pre></pre>
<p>For conversions between character encodings check out the <a href="https://crates.io/crates/encoding">encoding</a> crate.</p>
<p>A more detailed listing of the ways to write string literals and escape characters
is given in the <a href="https://doc.rust-lang.org/reference/tokens.html">'Tokens' chapter</a> of the Rust Reference.</p>
<h1><a class="header" href="#option" id="option"><code>Option</code></a></h1>
<p>Sometimes it's desirable to catch the failure of some parts of a program
instead of calling <code>panic!</code>; this can be accomplished using the <code>Option</code> enum.</p>
<p>The <code>Option&lt;T&gt;</code> enum has two variants:</p>
<ul>
<li><code>None</code>, to indicate failure or lack of value, and</li>
<li><code>Some(value)</code>, a tuple struct that wraps a <code>value</code> with type <code>T</code>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// An integer division that doesn't `panic!`
fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor == 0 {
        // Failure is represented as the `None` variant
        None
    } else {
        // Result is wrapped in a `Some` variant
        Some(dividend / divisor)
    }
}

// This function handles a division that may not succeed
fn try_division(dividend: i32, divisor: i32) {
    // `Option` values can be pattern matched, just like other enums
    match checked_division(dividend, divisor) {
        None =&gt; println!(&quot;{} / {} failed!&quot;, dividend, divisor),
        Some(quotient) =&gt; {
            println!(&quot;{} / {} = {}&quot;, dividend, divisor, quotient)
        },
    }
}

fn main() {
    try_division(4, 2);
    try_division(1, 0);

    // Binding `None` to a variable needs to be type annotated
    let none: Option&lt;i32&gt; = None;
    let _equivalent_none = None::&lt;i32&gt;;

    let optional_float = Some(0f32);

    // Unwrapping a `Some` variant will extract the value wrapped.
    println!(&quot;{:?} unwraps to {:?}&quot;, optional_float, optional_float.unwrap());

    // Unwrapping a `None` variant will `panic!`
    println!(&quot;{:?} unwraps to {:?}&quot;, none, none.unwrap());
}
</code></pre></pre>
<h1><a class="header" href="#result-1" id="result-1"><code>Result</code></a></h1>
<p>We've seen that the <code>Option</code> enum can be used as a return value from functions
that may fail, where <code>None</code> can be returned to indicate failure. However,
sometimes it is important to express <em>why</em> an operation failed. To do this we 
have the <code>Result</code> enum.</p>
<p>The <code>Result&lt;T, E&gt;</code> enum has two variants:</p>
<ul>
<li><code>Ok(value)</code> which indicates that the operation succeeded, and wraps the
<code>value</code> returned by the operation. (<code>value</code> has type <code>T</code>)</li>
<li><code>Err(why)</code>, which indicates that the operation failed, and wraps <code>why</code>,
which (hopefully) explains the cause of the failure. (<code>why</code> has type <code>E</code>)</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    // Mathematical &quot;errors&quot; we want to catch
    #[derive(Debug)]
    pub enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    pub type MathResult = Result&lt;f64, MathError&gt;;

    pub fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            // This operation would `fail`, instead let's return the reason of
            // the failure wrapped in `Err`
            Err(MathError::DivisionByZero)
        } else {
            // This operation is valid, return the result wrapped in `Ok`
            Ok(x / y)
        }
    }

    pub fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    pub fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }
}

// `op(x, y)` === `sqrt(ln(x / y))`
fn op(x: f64, y: f64) -&gt; f64 {
    // This is a three level match pyramid!
    match checked::div(x, y) {
        Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
        Ok(ratio) =&gt; match checked::ln(ratio) {
            Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
            Ok(ln) =&gt; match checked::sqrt(ln) {
                Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
                Ok(sqrt) =&gt; sqrt,
            },
        },
    }
}

fn main() {
    // Will this fail?
    println!(&quot;{}&quot;, op(1.0, 10.0));
}
</code></pre></pre>
<h1><a class="header" href="#" id=""><code>?</code></a></h1>
<p>Chaining results using match can get pretty untidy; luckily, the <code>?</code> operator
can be used to make things pretty again. <code>?</code> is used at the end of an expression
returning a <code>Result</code>, and is equivalent to a match expression, where the 
<code>Err(err)</code> branch expands to an early <code>Err(From::from(err))</code>, and the <code>Ok(ok)</code>
branch expands to an <code>ok</code> expression.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    type MathResult = Result&lt;f64, MathError&gt;;

    fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(x / y)
        }
    }

    fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }

    // Intermediate function
    fn op_(x: f64, y: f64) -&gt; MathResult {
        // if `div` &quot;fails&quot;, then `DivisionByZero` will be `return`ed
        let ratio = div(x, y)?;

        // if `ln` &quot;fails&quot;, then `NonPositiveLogarithm` will be `return`ed
        let ln = ln(ratio)?;

        sqrt(ln)
    }

    pub fn op(x: f64, y: f64) {
        match op_(x, y) {
            Err(why) =&gt; panic!(match why {
                MathError::NonPositiveLogarithm
                    =&gt; &quot;logarithm of non-positive number&quot;,
                MathError::DivisionByZero
                    =&gt; &quot;division by zero&quot;,
                MathError::NegativeSquareRoot
                    =&gt; &quot;square root of negative number&quot;,
            }),
            Ok(value) =&gt; println!(&quot;{}&quot;, value),
        }
    }
}

fn main() {
    checked::op(1.0, 10.0);
}
</code></pre></pre>
<p>Be sure to check the <a href="https://doc.rust-lang.org/std/result/index.html">documentation</a>,
as there are many methods to map/compose <code>Result</code>.</p>
<h1><a class="header" href="#panic-1" id="panic-1"><code>panic!</code></a></h1>
<p>The <code>panic!</code> macro can be used to generate a panic and start unwinding
its stack. While unwinding, the runtime will take care of freeing all the
resources <em>owned</em> by the thread by calling the destructor of all its objects.</p>
<p>Since we are dealing with programs with only one thread, <code>panic!</code> will cause the
program to report the panic message and exit.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Re-implementation of integer division (/)
fn division(dividend: i32, divisor: i32) -&gt; i32 {
    if divisor == 0 {
        // Division by zero triggers a panic
        panic!(&quot;division by zero&quot;);
    } else {
        dividend / divisor
    }
}

// The `main` task
fn main() {
    // Heap allocated integer
    let _x = Box::new(0i32);

    // This operation will trigger a task failure
    division(3, 0);

    println!(&quot;This point won't be reached!&quot;);

    // `_x` should get destroyed at this point
}
</code></pre></pre>
<p>Let's check that <code>panic!</code> doesn't leak memory.</p>
<pre><code class="language-shell">$ rustc panic.rs &amp;&amp; valgrind ./panic
==4401== Memcheck, a memory error detector
==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==4401== Command: ./panic
==4401== 
thread '&lt;main&gt;' panicked at 'division by zero', panic.rs:5
==4401== 
==4401== HEAP SUMMARY:
==4401==     in use at exit: 0 bytes in 0 blocks
==4401==   total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated
==4401== 
==4401== All heap blocks were freed -- no leaks are possible
==4401== 
==4401== For counts of detected and suppressed errors, rerun with: -v
==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<h1><a class="header" href="#hashmap" id="hashmap">HashMap</a></h1>
<p>Where vectors store values by an integer index, <code>HashMap</code>s store values by key. 
<code>HashMap</code> keys can be booleans, integers, strings, 
or any other type that implements the <code>Eq</code> and <code>Hash</code> traits. 
More on this in the next section.</p>
<p>Like vectors, <code>HashMap</code>s are growable, but HashMaps can also shrink themselves 
when they have excess space. 
You can create a HashMap with a certain starting capacity using 
<code>HashMap::with_capacity(uint)</code>, or use <code>HashMap::new()</code> to get a HashMap 
with a default initial capacity (recommended).</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;

fn call(number: &amp;str) -&gt; &amp;str {
    match number {
        &quot;798-1364&quot; =&gt; &quot;We're sorry, the call cannot be completed as dialed. 
            Please hang up and try again.&quot;,
        &quot;645-7689&quot; =&gt; &quot;Hello, this is Mr. Awesome's Pizza. My name is Fred.
            What can I get for you today?&quot;,
        _ =&gt; &quot;Hi! Who is this again?&quot;
    }
}

fn main() { 
    let mut contacts = HashMap::new();

    contacts.insert(&quot;Daniel&quot;, &quot;798-1364&quot;);
    contacts.insert(&quot;Ashley&quot;, &quot;645-7689&quot;);
    contacts.insert(&quot;Katie&quot;, &quot;435-8291&quot;);
    contacts.insert(&quot;Robert&quot;, &quot;956-1745&quot;);

    // Takes a reference and returns Option&lt;&amp;V&gt;
    match contacts.get(&amp;&quot;Daniel&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Daniel: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Daniel's number.&quot;),
    }

    // `HashMap::insert()` returns `None`
    // if the inserted value is new, `Some(value)` otherwise
    contacts.insert(&quot;Daniel&quot;, &quot;164-6743&quot;);

    match contacts.get(&amp;&quot;Ashley&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Ashley: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Ashley's number.&quot;),
    }

    contacts.remove(&amp;&quot;Ashley&quot;); 

    // `HashMap::iter()` returns an iterator that yields 
    // (&amp;'a key, &amp;'a value) pairs in arbitrary order.
    for (contact, &amp;number) in contacts.iter() {
        println!(&quot;Calling {}: {}&quot;, contact, call(number)); 
    }
}
</code></pre></pre>
<p>For more information on how hashing and hash maps 
(sometimes called hash tables) work, have a look at 
<a href="https://en.wikipedia.org/wiki/Hash_table">Hash Table Wikipedia</a></p>
<h1><a class="header" href="#alternatecustom-key-types" id="alternatecustom-key-types">Alternate/custom key types</a></h1>
<p>Any type that implements the <code>Eq</code> and <code>Hash</code> traits can be a key in <code>HashMap</code>. 
This includes:</p>
<ul>
<li><code>bool</code> (though not very useful since there is only two possible keys)</li>
<li><code>int</code>, <code>uint</code>, and all variations thereof</li>
<li><code>String</code> and <code>&amp;str</code> (protip: you can have a <code>HashMap</code> keyed by <code>String</code>
and call <code>.get()</code> with an <code>&amp;str</code>)</li>
</ul>
<p>Note that <code>f32</code> and <code>f64</code> do <em>not</em> implement <code>Hash</code>,
likely because <a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">floating-point precision errors</a>
would make using them as hashmap keys horribly error-prone.</p>
<p>All collection classes implement <code>Eq</code> and <code>Hash</code> 
if their contained type also respectively implements <code>Eq</code> and <code>Hash</code>. 
For example, <code>Vec&lt;T&gt;</code> will implement <code>Hash</code> if <code>T</code> implements <code>Hash</code>.</p>
<p>You can easily implement <code>Eq</code> and <code>Hash</code> for a custom type with just one line: 
<code>#[derive(PartialEq, Eq, Hash)]</code></p>
<p>The compiler will do the rest. If you want more control over the details, 
you can implement <code>Eq</code> and/or <code>Hash</code> yourself. 
This guide will not cover the specifics of implementing <code>Hash</code>. </p>
<p>To play around with using a <code>struct</code> in <code>HashMap</code>, 
let's try making a very simple user logon system:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;

// Eq requires that you derive PartialEq on the type.
#[derive(PartialEq, Eq, Hash)]
struct Account&lt;'a&gt;{
    username: &amp;'a str,
    password: &amp;'a str,
}

struct AccountInfo&lt;'a&gt;{
    name: &amp;'a str,
    email: &amp;'a str,
}

type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;

fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
        username: &amp;'a str, password: &amp;'a str){
    println!(&quot;Username: {}&quot;, username);
    println!(&quot;Password: {}&quot;, password);
    println!(&quot;Attempting logon...&quot;);

    let logon = Account {
        username,
        password,
    };

    match accounts.get(&amp;logon) {
        Some(account_info) =&gt; {
            println!(&quot;Successful logon!&quot;);
            println!(&quot;Name: {}&quot;, account_info.name);
            println!(&quot;Email: {}&quot;, account_info.email);
        },
        _ =&gt; println!(&quot;Login failed!&quot;),
    }
}

fn main(){
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: &quot;j.everyman&quot;,
        password: &quot;password123&quot;,
    };

    let account_info = AccountInfo {
        name: &quot;John Everyman&quot;,
        email: &quot;j.everyman@email.com&quot;,
    };

    accounts.insert(account, account_info);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;psasword123&quot;);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;password123&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#hashset" id="hashset">HashSet</a></h1>
<p>Consider a <code>HashSet</code> as a <code>HashMap</code> where we just care about the keys (
<code>HashSet&lt;T&gt;</code> is, in actuality, just a wrapper around <code>HashMap&lt;T, ()&gt;</code>).</p>
<p>&quot;What's the point of that?&quot; you ask. &quot;I could just store the keys in a <code>Vec</code>.&quot;</p>
<p>A <code>HashSet</code>'s unique feature is that 
it is guaranteed to not have duplicate elements. 
That's the contract that any set collection fulfills. 
<code>HashSet</code> is just one implementation. (see also: <a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a>)</p>
<p>If you insert a value that is already present in the <code>HashSet</code>, 
(i.e. the new value is equal to the existing and they both have the same hash), 
then the new value will replace the old.</p>
<p>This is great for when you never want more than one of something, 
or when you want to know if you've already got something.</p>
<p>But sets can do more than that. </p>
<p>Sets have 4 primary operations (all of the following calls return an iterator):</p>
<ul>
<li>
<p><code>union</code>: get all the unique elements in both sets.</p>
</li>
<li>
<p><code>difference</code>: get all the elements that are in the first set but not the second.</p>
</li>
<li>
<p><code>intersection</code>: get all the elements that are only in <em>both</em> sets.</p>
</li>
<li>
<p><code>symmetric_difference</code>: 
get all the elements that are in one set or the other, but <em>not</em> both.</p>
</li>
</ul>
<p>Try all of these in the following example:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">use std::collections::HashSet;

fn main() {
    let mut a: HashSet&lt;i32&gt; = vec![1i32, 2, 3].into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec![2i32, 3, 4].into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&amp;4));

    // `HashSet::insert()` returns false if
    // there was a value already present.
    assert!(b.insert(4), &quot;Value 4 is already in set B!&quot;);
    // FIXME ^ Comment out this line

    b.insert(5);

    // If a collection's element type implements `Debug`,
    // then the collection implements `Debug`.
    // It usually prints its elements in the format `[elem1, elem2, ...]`
    println!(&quot;A: {:?}&quot;, a);
    println!(&quot;B: {:?}&quot;, b);

    // Print [1, 2, 3, 4, 5] in arbitrary order
    println!(&quot;Union: {:?}&quot;, a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // This should print [1]
    println!(&quot;Difference: {:?}&quot;, a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Print [2, 3, 4] in arbitrary order.
    println!(&quot;Intersection: {:?}&quot;, a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Print [1, 5]
    println!(&quot;Symmetric Difference: {:?}&quot;,
             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());
}
</code></pre></pre>
<p>(Examples are adapted from the <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.difference">documentation.</a>)</p>
<h1><a class="header" href="#rc" id="rc"><code>Rc</code></a></h1>
<p>When multiple ownership is needed, <code>Rc</code>(Reference Counting) can be used. <code>Rc</code> keeps track of the number of the references which means the number of owners of the value wrapped inside an <code>Rc</code>. </p>
<p>Reference count of an <code>Rc</code> increases by 1 whenever an <code>Rc</code> is cloned, and decreases by 1 whenever one cloned <code>Rc</code> is dropped out of the scope. When an <code>Rc</code>'s reference count becomes zero, which means there are no owners remained, both the <code>Rc</code> and the value are all dropped. </p>
<p>Cloning an <code>Rc</code> never do a deep copy. Cloning creates just another pointer to the wrapped value, and increments the count.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::rc::Rc;

fn main() {
    let rc_examples = &quot;Rc examples&quot;.to_string();
    {
        println!(&quot;--- rc_a is created ---&quot;);
        
        let rc_a: Rc&lt;String&gt; = Rc::new(rc_examples);
        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        {
            println!(&quot;--- rc_a is cloned to rc_b ---&quot;);
            
            let rc_b: Rc&lt;String&gt; = Rc::clone(&amp;rc_a);
            println!(&quot;Reference Count of rc_b: {}&quot;, Rc::strong_count(&amp;rc_b));
            println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
            
            // Two `Rc`s are equal if their inner values are equal
            println!(&quot;rc_a and rc_b are equal: {}&quot;, rc_a.eq(&amp;rc_b));
            
            // We can use methods of a value directly
            println!(&quot;Length of the value inside rc_a: {}&quot;, rc_a.len());
            println!(&quot;Value of rc_b: {}&quot;, rc_b);
            
            println!(&quot;--- rc_b is dropped out of scope ---&quot;);
        }
        
        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        println!(&quot;--- rc_a is dropped out of scope ---&quot;);
    }
    
    // Error! `rc_examples` already moved into `rc_a`
    // And when `rc_a` is dropped, `rc_examples` is dropped together
    // println!(&quot;rc_examples: {}&quot;, rc_examples);
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<h3><a class="header" href="#see-also-2" id="see-also-2">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/rc/index.html">std::rc</a> and <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a>.</p>
<h1><a class="header" href="#std-misc" id="std-misc">Std misc</a></h1>
<p>Many other types are provided by the std library to support
things such as:</p>
<ul>
<li>Threads</li>
<li>Channels</li>
<li>File I/O</li>
</ul>
<p>These expand beyond what the <a href="primitives.html">primitives</a> provide.</p>
<h3><a class="header" href="#see-also-3" id="see-also-3">See also:</a></h3>
<p><a href="primitives.html">primitives</a> and <a href="https://doc.rust-lang.org/std/">the std library</a></p>
<h1><a class="header" href="#threads" id="threads">Threads</a></h1>
<p>Rust provides a mechanism for spawning native OS threads via the <code>spawn</code>
function, the argument of this function is a moving closure.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::thread;

static NTHREADS: i32 = 10;

// This is the `main` thread
fn main() {
    // Make a vector to hold the children which are spawned.
    let mut children = vec![];

    for i in 0..NTHREADS {
        // Spin up another thread
        children.push(thread::spawn(move || {
            println!(&quot;this is thread number {}&quot;, i);
        }));
    }

    for child in children {
        // Wait for the thread to finish. Returns a result.
        let _ = child.join();
    }
}
</code></pre></pre>
<p>These threads will be scheduled by the OS.</p>
<h1><a class="header" href="#testcase-map-reduce" id="testcase-map-reduce">Testcase: map-reduce</a></h1>
<p>Rust makes it very easy to parallelise data processing, without many of the headaches traditionally associated with such an attempt.</p>
<p>The standard library provides great threading primitives out of the box.
These, combined with Rust's concept of Ownership and aliasing rules, automatically prevent
data races.</p>
<p>The aliasing rules (one writable reference XOR many readable references) automatically prevent
you from manipulating state that is visible to other threads. (Where synchronisation is needed,
there are synchronisation
primitives like <code>Mutex</code>es or <code>Channel</code>s.)</p>
<p>In this example, we will calculate the sum of all digits in a block of numbers.
We will do this by parcelling out chunks of the block into different threads. Each thread will sum
its tiny block of digits, and subsequently we will sum the intermediate sums produced by each
thread.</p>
<p>Note that, although we're passing references across thread boundaries, Rust understands that we're
only passing read-only references, and that thus no unsafety or data races can occur. Because
we're <code>move</code>-ing the data segments into the thread, Rust will also ensure the data is kept alive
until the threads exit, so no dangling pointers occur.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::thread;

// This is the `main` thread
fn main() {

    // This is our data to process.
    // We will calculate the sum of all digits via a threaded  map-reduce algorithm.
    // Each whitespace separated chunk will be handled in a different thread.
    //
    // TODO: see what happens to the output if you insert spaces!
    let data = &quot;86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668&quot;;

    // Make a vector to hold the child-threads which we will spawn.
    let mut children = vec![];

    /*************************************************************************
     * &quot;Map&quot; phase
     *
     * Divide our data into segments, and apply initial processing
     ************************************************************************/

    // split our data into segments for individual calculation
    // each chunk will be a reference (&amp;str) into the actual data
    let chunked_data = data.split_whitespace();

    // Iterate over the data segments.
    // .enumerate() adds the current loop index to whatever is iterated
    // the resulting tuple &quot;(index, element)&quot; is then immediately
    // &quot;destructured&quot; into two variables, &quot;i&quot; and &quot;data_segment&quot; with a
    // &quot;destructuring assignment&quot;
    for (i, data_segment) in chunked_data.enumerate() {
        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);

        // Process each data segment in a separate thread
        //
        // spawn() returns a handle to the new thread,
        // which we MUST keep to access the returned value
        //
        // 'move || -&gt; u32' is syntax for a closure that:
        // * takes no arguments ('||')
        // * takes ownership of its captured variables ('move') and
        // * returns an unsigned 32-bit integer ('-&gt; u32')
        //
        // Rust is smart enough to infer the '-&gt; u32' from
        // the closure itself so we could have left that out.
        //
        // TODO: try removing the 'move' and see what happens
        children.push(thread::spawn(move || -&gt; u32 {
            // Calculate the intermediate sum of this segment:
            let result = data_segment
                        // iterate over the characters of our segment..
                        .chars()
                        // .. convert text-characters to their number value..
                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))
                        // .. and sum the resulting iterator of numbers
                        .sum();

            // println! locks stdout, so no text-interleaving occurs
            println!(&quot;processed segment {}, result={}&quot;, i, result);

            // &quot;return&quot; not needed, because Rust is an &quot;expression language&quot;, the
            // last evaluated expression in each block is automatically its value.
            result

        }));
    }


    /*************************************************************************
     * &quot;Reduce&quot; phase
     *
     * Collect our intermediate results, and combine them into a final result
     ************************************************************************/

    // collect each thread's intermediate results into a new Vec
    let mut intermediate_sums = vec![];
    for child in children {
        // collect each child thread's return-value
        let intermediate_sum = child.join().unwrap();
        intermediate_sums.push(intermediate_sum);
    }

    // combine all intermediate sums into a single final sum.
    //
    // we use the &quot;turbofish&quot; ::&lt;&gt; to provide sum() with a type hint.
    //
    // TODO: try without the turbofish, by instead explicitly
    // specifying the type of final_result
    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();

    println!(&quot;Final sum result: {}&quot;, final_result);
}


</code></pre></pre>
<h3><a class="header" href="#assignments" id="assignments">Assignments</a></h3>
<p>It is not wise to let our number of threads depend on user inputted data.
What if the user decides to insert a lot of spaces? Do we <em>really</em> want to spawn 2,000 threads?
Modify the program so that the data is always chunked into a limited number of chunks,
defined by a static constant at the beginning of the program.</p>
<h3><a class="header" href="#see-also-4" id="see-also-4">See also:</a></h3>
<ul>
<li><a href="std_misc/threads/../threads.html">Threads</a></li>
<li><a href="std_misc/threads/../../std/vec.html">vectors</a> and <a href="std_misc/threads/../../trait/iter.html">iterators</a></li>
<li><a href="std_misc/threads/../../fn/closures.html">closures</a>, <a href="std_misc/threads/../../scope/move.html">move</a> semantics and <a href="https://doc.rust-lang.org/book/ch13-01-closures.html#closures-can-capture-their-environment"><code>move</code> closures</a></li>
<li><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values">destructuring</a> assignments</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">turbofish notation</a> to help type inference</li>
<li><a href="std_misc/threads/../../error/option_unwrap.html">unwrap vs. expect</a></li>
<li><a href="https://doc.rust-lang.org/book/loops.html#enumerate">enumerate</a></li>
</ul>
<h1><a class="header" href="#channels" id="channels">Channels</a></h1>
<p>Rust provides asynchronous <code>channels</code> for communication between threads. Channels
allow a unidirectional flow of information between two end-points: the
<code>Sender</code> and the <code>Receiver</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // Channels have two endpoints: the `Sender&lt;T&gt;` and the `Receiver&lt;T&gt;`,
    // where `T` is the type of the message to be transferred
    // (type annotation is superfluous)
    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();
    let mut children = Vec::new();

    for id in 0..NTHREADS {
        // The sender endpoint can be copied
        let thread_tx = tx.clone();

        // Each thread will send its id via the channel
        let child = thread::spawn(move || {
            // The thread takes ownership over `thread_tx`
            // Each thread queues a message in the channel
            thread_tx.send(id).unwrap();

            // Sending is a non-blocking operation, the thread will continue
            // immediately after sending its message
            println!(&quot;thread {} finished&quot;, id);
        });

        children.push(child);
    }

    // Here, all the messages are collected
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // The `recv` method picks a message from the channel
        // `recv` will block the current thread if there are no messages available
        ids.push(rx.recv());
    }
    
    // Wait for the threads to complete any remaining work
    for child in children {
        child.join().expect(&quot;oops! the child thread panicked&quot;);
    }

    // Show the order in which the messages were sent
    println!(&quot;{:?}&quot;, ids);
}
</code></pre></pre>
<h1><a class="header" href="#path" id="path">Path</a></h1>
<p>The <code>Path</code> struct represents file paths in the underlying filesystem. There are
two flavors of <code>Path</code>: <code>posix::Path</code>, for UNIX-like systems, and
<code>windows::Path</code>, for Windows. The prelude exports the appropriate
platform-specific <code>Path</code> variant.</p>
<p>A <code>Path</code> can be created from an <code>OsStr</code>, and provides several methods to get
information from the file/directory the path points to.</p>
<p>Note that a <code>Path</code> is <em>not</em> internally represented as an UTF-8 string, but
instead is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>). Therefore, converting a
<code>Path</code> to a <code>&amp;str</code> is <em>not</em> free and may fail (an <code>Option</code> is returned).</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::path::Path;

fn main() {
    // Create a `Path` from an `&amp;'static str`
    let path = Path::new(&quot;.&quot;);

    // The `display` method returns a `Show`able structure
    let _display = path.display();

    // `join` merges a path with a byte container using the OS specific
    // separator, and returns the new path
    let new_path = path.join(&quot;a&quot;).join(&quot;b&quot;);

    // Convert the path into a string slice
    match new_path.to_str() {
        None =&gt; panic!(&quot;new path is not a valid UTF-8 sequence&quot;),
        Some(s) =&gt; println!(&quot;new path is {}&quot;, s),
    }
}

</code></pre></pre>
<p>Be sure to check at other <code>Path</code> methods (<code>posix::Path</code> or <code>windows::Path</code>) and
the <code>Metadata</code> struct.</p>
<h3><a class="header" href="#see-also-5" id="see-also-5">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">OsStr</a> and <a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html">Metadata</a>.</p>
<h1><a class="header" href="#file-io" id="file-io">File I/O</a></h1>
<p>The <code>File</code> struct represents a file that has been opened (it wraps a file
descriptor), and gives read and/or write access to the underlying file.</p>
<p>Since many things can go wrong when doing file I/O, all the <code>File</code> methods
return the <code>io::Result&lt;T&gt;</code> type, which is an alias for <code>Result&lt;T, io::Error&gt;</code>.</p>
<p>This makes the failure of all I/O operations <em>explicit</em>. Thanks to this, the
programmer can see all the failure paths, and is encouraged to handle them in
a proactive manner.</p>
<h1><a class="header" href="#open" id="open"><code>open</code></a></h1>
<p>The <code>open</code> static method can be used to open a file in read-only mode.</p>
<p>A <code>File</code> owns a resource, the file descriptor and takes care of closing the
file when it is <code>drop</code>ed.</p>
<pre><code class="language-rust editable ignore">use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // Create a path to the desired file
    let path = Path::new(&quot;hello.txt&quot;);
    let display = path.display();

    // Open the path in read-only mode, returns `io::Result&lt;File&gt;`
    let mut file = match File::open(&amp;path) {
        Err(why) =&gt; panic!(&quot;couldn't open {}: {}&quot;, display, why),
        Ok(file) =&gt; file,
    };

    // Read the file contents into a string, returns `io::Result&lt;usize&gt;`
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read {}: {}&quot;, display, why),
        Ok(_) =&gt; print!(&quot;{} contains:\n{}&quot;, display, s),
    }

    // `file` goes out of scope, and the &quot;hello.txt&quot; file gets closed
}
</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-shell">$ echo &quot;Hello World!&quot; &gt; hello.txt
$ rustc open.rs &amp;&amp; ./open
hello.txt contains:
Hello World!
</code></pre>
<p>(You are encouraged to test the previous example under different failure
conditions: <code>hello.txt</code> doesn't exist, or <code>hello.txt</code> is not readable,
etc.)</p>
<h1><a class="header" href="#create" id="create"><code>create</code></a></h1>
<p>The <code>create</code> static method opens a file in write-only mode. If the file
already existed, the old content is destroyed. Otherwise, a new file is
created.</p>
<pre><code class="language-rust ignore">static LOREM_IPSUM: &amp;str =
    &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
&quot;;

use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    let path = Path::new(&quot;lorem_ipsum.txt&quot;);
    let display = path.display();

    // Open a file in write-only mode, returns `io::Result&lt;File&gt;`
    let mut file = match File::create(&amp;path) {
        Err(why) =&gt; panic!(&quot;couldn't create {}: {}&quot;, display, why),
        Ok(file) =&gt; file,
    };

    // Write the `LOREM_IPSUM` string to `file`, returns `io::Result&lt;()&gt;`
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to {}: {}&quot;, display, why),
        Ok(_) =&gt; println!(&quot;successfully wrote to {}&quot;, display),
    }
}
</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-shell">$ rustc create.rs &amp;&amp; ./create
successfully wrote to lorem_ipsum.txt
$ cat lorem_ipsum.txt
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
</code></pre>
<p>(As in the previous example, you are encouraged to test this example under
failure conditions.)</p>
<p>There is <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html"><code>OpenOptions</code></a> struct that can be used to configure how a file is opened.</p>
<h1><a class="header" href="#read_lines" id="read_lines"><code>read_lines</code></a></h1>
<p>The method <code>lines()</code> returns an iterator over the lines
of a file.</p>
<p><code>File::open</code> expects a generic, <code>AsRef&lt;Path&gt;</code>.  That's what
<code>read_lines()</code> expects as input.</p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    // File hosts must exist in current path before this produces output
    if let Ok(lines) = read_lines(&quot;./hosts&quot;) {
        // Consumes the iterator, returns an (Optional) String
        for line in lines {
            if let Ok(ip) = line {
                println!(&quot;{}&quot;, ip);
            }
        }
    }
}

// The output is wrapped in a Result to allow matching on errors
// Returns an Iterator to the Reader of the lines of the file.
fn read_lines&lt;P&gt;(filename: P) -&gt; io::Result&lt;io::Lines&lt;io::BufReader&lt;File&gt;&gt;&gt;
where P: AsRef&lt;Path&gt;, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
</code></pre></pre>
<p>Running this program simply prints the lines individually.</p>
<pre><code class="language-shell">$ echo -e &quot;127.0.0.1\n192.168.0.1\n&quot; &gt; hosts
$ rustc read_lines.rs &amp;&amp; ./read_lines
127.0.0.1
192.168.0.1
</code></pre>
<p>This process is more efficient than creating a <code>String</code> in memory
especially working with larger files.</p>
<h1><a class="header" href="#child-processes" id="child-processes">Child processes</a></h1>
<p>The <code>process::Output</code> struct represents the output of a finished child process,
and the <code>process::Command</code> struct is a process builder.</p>
<pre><code class="language-rust editable ignore">use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;--version&quot;)
        .output().unwrap_or_else(|e| {
            panic!(&quot;failed to execute process: {}&quot;, e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&amp;output.stdout);

        print!(&quot;rustc succeeded and stdout was:\n{}&quot;, s);
    } else {
        let s = String::from_utf8_lossy(&amp;output.stderr);

        print!(&quot;rustc failed and stderr was:\n{}&quot;, s);
    }
}
</code></pre>
<p>(You are encouraged to try the previous example with an incorrect flag passed
to <code>rustc</code>)</p>
<h1><a class="header" href="#pipes" id="pipes">Pipes</a></h1>
<p>The <code>std::Child</code> struct represents a running child process, and exposes the
<code>stdin</code>, <code>stdout</code> and <code>stderr</code> handles for interaction with the underlying
process via pipes.</p>
<pre><code class="language-rust ignore">use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &amp;'static str =
&quot;the quick brown fox jumped over the lazy dog\n&quot;;

fn main() {
    // Spawn the `wc` command
    let process = match Command::new(&quot;wc&quot;)
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) =&gt; panic!(&quot;couldn't spawn wc: {}&quot;, why),
        Ok(process) =&gt; process,
    };

    // Write a string to the `stdin` of `wc`.
    //
    // `stdin` has type `Option&lt;ChildStdin&gt;`, but since we know this instance
    // must have one, we can directly `unwrap` it.
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to wc stdin: {}&quot;, why),
        Ok(_) =&gt; println!(&quot;sent pangram to wc&quot;),
    }

    // Because `stdin` does not live after the above calls, it is `drop`ed,
    // and the pipe is closed.
    //
    // This is very important, otherwise `wc` wouldn't start processing the
    // input we just sent.

    // The `stdout` field also has type `Option&lt;ChildStdout&gt;` so must be unwrapped.
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read wc stdout: {}&quot;, why),
        Ok(_) =&gt; print!(&quot;wc responded with:\n{}&quot;, s),
    }
}
</code></pre>
<h1><a class="header" href="#wait" id="wait">Wait</a></h1>
<p>If you'd like to wait for a <code>process::Child</code> to finish, you must call
<code>Child::wait</code>, which will return a <code>process::ExitStatus</code>.</p>
<pre><code class="language-rust ignore">use std::process::Command;

fn main() {
    let mut child = Command::new(&quot;sleep&quot;).arg(&quot;5&quot;).spawn().unwrap();
    let _result = child.wait().unwrap();

    println!(&quot;reached end of main&quot;);
}
</code></pre>
<pre><code class="language-bash">$ rustc wait.rs &amp;&amp; ./wait
# `wait` keeps running for 5 seconds until the `sleep 5` command finishes
reached end of main
</code></pre>
<h1><a class="header" href="#filesystem-operations" id="filesystem-operations">Filesystem Operations</a></h1>
<p>The <code>std::fs</code> module contains several functions that deal with the filesystem.</p>
<pre><code class="language-rust ignore">use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
use std::os::unix;
use std::path::Path;

// A simple implementation of `% cat path`
fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// A simple implementation of `% echo s &gt; path`
fn echo(s: &amp;str, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// A simple implementation of `% touch path` (ignores existing files)
fn touch(path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) =&gt; Ok(()),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    println!(&quot;`mkdir a`&quot;);
    // Create a directory, returns `io::Result&lt;()&gt;`
    match fs::create_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(_) =&gt; {},
    }

    println!(&quot;`echo hello &gt; a/b.txt`&quot;);
    // The previous match can be simplified using the `unwrap_or_else` method
    echo(&quot;hello&quot;, &amp;Path::new(&quot;a/b.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`mkdir -p a/c/d`&quot;);
    // Recursively create a directory, returns `io::Result&lt;()&gt;`
    fs::create_dir_all(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`touch a/c/e.txt`&quot;);
    touch(&amp;Path::new(&quot;a/c/e.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`ln -s ../b.txt a/c/b.txt`&quot;);
    // Create a symbolic link, returns `io::Result&lt;()&gt;`
    if cfg!(target_family = &quot;unix&quot;) {
        unix::fs::symlink(&quot;../b.txt&quot;, &quot;a/c/b.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
        });
    }

    println!(&quot;`cat a/c/b.txt`&quot;);
    match cat(&amp;Path::new(&quot;a/c/b.txt&quot;)) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(s) =&gt; println!(&quot;&gt; {}&quot;, s),
    }

    println!(&quot;`ls a`&quot;);
    // Read the contents of a directory, returns `io::Result&lt;Vec&lt;Path&gt;&gt;`
    match fs::read_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(paths) =&gt; for path in paths {
            println!(&quot;&gt; {:?}&quot;, path.unwrap().path());
        },
    }

    println!(&quot;`rm a/c/e.txt`&quot;);
    // Remove a file, returns `io::Result&lt;()&gt;`
    fs::remove_file(&quot;a/c/e.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`rmdir a/c/d`&quot;);
    // Remove an empty directory, returns `io::Result&lt;()&gt;`
    fs::remove_dir(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });
}

</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-shell">$ rustc fs.rs &amp;&amp; ./fs
`mkdir a`
`echo hello &gt; a/b.txt`
`mkdir -p a/c/d`
`touch a/c/e.txt`
`ln -s ../b.txt a/c/b.txt`
`cat a/c/b.txt`
&gt; hello
`ls a`
&gt; &quot;a/b.txt&quot;
&gt; &quot;a/c&quot;
`rm a/c/e.txt`
`rmdir a/c/d`
</code></pre>
<p>And the final state of the <code>a</code> directory is:</p>
<pre><code class="language-shell">$ tree a
a
|-- b.txt
`-- c
    `-- b.txt -&gt; ../b.txt

1 directory, 2 files
</code></pre>
<p>An alternative way to define the function <code>cat</code> is with <code>?</code> notation:</p>
<pre><code class="language-rust ignore">fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre>
<h3><a class="header" href="#see-also-6" id="see-also-6">See also:</a></h3>
<p><a href="std_misc/../attribute/cfg.html"><code>cfg!</code></a></p>
<h1><a class="header" href="#program-arguments" id="program-arguments">Program arguments</a></h1>
<h2><a class="header" href="#standard-library" id="standard-library">Standard Library</a></h2>
<p>The command line arguments can be accessed using <code>std::env::args</code>, which
returns an iterator that yields a <code>String</code> for each argument:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    // The first argument is the path that was used to call the program.
    println!(&quot;My path is {}.&quot;, args[0]);

    // The rest of the arguments are the passed command line parameters.
    // Call the program like this:
    //   $ ./args arg1 arg2
    println!(&quot;I got {:?} arguments: {:?}.&quot;, args.len() - 1, &amp;args[1..]);
}
</code></pre></pre>
<pre><code class="language-shell">$ ./args 1 2 3
My path is ./args.
I got 3 arguments: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].
</code></pre>
<h2><a class="header" href="#crates" id="crates">Crates</a></h2>
<p>Alternatively, there are numerous crates that can provide extra functionality
when creating command-line applications. The <a href="https://rust-lang-nursery.github.io/rust-cookbook/cli/arguments.html">Rust Cookbook</a> exhibits best
practices on how to use one of the more popular command line argument crates,
<code>clap</code>.</p>
<h1><a class="header" href="#argument-parsing" id="argument-parsing">Argument parsing</a></h1>
<p>Matching can be used to parse simple arguments:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::env;

fn increase(number: i32) {
    println!(&quot;{}&quot;, number + 1);
}

fn decrease(number: i32) {
    println!(&quot;{}&quot;, number - 1);
}

fn help() {
    println!(&quot;usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {{increase|decrease}} &lt;integer&gt;
    Increase or decrease given integer by one.&quot;);
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    match args.len() {
        // no arguments passed
        1 =&gt; {
            println!(&quot;My name is 'match_args'. Try passing some arguments!&quot;);
        },
        // one argument passed
        2 =&gt; {
            match args[1].parse() {
                Ok(42) =&gt; println!(&quot;This is the answer!&quot;),
                _ =&gt; println!(&quot;This is not the answer.&quot;),
            }
        },
        // one command and one argument passed
        3 =&gt; {
            let cmd = &amp;args[1];
            let num = &amp;args[2];
            // parse the number
            let number: i32 = match num.parse() {
                Ok(n) =&gt; {
                    n
                },
                Err(_) =&gt; {
                    eprintln!(&quot;error: second argument not an integer&quot;);
                    help();
                    return;
                },
            };
            // parse the command
            match &amp;cmd[..] {
                &quot;increase&quot; =&gt; increase(number),
                &quot;decrease&quot; =&gt; decrease(number),
                _ =&gt; {
                    eprintln!(&quot;error: invalid command&quot;);
                    help();
                },
            }
        },
        // all the other cases
        _ =&gt; {
            // show a help message
            help();
        }
    }
}
</code></pre></pre>
<pre><code class="language-shell">$ ./match_args Rust
This is not the answer.
$ ./match_args 42
This is the answer!
$ ./match_args do something
error: second argument not an integer
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args do 42
error: invalid command
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args increase 42
43
</code></pre>
<h1><a class="header" href="#foreign-function-interface" id="foreign-function-interface">Foreign Function Interface</a></h1>
<p>Rust provides a Foreign Function Interface (FFI) to C libraries. Foreign
functions must be declared inside an <code>extern</code> block annotated with a <code>#[link]</code>
attribute containing the name of the foreign library.</p>
<pre><code class="language-rust ignore">use std::fmt;

// this extern block links to the libm library
#[link(name = &quot;m&quot;)]
extern {
    // this is a foreign function
    // that computes the square root of a single precision complex number
    fn csqrtf(z: Complex) -&gt; Complex;

    fn ccosf(z: Complex) -&gt; Complex;
}

// Since calling foreign functions is considered unsafe,
// it's common to write safe wrappers around them.
fn cos(z: Complex) -&gt; Complex {
    unsafe { ccosf(z) }
}

fn main() {
    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };

    // calling a foreign function is an unsafe operation
    let z_sqrt = unsafe { csqrtf(z) };

    println!(&quot;the square root of {:?} is {:?}&quot;, z, z_sqrt);

    // calling safe API wrapped around unsafe operation
    println!(&quot;cos({:?}) = {:?}&quot;, z, cos(z));
}

// Minimal implementation of single precision complex numbers
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.im &lt; 0. {
            write!(f, &quot;{}-{}i&quot;, self.re, -self.im)
        } else {
            write!(f, &quot;{}+{}i&quot;, self.re, self.im)
        }
    }
}
</code></pre>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<p>Rust is a programming language that cares a lot about correctness and it
includes support for writing software tests within the language itself.</p>
<p>Testing comes in three styles:</p>
<ul>
<li><a href="testing/unit_testing.html">Unit</a> testing.</li>
<li><a href="testing/doc_testing.html">Doc</a> testing.</li>
<li><a href="testing/integration_testing.html">Integration</a> testing.</li>
</ul>
<p>Also Rust has support for specifying additional dependencies for tests:</p>
<ul>
<li><a href="testing/dev_dependencies.html">Dev-dependencies</a></li>
</ul>
<h2><a class="header" href="#see-also-7" id="see-also-7">See Also</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-00-testing.html">The Book</a> chapter on testing</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API Guidelines</a> on doc-testing</li>
</ul>
<h1><a class="header" href="#unit-testing" id="unit-testing">Unit testing</a></h1>
<p>Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform some setup,
run the code we want to test, then assert whether the results are what we
expect.</p>
<p>Most unit tests go into a <code>tests</code> <a href="testing/../mod.html">mod</a> with the <code>#[cfg(test)]</code> <a href="testing/../attribute.html">attribute</a>.
Test functions are marked with the <code>#[test]</code> attribute.</p>
<p>Tests fail when something in the test function <a href="testing/../std/panic.html">panics</a>. There are some
helper <a href="testing/../macros.html">macros</a>:</p>
<ul>
<li><code>assert!(expression)</code> - panics if expression evaluates to <code>false</code>.</li>
<li><code>assert_eq!(left, right)</code> and <code>assert_ne!(left, right)</code> - testing left and
right expressions for equality and inequality respectively.</li>
</ul>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// This is a really bad adding function, its purpose is to fail in this
// example.
#[allow(dead_code)]
fn bad_add(a: i32, b: i32) -&gt; i32 {
    a - b
}

#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }

    #[test]
    fn test_bad_add() {
        // This assert would fire and test will fail.
        // Please note, that private functions can be tested too!
        assert_eq!(bad_add(1, 2), 3);
    }
}
</code></pre>
<p>Tests can be run with <code>cargo test</code>.</p>
<pre><code class="language-shell">$ cargo test

running 2 tests
test tests::test_bad_add ... FAILED
test tests::test_add ... ok

failures:

---- tests::test_bad_add stdout ----
        thread 'tests::test_bad_add' panicked at 'assertion failed: `(left == right)`
  left: `-1`,
 right: `3`', src/lib.rs:21:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::test_bad_add

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#tests-and-" id="tests-and-">Tests and <code>?</code></a></h2>
<p>None of the previous unit test examples had a return type. But in Rust 2018,
your unit tests can return <code>Result&lt;()&gt;</code>, which lets you use <code>?</code> in them! This
can make them much more concise.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn sqrt(number: f64) -&gt; Result&lt;f64, String&gt; {
    if number &gt;= 0.0 {
        Ok(number.powf(0.5))
    } else {
        Err(&quot;negative floats don't have square roots&quot;.to_owned())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sqrt() -&gt; Result&lt;(), String&gt; {
        let x = 4.0;
        assert_eq!(sqrt(x)?.powf(2.0), x);
        Ok(())
    }
}
</code></pre></pre>
<p>See <a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/question-mark-in-main-and-tests.html">&quot;The Edition Guide&quot;</a> for more details.</p>
<h2><a class="header" href="#testing-panics" id="testing-panics">Testing panics</a></h2>
<p>To check functions that should panic under certain circumstances, use attribute
<code>#[should_panic]</code>. This attribute accepts optional parameter <code>expected = </code> with
the text of the panic message. If your function can panic in multiple ways, it helps
make sure your test is testing the correct panic.</p>
<pre><code class="language-rust ignore">pub fn divide_non_zero_result(a: u32, b: u32) -&gt; u32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    } else if a &lt; b {
        panic!(&quot;Divide result is zero&quot;);
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = &quot;Divide result is zero&quot;)]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
}
</code></pre>
<p>Running these tests gives us:</p>
<pre><code class="language-shell">$ cargo test

running 3 tests
test tests::test_any_panic ... ok
test tests::test_divide ... ok
test tests::test_specific_panic ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#running-specific-tests" id="running-specific-tests">Running specific tests</a></h2>
<p>To run specific tests one may specify the test name to <code>cargo test</code> command.</p>
<pre><code class="language-shell">$ cargo test test_any_panic
running 1 test
test tests::test_any_panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>To run multiple tests one may specify part of a test name that matches all the
tests that should be run.</p>
<pre><code class="language-shell">$ cargo test panic
running 2 tests
test tests::test_any_panic ... ok
test tests::test_specific_panic ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#ignoring-tests" id="ignoring-tests">Ignoring tests</a></h2>
<p>Tests can be marked with the <code>#[ignore]</code> attribute to exclude some tests. Or to run
them with command <code>cargo test -- --ignored</code></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(100, 2), 102);
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(0, 0), 0);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-shell">$ cargo test
running 3 tests
test tests::ignored_test ... ignored
test tests::test_add ... ok
test tests::test_add_hundred ... ok

test result: ok. 2 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

$ cargo test -- --ignored
running 1 test
test tests::ignored_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h1><a class="header" href="#documentation-testing" id="documentation-testing">Documentation testing</a></h1>
<p>The primary way of documenting a Rust project is through annotating the source
code. Documentation comments are written in <a href="https://daringfireball.net/projects/markdown/">markdown</a> and support code
blocks in them. Rust takes care about correctness, so these code blocks are
compiled and used as tests.</p>
<pre><code class="language-rust ignore">/// First line is a short summary describing function.
///
/// The next lines present detailed documentation. Code blocks start with
/// triple backquotes and have implicit `fn main()` inside
/// and `extern crate &lt;cratename&gt;`. Assume we're testing `doccomments` crate:
///
/// ```
/// let result = doccomments::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

/// Usually doc comments may include sections &quot;Examples&quot;, &quot;Panics&quot; and &quot;Failures&quot;.
///
/// The next function divides two numbers.
///
/// # Examples
///
/// ```
/// let result = doccomments::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust,should_panic
/// // panics on division by zero
/// doccomments::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    }

    a / b
}
</code></pre>
<p>Tests can be run with <code>cargo test</code>:</p>
<pre><code class="language-shell">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests doccomments

running 3 tests
test src/lib.rs - add (line 7) ... ok
test src/lib.rs - div (line 21) ... ok
test src/lib.rs - div (line 31) ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#motivation-behind-documentation-tests" id="motivation-behind-documentation-tests">Motivation behind documentation tests</a></h2>
<p>The main purpose of documentation tests is to serve as examples that exercise
the functionality, which is one of the most important
<a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html#examples-use--not-try-not-unwrap-c-question-mark">guidelines</a>. It allows using examples from docs as
complete code snippets. But using <code>?</code> makes compilation fail since <code>main</code>
returns <code>unit</code>. The ability to hide some source lines from documentation comes
to the rescue: one may write <code>fn try_main() -&gt; Result&lt;(), ErrorType&gt;</code>, hide it and
<code>unwrap</code> it in hidden <code>main</code>. Sounds complicated? Here's an example:</p>
<pre><code class="language-rust ignore">/// Using hidden `try_main` in doc tests.
///
/// ```
/// # // hidden lines start with `#` symbol, but they're still compileable!
/// # fn try_main() -&gt; Result&lt;(), String&gt; { // line that wraps the body shown in doc
/// let res = try::try_div(10, 2)?;
/// # Ok(()) // returning from try_main
/// # }
/// # fn main() { // starting main that'll unwrap()
/// #    try_main().unwrap(); // calling try_main and unwrapping
/// #                         // so that test will panic in case of error
/// # }
/// ```
pub fn try_div(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from(&quot;Divide-by-zero&quot;))
    } else {
        Ok(a / b)
    }
}
</code></pre>
<h2><a class="header" href="#see-also-8" id="see-also-8">See Also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC505</a> on documentation style</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API Guidelines</a> on documentation guidelines</li>
</ul>
<h1><a class="header" href="#integration-testing" id="integration-testing">Integration testing</a></h1>
<p><a href="testing/unit_testing.html">Unit tests</a> are testing one module in isolation at a time: they're small
and can test private code. Integration tests are external to your crate and use
only its public interface in the same way any other code would. Their purpose is
to test that many parts of your library work correctly together.</p>
<p>Cargo looks for integration tests in <code>tests</code> directory next to <code>src</code>.</p>
<p>File <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">// Assume that crate is called adder, will have to extern it in integration test.
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
<p>File with test: <code>tests/integration_test.rs</code>:</p>
<pre><code class="language-rust ignore">// extern crate we're testing, same as any other code would do.
extern crate adder;

#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>Running tests with <code>cargo test</code> command:</p>
<pre><code class="language-shell">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-bcd60824f5fbfe19

running 1 test
test test_add ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Each Rust source file in <code>tests</code> directory is compiled as a separate crate. One
way of sharing some code between integration tests is making module with public
functions, importing and using it within tests.</p>
<p>File <code>tests/common.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn setup() {
    // some setup code, like creating required files/directories, starting
    // servers, etc.
}
</code></pre>
<p>File with test: <code>tests/integration_test.rs</code></p>
<pre><code class="language-rust ignore">// extern crate we're testing, same as any other code will do.
extern crate adder;

// importing common module.
mod common;

#[test]
fn test_add() {
    // using common code.
    common::setup();
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>Modules with common code follow the ordinary <a href="testing/../mod.html">modules</a> rules, so it's ok to
create common module as <code>tests/common/mod.rs</code>.</p>
<h1><a class="header" href="#development-dependencies" id="development-dependencies">Development dependencies</a></h1>
<p>Sometimes there is a need to have dependencies for tests (examples,
benchmarks) only. Such dependencies are added to <code>Cargo.toml</code> in the
<code>[dev-dependencies]</code> section. These dependencies are not propagated to other
packages which depend on this package.</p>
<p>One such example is using a crate that extends standard <code>assert!</code> macros.<br />
File <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># standard crate data is left out
[dev-dependencies]
pretty_assertions = &quot;0.4.0&quot;
</code></pre>
<p>File <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">// externing crate for test-only use
#[cfg(test)]
#[macro_use]
extern crate pretty_assertions;

pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
</code></pre>
<h2><a class="header" href="#see-also-9" id="see-also-9">See Also</a></h2>
<p><a href="http://doc.crates.io/specifying-dependencies.html">Cargo</a> docs on specifying dependencies.</p>
<h1><a class="header" href="#安全でない操作" id="安全でない操作">安全でない操作</a></h1>
<p>この節では、まず<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">公式ドキュメント</a>から、「one should try to minimize
the amount of unsafe code in a code base.」(安全でないコードがコードベースに
しめる割合が最小になるよう努力しなければならない。)これを念頭に置いて、始めましょう。
Rustの<code>unsafe</code>アノテーションは、コンパイラによる保護を無効化するのに使います。
<code>unsafe</code>はおもにこれらの4つのことに使われます。</p>
<ul>
<li>生ポインタを参照する</li>
<li><code>unsafe</code>な関数やメソッドを呼び出す。(FFIから関数を呼び出すときも含みます。
この本の<a href="std_misc/ffi.html">前の章</a>も参照してください。) </li>
<li>静的可変変数を変更する</li>
<li>安全でないトレイトを実装する</li>
</ul>
<h3><a class="header" href="#生ポインタ" id="生ポインタ">生ポインタ</a></h3>
<p>生ポインタ<code>*</code>と参照<code>&amp;T</code>は似ていますが、参照は有効なデータを参照していることが
ボローチェッカーによっていつも保証されています。生ポインタを参照するには<code>unsafe</code>
ブロックを使う必要があります。</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let raw_p: *const u32 = &amp;10;

    unsafe {
        assert!(*raw_p == 10);
    }
}
</code></pre></pre>
<h3><a class="header" href="#安全でない関数を呼び出す" id="安全でない関数を呼び出す">安全でない関数を呼び出す</a></h3>
<p>いくつかの関数は<code>unsafe</code>ブロックで定義されていて、これはコンパイラの代わりに
プログラマが正確性を管理しなければいけないことを意味します。一つの例は、最初の
要素のポインタと長さからスライスを作る<a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html"><code>std::slice::from_raw_parts</code></a>関数です。</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::slice;

fn main() {
    let some_vector = vec![1, 2, 3, 4];

    let pointer = some_vector.as_ptr();
    let length = some_vector.len();

    unsafe {
        let my_slice: &amp;[u32] = slice::from_raw_parts(pointer, length);

        assert_eq!(some_vector.as_slice(), my_slice);
    }
}
</code></pre></pre>
<p><code>slice::from_raw_parts</code>は、メモリのポインタが有効で、かつすべて正しい型を持っている
という一種の仮定に基づいています。これはいつも成り立つとは限らず、もし成り立たなかった
ときの動作が未定義で、何が起こるかわかりません。</p>
<h1><a class="header" href="#compatibility" id="compatibility">Compatibility</a></h1>
<p>The Rust language is fastly evolving, and because of this certain compatibility
issues can arise, despite efforts to ensure forwards-compatibility wherever
possible.</p>
<ul>
<li><a href="compatibility/raw_identifiers.html">Raw identifiers</a></li>
</ul>
<h1><a class="header" href="#raw-identifiers" id="raw-identifiers">Raw identifiers</a></h1>
<p>Rust, like many programming languages, has the concept of &quot;keywords&quot;.
These identifiers mean something to the language, and so you cannot use them in
places like variable names, function names, and other places.
Raw identifiers let you use keywords where they would not normally be allowed.
This is particularly useful when Rust introduces new keywords, and a library
using an older edition of Rust has a variable or function with the same name
as a keyword introduced in a newer edition.</p>
<p>For example, consider a crate <code>foo</code> compiled with the 2015 edition of Rust that
exports a function named <code>try</code>. This keyword is reserved for a new feature in
the 2018 edition, so without raw identifiers, we would have no way to name the
function.</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::try();
}
</code></pre>
<p>You'll get this error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `try`
 --&gt; src/main.rs:4:4
  |
4 | foo::try();
  |      ^^^ expected identifier, found keyword
</code></pre>
<p>You can write this with a raw identifier:</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::r#try();
}
</code></pre>
<h1><a class="header" href="#meta" id="meta">Meta</a></h1>
<p>Some topics aren't exactly relevant to how you program but provide you
tooling or infrastructure support which just makes things better for
everyone. These topics include:</p>
<ul>
<li><a href="meta/doc.html">Documentation</a>: Generate library documentation for users via the included
<code>rustdoc</code>.</li>
<li><a href="meta/playpen.html">Playpen</a>: Integrate the Rust Playpen(also known as the Rust Playground) in your documentation.</li>
</ul>
<h1><a class="header" href="#documentation" id="documentation">Documentation</a></h1>
<p>Use <code>cargo doc</code> to build documentation in <code>target/doc</code>.</p>
<p>Use <code>cargo test</code> to run all tests (including documentation tests), and <code>cargo test --doc</code> to only run documentation tests.</p>
<p>These commands will appropriately invoke <code>rustdoc</code> (and <code>rustc</code>) as required.</p>
<h2><a class="header" href="#doc-comments" id="doc-comments">Doc comments</a></h2>
<p>Doc comments are very useful for big projects that require documentation. When
running <code>rustdoc</code>, these are the comments that get compiled into
documentation. They are denoted by a <code>///</code>, and support <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>.</p>
<pre><code class="language-rust editable ignore">#![crate_name = &quot;doc&quot;]

/// A human being is represented here
pub struct Person {
    /// A person must have a name, no matter how much Juliet may hate it
    name: String,
}

impl Person {
    /// Returns a person with the name given them
    ///
    /// # Arguments
    ///
    /// * `name` - A string slice that holds the name of the person
    ///
    /// # Examples
    ///
    /// ```
    /// // You can have rust code between fences inside the comments
    /// // If you pass --test to `rustdoc`, it will even test it for you!
    /// use doc::Person;
    /// let person = Person::new(&quot;name&quot;);
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// Gives a friendly hello!
    ///
    /// Says &quot;Hello, [name]&quot; to the `Person` it is called on.
    pub fn hello(&amp; self) {
        println!(&quot;Hello, {}!&quot;, self.name);
    }
}

fn main() {
    let john = Person::new(&quot;John&quot;);

    john.hello();
}
</code></pre>
<p>To run the tests, first build the code as a library, then tell <code>rustdoc</code> where
to find the library so it can link it into each doctest program:</p>
<pre><code class="language-shell">$ rustc doc.rs --crate-type lib
$ rustdoc --test --extern doc=&quot;libdoc.rlib&quot; doc.rs
</code></pre>
<h2><a class="header" href="#doc-attributes" id="doc-attributes">Doc attributes</a></h2>
<p>Below are a few examples of the most common <code>#[doc]</code> attributes used with <code>rustdoc</code>.</p>
<h3><a class="header" href="#inline" id="inline"><code>inline</code></a></h3>
<p>Used to inline docs, instead of linking out to separate page.</p>
<pre><code class="language-rust ignore">#[doc(inline)]
pub use bar::Bar;

/// bar docs
mod bar {
    /// the docs for Bar
    pub struct Bar;
}
</code></pre>
<h3><a class="header" href="#no_inline" id="no_inline"><code>no_inline</code></a></h3>
<p>Used to prevent linking out to separate page or anywhere.</p>
<pre><code class="language-rust ignore">// Example from libcore/prelude
#[doc(no_inline)]
pub use crate::mem::drop;
</code></pre>
<h3><a class="header" href="#hidden" id="hidden"><code>hidden</code></a></h3>
<p>Using this tells <code>rustdoc</code> not to include this in documentation:</p>
<pre><code class="language-rust editable ignore">// Example from the futures-rs library
#[doc(hidden)]
pub use self::async_await::*;
</code></pre>
<p>For documentation, <code>rustdoc</code> is widely used by the community. It's what is used to generate the <a href="https://doc.rust-lang.org/std/">std library docs</a>.</p>
<h3><a class="header" href="#see-also-10" id="see-also-10">See also:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">The Rust Book: Making Useful Documentation Comments</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/index.html">The rustdoc Book</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/comments.html#doc-comments">The Reference: Doc comments</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1574-more-api-documentation-conventions.html#appendix-a-full-conventions-text">RFC 1574: API Documentation Conventions</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1946-intra-rustdoc-links.html">RFC 1946: Relative links to other items from doc comments (intra-rustdoc links)</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/ahb50s/is_there_any_documentation_style_guide_for/">Is there any documentation style guide for comments? (reddit)</a></li>
</ul>
<h1><a class="header" href="#playpen" id="playpen">Playpen</a></h1>
<p>The <a href="https://github.com/rust-lang/rust-playpen">Rust Playpen</a> is a way to experiment with Rust code through a web interface. This project is now commonly referred to as <a href="https://play.rust-lang.org/">Rust Playground</a>.</p>
<h2><a class="header" href="#using-it-with-mdbook" id="using-it-with-mdbook">Using it with <code>mdbook</code></a></h2>
<p>In <a href="https://github.com/rust-lang/mdBook"><code>mdbook</code></a>, you can make code examples playable and editable.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>This allows the reader to both run your code sample, but also modify and tweak it. The key here is the adding the word <code>editable</code> to your codefence block separated by a comma.</p>
<pre><code class="language-markdown">```rust,editable
//...place your code here
```
</code></pre>
<p>Additionally, you can add <code>ignore</code> if you want <code>mdbook</code> to skip your code when it builds and tests.</p>
<pre><code class="language-markdown">```rust,editable,ignore
//...place your code here
```
</code></pre>
<h2><a class="header" href="#using-it-with-docs" id="using-it-with-docs">Using it with docs</a></h2>
<p>You may have noticed in some of the <a href="https://doc.rust-lang.org/core/">official Rust docs</a> a button that says &quot;Run&quot;, which opens the code sample up in a new tab in Rust Playground. This feature is enabled if you use the #[doc] attribute called <a href="https://doc.rust-lang.org/rustdoc/the-doc-attribute.html#html_playground_url"><code>html_playground_url</code></a>.</p>
<h3><a class="header" href="#see-also-11" id="see-also-11">See also:</a></h3>
<ul>
<li><a href="https://play.rust-lang.org/">The Rust Playground</a></li>
<li><a href="https://github.com/integer32llc/rust-playground/">The next-gen playpen</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">The rustdoc Book</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
